
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Party
 * 
 */
export type Party = $Result.DefaultSelection<Prisma.$PartyPayload>
/**
 * Model Courier
 * 
 */
export type Courier = $Result.DefaultSelection<Prisma.$CourierPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model inRegister
 * 
 */
export type inRegister = $Result.DefaultSelection<Prisma.$inRegisterPayload>
/**
 * Model saleEntry
 * 
 */
export type saleEntry = $Result.DefaultSelection<Prisma.$saleEntryPayload>
/**
 * Model SalesByItem
 * 
 */
export type SalesByItem = $Result.DefaultSelection<Prisma.$SalesByItemPayload>
/**
 * Model SaleData2425
 * 
 */
export type SaleData2425 = $Result.DefaultSelection<Prisma.$SaleData2425Payload>
/**
 * Model StockItem
 * 
 */
export type StockItem = $Result.DefaultSelection<Prisma.$StockItemPayload>
/**
 * Model PermanentItem
 * 
 */
export type PermanentItem = $Result.DefaultSelection<Prisma.$PermanentItemPayload>
/**
 * Model saleTempEntry
 * 
 */
export type saleTempEntry = $Result.DefaultSelection<Prisma.$saleTempEntryPayload>
/**
 * Model CustomerPricingRule
 * 
 */
export type CustomerPricingRule = $Result.DefaultSelection<Prisma.$CustomerPricingRulePayload>
/**
 * Model ProductBatch
 * 
 */
export type ProductBatch = $Result.DefaultSelection<Prisma.$ProductBatchPayload>
/**
 * Model PurchaseEntry
 * 
 */
export type PurchaseEntry = $Result.DefaultSelection<Prisma.$PurchaseEntryPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Parties
 * const parties = await prisma.party.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Parties
   * const parties = await prisma.party.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.party`: Exposes CRUD operations for the **Party** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parties
    * const parties = await prisma.party.findMany()
    * ```
    */
  get party(): Prisma.PartyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courier`: Exposes CRUD operations for the **Courier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Couriers
    * const couriers = await prisma.courier.findMany()
    * ```
    */
  get courier(): Prisma.CourierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inRegister`: Exposes CRUD operations for the **inRegister** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InRegisters
    * const inRegisters = await prisma.inRegister.findMany()
    * ```
    */
  get inRegister(): Prisma.inRegisterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saleEntry`: Exposes CRUD operations for the **saleEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleEntries
    * const saleEntries = await prisma.saleEntry.findMany()
    * ```
    */
  get saleEntry(): Prisma.saleEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesByItem`: Exposes CRUD operations for the **SalesByItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesByItems
    * const salesByItems = await prisma.salesByItem.findMany()
    * ```
    */
  get salesByItem(): Prisma.SalesByItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saleData2425`: Exposes CRUD operations for the **SaleData2425** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleData2425s
    * const saleData2425s = await prisma.saleData2425.findMany()
    * ```
    */
  get saleData2425(): Prisma.SaleData2425Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockItem`: Exposes CRUD operations for the **StockItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockItems
    * const stockItems = await prisma.stockItem.findMany()
    * ```
    */
  get stockItem(): Prisma.StockItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permanentItem`: Exposes CRUD operations for the **PermanentItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PermanentItems
    * const permanentItems = await prisma.permanentItem.findMany()
    * ```
    */
  get permanentItem(): Prisma.PermanentItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saleTempEntry`: Exposes CRUD operations for the **saleTempEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleTempEntries
    * const saleTempEntries = await prisma.saleTempEntry.findMany()
    * ```
    */
  get saleTempEntry(): Prisma.saleTempEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerPricingRule`: Exposes CRUD operations for the **CustomerPricingRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerPricingRules
    * const customerPricingRules = await prisma.customerPricingRule.findMany()
    * ```
    */
  get customerPricingRule(): Prisma.CustomerPricingRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productBatch`: Exposes CRUD operations for the **ProductBatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductBatches
    * const productBatches = await prisma.productBatch.findMany()
    * ```
    */
  get productBatch(): Prisma.ProductBatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseEntry`: Exposes CRUD operations for the **PurchaseEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseEntries
    * const purchaseEntries = await prisma.purchaseEntry.findMany()
    * ```
    */
  get purchaseEntry(): Prisma.PurchaseEntryDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Party: 'Party',
    Courier: 'Courier',
    Department: 'Department',
    Item: 'Item',
    inRegister: 'inRegister',
    saleEntry: 'saleEntry',
    SalesByItem: 'SalesByItem',
    SaleData2425: 'SaleData2425',
    StockItem: 'StockItem',
    PermanentItem: 'PermanentItem',
    saleTempEntry: 'saleTempEntry',
    CustomerPricingRule: 'CustomerPricingRule',
    ProductBatch: 'ProductBatch',
    PurchaseEntry: 'PurchaseEntry'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "party" | "courier" | "department" | "item" | "inRegister" | "saleEntry" | "salesByItem" | "saleData2425" | "stockItem" | "permanentItem" | "saleTempEntry" | "customerPricingRule" | "productBatch" | "purchaseEntry"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Party: {
        payload: Prisma.$PartyPayload<ExtArgs>
        fields: Prisma.PartyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPayload>
          }
          findFirst: {
            args: Prisma.PartyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPayload>
          }
          findMany: {
            args: Prisma.PartyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPayload>[]
          }
          create: {
            args: Prisma.PartyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPayload>
          }
          createMany: {
            args: Prisma.PartyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PartyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPayload>[]
          }
          delete: {
            args: Prisma.PartyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPayload>
          }
          update: {
            args: Prisma.PartyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPayload>
          }
          deleteMany: {
            args: Prisma.PartyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PartyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPayload>[]
          }
          upsert: {
            args: Prisma.PartyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartyPayload>
          }
          aggregate: {
            args: Prisma.PartyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParty>
          }
          groupBy: {
            args: Prisma.PartyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartyCountArgs<ExtArgs>
            result: $Utils.Optional<PartyCountAggregateOutputType> | number
          }
        }
      }
      Courier: {
        payload: Prisma.$CourierPayload<ExtArgs>
        fields: Prisma.CourierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>
          }
          findFirst: {
            args: Prisma.CourierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>
          }
          findMany: {
            args: Prisma.CourierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>[]
          }
          create: {
            args: Prisma.CourierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>
          }
          createMany: {
            args: Prisma.CourierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>[]
          }
          delete: {
            args: Prisma.CourierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>
          }
          update: {
            args: Prisma.CourierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>
          }
          deleteMany: {
            args: Prisma.CourierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>[]
          }
          upsert: {
            args: Prisma.CourierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourierPayload>
          }
          aggregate: {
            args: Prisma.CourierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourier>
          }
          groupBy: {
            args: Prisma.CourierGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourierGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourierCountArgs<ExtArgs>
            result: $Utils.Optional<CourierCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      inRegister: {
        payload: Prisma.$inRegisterPayload<ExtArgs>
        fields: Prisma.inRegisterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inRegisterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inRegisterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inRegisterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inRegisterPayload>
          }
          findFirst: {
            args: Prisma.inRegisterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inRegisterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inRegisterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inRegisterPayload>
          }
          findMany: {
            args: Prisma.inRegisterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inRegisterPayload>[]
          }
          create: {
            args: Prisma.inRegisterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inRegisterPayload>
          }
          createMany: {
            args: Prisma.inRegisterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.inRegisterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inRegisterPayload>[]
          }
          delete: {
            args: Prisma.inRegisterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inRegisterPayload>
          }
          update: {
            args: Prisma.inRegisterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inRegisterPayload>
          }
          deleteMany: {
            args: Prisma.inRegisterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.inRegisterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.inRegisterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inRegisterPayload>[]
          }
          upsert: {
            args: Prisma.inRegisterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$inRegisterPayload>
          }
          aggregate: {
            args: Prisma.InRegisterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInRegister>
          }
          groupBy: {
            args: Prisma.inRegisterGroupByArgs<ExtArgs>
            result: $Utils.Optional<InRegisterGroupByOutputType>[]
          }
          count: {
            args: Prisma.inRegisterCountArgs<ExtArgs>
            result: $Utils.Optional<InRegisterCountAggregateOutputType> | number
          }
        }
      }
      saleEntry: {
        payload: Prisma.$saleEntryPayload<ExtArgs>
        fields: Prisma.saleEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.saleEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saleEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.saleEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saleEntryPayload>
          }
          findFirst: {
            args: Prisma.saleEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saleEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.saleEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saleEntryPayload>
          }
          findMany: {
            args: Prisma.saleEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saleEntryPayload>[]
          }
          create: {
            args: Prisma.saleEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saleEntryPayload>
          }
          createMany: {
            args: Prisma.saleEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.saleEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saleEntryPayload>[]
          }
          delete: {
            args: Prisma.saleEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saleEntryPayload>
          }
          update: {
            args: Prisma.saleEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saleEntryPayload>
          }
          deleteMany: {
            args: Prisma.saleEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.saleEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.saleEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saleEntryPayload>[]
          }
          upsert: {
            args: Prisma.saleEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saleEntryPayload>
          }
          aggregate: {
            args: Prisma.SaleEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleEntry>
          }
          groupBy: {
            args: Prisma.saleEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.saleEntryCountArgs<ExtArgs>
            result: $Utils.Optional<SaleEntryCountAggregateOutputType> | number
          }
        }
      }
      SalesByItem: {
        payload: Prisma.$SalesByItemPayload<ExtArgs>
        fields: Prisma.SalesByItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesByItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesByItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesByItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesByItemPayload>
          }
          findFirst: {
            args: Prisma.SalesByItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesByItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesByItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesByItemPayload>
          }
          findMany: {
            args: Prisma.SalesByItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesByItemPayload>[]
          }
          create: {
            args: Prisma.SalesByItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesByItemPayload>
          }
          createMany: {
            args: Prisma.SalesByItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesByItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesByItemPayload>[]
          }
          delete: {
            args: Prisma.SalesByItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesByItemPayload>
          }
          update: {
            args: Prisma.SalesByItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesByItemPayload>
          }
          deleteMany: {
            args: Prisma.SalesByItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesByItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesByItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesByItemPayload>[]
          }
          upsert: {
            args: Prisma.SalesByItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesByItemPayload>
          }
          aggregate: {
            args: Prisma.SalesByItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesByItem>
          }
          groupBy: {
            args: Prisma.SalesByItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesByItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesByItemCountArgs<ExtArgs>
            result: $Utils.Optional<SalesByItemCountAggregateOutputType> | number
          }
        }
      }
      SaleData2425: {
        payload: Prisma.$SaleData2425Payload<ExtArgs>
        fields: Prisma.SaleData2425FieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleData2425FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleData2425Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleData2425FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleData2425Payload>
          }
          findFirst: {
            args: Prisma.SaleData2425FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleData2425Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleData2425FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleData2425Payload>
          }
          findMany: {
            args: Prisma.SaleData2425FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleData2425Payload>[]
          }
          create: {
            args: Prisma.SaleData2425CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleData2425Payload>
          }
          createMany: {
            args: Prisma.SaleData2425CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleData2425CreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleData2425Payload>[]
          }
          delete: {
            args: Prisma.SaleData2425DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleData2425Payload>
          }
          update: {
            args: Prisma.SaleData2425UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleData2425Payload>
          }
          deleteMany: {
            args: Prisma.SaleData2425DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleData2425UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SaleData2425UpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleData2425Payload>[]
          }
          upsert: {
            args: Prisma.SaleData2425UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleData2425Payload>
          }
          aggregate: {
            args: Prisma.SaleData2425AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleData2425>
          }
          groupBy: {
            args: Prisma.SaleData2425GroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleData2425GroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleData2425CountArgs<ExtArgs>
            result: $Utils.Optional<SaleData2425CountAggregateOutputType> | number
          }
        }
      }
      StockItem: {
        payload: Prisma.$StockItemPayload<ExtArgs>
        fields: Prisma.StockItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>
          }
          findFirst: {
            args: Prisma.StockItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>
          }
          findMany: {
            args: Prisma.StockItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>[]
          }
          create: {
            args: Prisma.StockItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>
          }
          createMany: {
            args: Prisma.StockItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>[]
          }
          delete: {
            args: Prisma.StockItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>
          }
          update: {
            args: Prisma.StockItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>
          }
          deleteMany: {
            args: Prisma.StockItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>[]
          }
          upsert: {
            args: Prisma.StockItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockItemPayload>
          }
          aggregate: {
            args: Prisma.StockItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockItem>
          }
          groupBy: {
            args: Prisma.StockItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockItemCountArgs<ExtArgs>
            result: $Utils.Optional<StockItemCountAggregateOutputType> | number
          }
        }
      }
      PermanentItem: {
        payload: Prisma.$PermanentItemPayload<ExtArgs>
        fields: Prisma.PermanentItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermanentItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermanentItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermanentItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermanentItemPayload>
          }
          findFirst: {
            args: Prisma.PermanentItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermanentItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermanentItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermanentItemPayload>
          }
          findMany: {
            args: Prisma.PermanentItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermanentItemPayload>[]
          }
          create: {
            args: Prisma.PermanentItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermanentItemPayload>
          }
          createMany: {
            args: Prisma.PermanentItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermanentItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermanentItemPayload>[]
          }
          delete: {
            args: Prisma.PermanentItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermanentItemPayload>
          }
          update: {
            args: Prisma.PermanentItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermanentItemPayload>
          }
          deleteMany: {
            args: Prisma.PermanentItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermanentItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermanentItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermanentItemPayload>[]
          }
          upsert: {
            args: Prisma.PermanentItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermanentItemPayload>
          }
          aggregate: {
            args: Prisma.PermanentItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermanentItem>
          }
          groupBy: {
            args: Prisma.PermanentItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermanentItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermanentItemCountArgs<ExtArgs>
            result: $Utils.Optional<PermanentItemCountAggregateOutputType> | number
          }
        }
      }
      saleTempEntry: {
        payload: Prisma.$saleTempEntryPayload<ExtArgs>
        fields: Prisma.saleTempEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.saleTempEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saleTempEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.saleTempEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saleTempEntryPayload>
          }
          findFirst: {
            args: Prisma.saleTempEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saleTempEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.saleTempEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saleTempEntryPayload>
          }
          findMany: {
            args: Prisma.saleTempEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saleTempEntryPayload>[]
          }
          create: {
            args: Prisma.saleTempEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saleTempEntryPayload>
          }
          createMany: {
            args: Prisma.saleTempEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.saleTempEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saleTempEntryPayload>[]
          }
          delete: {
            args: Prisma.saleTempEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saleTempEntryPayload>
          }
          update: {
            args: Prisma.saleTempEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saleTempEntryPayload>
          }
          deleteMany: {
            args: Prisma.saleTempEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.saleTempEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.saleTempEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saleTempEntryPayload>[]
          }
          upsert: {
            args: Prisma.saleTempEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$saleTempEntryPayload>
          }
          aggregate: {
            args: Prisma.SaleTempEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleTempEntry>
          }
          groupBy: {
            args: Prisma.saleTempEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleTempEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.saleTempEntryCountArgs<ExtArgs>
            result: $Utils.Optional<SaleTempEntryCountAggregateOutputType> | number
          }
        }
      }
      CustomerPricingRule: {
        payload: Prisma.$CustomerPricingRulePayload<ExtArgs>
        fields: Prisma.CustomerPricingRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerPricingRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerPricingRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingRulePayload>
          }
          findFirst: {
            args: Prisma.CustomerPricingRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerPricingRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingRulePayload>
          }
          findMany: {
            args: Prisma.CustomerPricingRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingRulePayload>[]
          }
          create: {
            args: Prisma.CustomerPricingRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingRulePayload>
          }
          createMany: {
            args: Prisma.CustomerPricingRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerPricingRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingRulePayload>[]
          }
          delete: {
            args: Prisma.CustomerPricingRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingRulePayload>
          }
          update: {
            args: Prisma.CustomerPricingRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingRulePayload>
          }
          deleteMany: {
            args: Prisma.CustomerPricingRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerPricingRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerPricingRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingRulePayload>[]
          }
          upsert: {
            args: Prisma.CustomerPricingRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPricingRulePayload>
          }
          aggregate: {
            args: Prisma.CustomerPricingRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerPricingRule>
          }
          groupBy: {
            args: Prisma.CustomerPricingRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerPricingRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerPricingRuleCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerPricingRuleCountAggregateOutputType> | number
          }
        }
      }
      ProductBatch: {
        payload: Prisma.$ProductBatchPayload<ExtArgs>
        fields: Prisma.ProductBatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductBatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductBatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBatchPayload>
          }
          findFirst: {
            args: Prisma.ProductBatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductBatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBatchPayload>
          }
          findMany: {
            args: Prisma.ProductBatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBatchPayload>[]
          }
          create: {
            args: Prisma.ProductBatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBatchPayload>
          }
          createMany: {
            args: Prisma.ProductBatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductBatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBatchPayload>[]
          }
          delete: {
            args: Prisma.ProductBatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBatchPayload>
          }
          update: {
            args: Prisma.ProductBatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBatchPayload>
          }
          deleteMany: {
            args: Prisma.ProductBatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductBatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductBatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBatchPayload>[]
          }
          upsert: {
            args: Prisma.ProductBatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductBatchPayload>
          }
          aggregate: {
            args: Prisma.ProductBatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductBatch>
          }
          groupBy: {
            args: Prisma.ProductBatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductBatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductBatchCountArgs<ExtArgs>
            result: $Utils.Optional<ProductBatchCountAggregateOutputType> | number
          }
        }
      }
      PurchaseEntry: {
        payload: Prisma.$PurchaseEntryPayload<ExtArgs>
        fields: Prisma.PurchaseEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseEntryPayload>
          }
          findFirst: {
            args: Prisma.PurchaseEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseEntryPayload>
          }
          findMany: {
            args: Prisma.PurchaseEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseEntryPayload>[]
          }
          create: {
            args: Prisma.PurchaseEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseEntryPayload>
          }
          createMany: {
            args: Prisma.PurchaseEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseEntryPayload>[]
          }
          delete: {
            args: Prisma.PurchaseEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseEntryPayload>
          }
          update: {
            args: Prisma.PurchaseEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseEntryPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseEntryPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseEntryPayload>
          }
          aggregate: {
            args: Prisma.PurchaseEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseEntry>
          }
          groupBy: {
            args: Prisma.PurchaseEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseEntryCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseEntryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    party?: PartyOmit
    courier?: CourierOmit
    department?: DepartmentOmit
    item?: ItemOmit
    inRegister?: inRegisterOmit
    saleEntry?: saleEntryOmit
    salesByItem?: SalesByItemOmit
    saleData2425?: SaleData2425Omit
    stockItem?: StockItemOmit
    permanentItem?: PermanentItemOmit
    saleTempEntry?: saleTempEntryOmit
    customerPricingRule?: CustomerPricingRuleOmit
    productBatch?: ProductBatchOmit
    purchaseEntry?: PurchaseEntryOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PartyCountOutputType
   */

  export type PartyCountOutputType = {
    pricingRules: number
  }

  export type PartyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pricingRules?: boolean | PartyCountOutputTypeCountPricingRulesArgs
  }

  // Custom InputTypes
  /**
   * PartyCountOutputType without action
   */
  export type PartyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartyCountOutputType
     */
    select?: PartyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PartyCountOutputType without action
   */
  export type PartyCountOutputTypeCountPricingRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerPricingRuleWhereInput
  }


  /**
   * Count Type ItemCountOutputType
   */

  export type ItemCountOutputType = {
    pricingRules: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pricingRules?: boolean | ItemCountOutputTypeCountPricingRulesArgs
  }

  // Custom InputTypes
  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountPricingRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerPricingRuleWhereInput
  }


  /**
   * Count Type StockItemCountOutputType
   */

  export type StockItemCountOutputType = {
    productBatches: number
  }

  export type StockItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productBatches?: boolean | StockItemCountOutputTypeCountProductBatchesArgs
  }

  // Custom InputTypes
  /**
   * StockItemCountOutputType without action
   */
  export type StockItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItemCountOutputType
     */
    select?: StockItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StockItemCountOutputType without action
   */
  export type StockItemCountOutputTypeCountProductBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductBatchWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Party
   */

  export type AggregateParty = {
    _count: PartyCountAggregateOutputType | null
    _avg: PartyAvgAggregateOutputType | null
    _sum: PartySumAggregateOutputType | null
    _min: PartyMinAggregateOutputType | null
    _max: PartyMaxAggregateOutputType | null
  }

  export type PartyAvgAggregateOutputType = {
    id: number | null
    code: number | null
    credit: number | null
  }

  export type PartySumAggregateOutputType = {
    id: number | null
    code: number | null
    credit: number | null
  }

  export type PartyMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    code: number | null
    contact: string | null
    credit: number | null
    dlno: string | null
    gst: string | null
    state: string | null
    type: string | null
    shipping_address: string | null
    credit_period: string | null
  }

  export type PartyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    code: number | null
    contact: string | null
    credit: number | null
    dlno: string | null
    gst: string | null
    state: string | null
    type: string | null
    shipping_address: string | null
    credit_period: string | null
  }

  export type PartyCountAggregateOutputType = {
    id: number
    name: number
    address: number
    code: number
    contact: number
    credit: number
    dlno: number
    gst: number
    state: number
    type: number
    shipping_address: number
    credit_period: number
    _all: number
  }


  export type PartyAvgAggregateInputType = {
    id?: true
    code?: true
    credit?: true
  }

  export type PartySumAggregateInputType = {
    id?: true
    code?: true
    credit?: true
  }

  export type PartyMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    code?: true
    contact?: true
    credit?: true
    dlno?: true
    gst?: true
    state?: true
    type?: true
    shipping_address?: true
    credit_period?: true
  }

  export type PartyMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    code?: true
    contact?: true
    credit?: true
    dlno?: true
    gst?: true
    state?: true
    type?: true
    shipping_address?: true
    credit_period?: true
  }

  export type PartyCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    code?: true
    contact?: true
    credit?: true
    dlno?: true
    gst?: true
    state?: true
    type?: true
    shipping_address?: true
    credit_period?: true
    _all?: true
  }

  export type PartyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Party to aggregate.
     */
    where?: PartyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parties to fetch.
     */
    orderBy?: PartyOrderByWithRelationInput | PartyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parties
    **/
    _count?: true | PartyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PartyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PartySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartyMaxAggregateInputType
  }

  export type GetPartyAggregateType<T extends PartyAggregateArgs> = {
        [P in keyof T & keyof AggregateParty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParty[P]>
      : GetScalarType<T[P], AggregateParty[P]>
  }




  export type PartyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartyWhereInput
    orderBy?: PartyOrderByWithAggregationInput | PartyOrderByWithAggregationInput[]
    by: PartyScalarFieldEnum[] | PartyScalarFieldEnum
    having?: PartyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartyCountAggregateInputType | true
    _avg?: PartyAvgAggregateInputType
    _sum?: PartySumAggregateInputType
    _min?: PartyMinAggregateInputType
    _max?: PartyMaxAggregateInputType
  }

  export type PartyGroupByOutputType = {
    id: number
    name: string
    address: string | null
    code: number | null
    contact: string | null
    credit: number | null
    dlno: string | null
    gst: string | null
    state: string | null
    type: string | null
    shipping_address: string | null
    credit_period: string | null
    _count: PartyCountAggregateOutputType | null
    _avg: PartyAvgAggregateOutputType | null
    _sum: PartySumAggregateOutputType | null
    _min: PartyMinAggregateOutputType | null
    _max: PartyMaxAggregateOutputType | null
  }

  type GetPartyGroupByPayload<T extends PartyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartyGroupByOutputType[P]>
            : GetScalarType<T[P], PartyGroupByOutputType[P]>
        }
      >
    >


  export type PartySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    code?: boolean
    contact?: boolean
    credit?: boolean
    dlno?: boolean
    gst?: boolean
    state?: boolean
    type?: boolean
    shipping_address?: boolean
    credit_period?: boolean
    pricingRules?: boolean | Party$pricingRulesArgs<ExtArgs>
    _count?: boolean | PartyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["party"]>

  export type PartySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    code?: boolean
    contact?: boolean
    credit?: boolean
    dlno?: boolean
    gst?: boolean
    state?: boolean
    type?: boolean
    shipping_address?: boolean
    credit_period?: boolean
  }, ExtArgs["result"]["party"]>

  export type PartySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    code?: boolean
    contact?: boolean
    credit?: boolean
    dlno?: boolean
    gst?: boolean
    state?: boolean
    type?: boolean
    shipping_address?: boolean
    credit_period?: boolean
  }, ExtArgs["result"]["party"]>

  export type PartySelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    code?: boolean
    contact?: boolean
    credit?: boolean
    dlno?: boolean
    gst?: boolean
    state?: boolean
    type?: boolean
    shipping_address?: boolean
    credit_period?: boolean
  }

  export type PartyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "code" | "contact" | "credit" | "dlno" | "gst" | "state" | "type" | "shipping_address" | "credit_period", ExtArgs["result"]["party"]>
  export type PartyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pricingRules?: boolean | Party$pricingRulesArgs<ExtArgs>
    _count?: boolean | PartyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PartyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PartyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PartyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Party"
    objects: {
      pricingRules: Prisma.$CustomerPricingRulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string | null
      code: number | null
      contact: string | null
      credit: number | null
      dlno: string | null
      gst: string | null
      state: string | null
      type: string | null
      shipping_address: string | null
      credit_period: string | null
    }, ExtArgs["result"]["party"]>
    composites: {}
  }

  type PartyGetPayload<S extends boolean | null | undefined | PartyDefaultArgs> = $Result.GetResult<Prisma.$PartyPayload, S>

  type PartyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PartyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PartyCountAggregateInputType | true
    }

  export interface PartyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Party'], meta: { name: 'Party' } }
    /**
     * Find zero or one Party that matches the filter.
     * @param {PartyFindUniqueArgs} args - Arguments to find a Party
     * @example
     * // Get one Party
     * const party = await prisma.party.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartyFindUniqueArgs>(args: SelectSubset<T, PartyFindUniqueArgs<ExtArgs>>): Prisma__PartyClient<$Result.GetResult<Prisma.$PartyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Party that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PartyFindUniqueOrThrowArgs} args - Arguments to find a Party
     * @example
     * // Get one Party
     * const party = await prisma.party.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartyFindUniqueOrThrowArgs>(args: SelectSubset<T, PartyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartyClient<$Result.GetResult<Prisma.$PartyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Party that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyFindFirstArgs} args - Arguments to find a Party
     * @example
     * // Get one Party
     * const party = await prisma.party.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartyFindFirstArgs>(args?: SelectSubset<T, PartyFindFirstArgs<ExtArgs>>): Prisma__PartyClient<$Result.GetResult<Prisma.$PartyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Party that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyFindFirstOrThrowArgs} args - Arguments to find a Party
     * @example
     * // Get one Party
     * const party = await prisma.party.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartyFindFirstOrThrowArgs>(args?: SelectSubset<T, PartyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartyClient<$Result.GetResult<Prisma.$PartyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parties
     * const parties = await prisma.party.findMany()
     * 
     * // Get first 10 Parties
     * const parties = await prisma.party.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partyWithIdOnly = await prisma.party.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartyFindManyArgs>(args?: SelectSubset<T, PartyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Party.
     * @param {PartyCreateArgs} args - Arguments to create a Party.
     * @example
     * // Create one Party
     * const Party = await prisma.party.create({
     *   data: {
     *     // ... data to create a Party
     *   }
     * })
     * 
     */
    create<T extends PartyCreateArgs>(args: SelectSubset<T, PartyCreateArgs<ExtArgs>>): Prisma__PartyClient<$Result.GetResult<Prisma.$PartyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parties.
     * @param {PartyCreateManyArgs} args - Arguments to create many Parties.
     * @example
     * // Create many Parties
     * const party = await prisma.party.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartyCreateManyArgs>(args?: SelectSubset<T, PartyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parties and returns the data saved in the database.
     * @param {PartyCreateManyAndReturnArgs} args - Arguments to create many Parties.
     * @example
     * // Create many Parties
     * const party = await prisma.party.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parties and only return the `id`
     * const partyWithIdOnly = await prisma.party.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PartyCreateManyAndReturnArgs>(args?: SelectSubset<T, PartyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Party.
     * @param {PartyDeleteArgs} args - Arguments to delete one Party.
     * @example
     * // Delete one Party
     * const Party = await prisma.party.delete({
     *   where: {
     *     // ... filter to delete one Party
     *   }
     * })
     * 
     */
    delete<T extends PartyDeleteArgs>(args: SelectSubset<T, PartyDeleteArgs<ExtArgs>>): Prisma__PartyClient<$Result.GetResult<Prisma.$PartyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Party.
     * @param {PartyUpdateArgs} args - Arguments to update one Party.
     * @example
     * // Update one Party
     * const party = await prisma.party.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartyUpdateArgs>(args: SelectSubset<T, PartyUpdateArgs<ExtArgs>>): Prisma__PartyClient<$Result.GetResult<Prisma.$PartyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parties.
     * @param {PartyDeleteManyArgs} args - Arguments to filter Parties to delete.
     * @example
     * // Delete a few Parties
     * const { count } = await prisma.party.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartyDeleteManyArgs>(args?: SelectSubset<T, PartyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parties
     * const party = await prisma.party.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartyUpdateManyArgs>(args: SelectSubset<T, PartyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parties and returns the data updated in the database.
     * @param {PartyUpdateManyAndReturnArgs} args - Arguments to update many Parties.
     * @example
     * // Update many Parties
     * const party = await prisma.party.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Parties and only return the `id`
     * const partyWithIdOnly = await prisma.party.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PartyUpdateManyAndReturnArgs>(args: SelectSubset<T, PartyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Party.
     * @param {PartyUpsertArgs} args - Arguments to update or create a Party.
     * @example
     * // Update or create a Party
     * const party = await prisma.party.upsert({
     *   create: {
     *     // ... data to create a Party
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Party we want to update
     *   }
     * })
     */
    upsert<T extends PartyUpsertArgs>(args: SelectSubset<T, PartyUpsertArgs<ExtArgs>>): Prisma__PartyClient<$Result.GetResult<Prisma.$PartyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Parties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyCountArgs} args - Arguments to filter Parties to count.
     * @example
     * // Count the number of Parties
     * const count = await prisma.party.count({
     *   where: {
     *     // ... the filter for the Parties we want to count
     *   }
     * })
    **/
    count<T extends PartyCountArgs>(
      args?: Subset<T, PartyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Party.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartyAggregateArgs>(args: Subset<T, PartyAggregateArgs>): Prisma.PrismaPromise<GetPartyAggregateType<T>>

    /**
     * Group by Party.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartyGroupByArgs['orderBy'] }
        : { orderBy?: PartyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Party model
   */
  readonly fields: PartyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Party.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pricingRules<T extends Party$pricingRulesArgs<ExtArgs> = {}>(args?: Subset<T, Party$pricingRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPricingRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Party model
   */
  interface PartyFieldRefs {
    readonly id: FieldRef<"Party", 'Int'>
    readonly name: FieldRef<"Party", 'String'>
    readonly address: FieldRef<"Party", 'String'>
    readonly code: FieldRef<"Party", 'Int'>
    readonly contact: FieldRef<"Party", 'String'>
    readonly credit: FieldRef<"Party", 'Float'>
    readonly dlno: FieldRef<"Party", 'String'>
    readonly gst: FieldRef<"Party", 'String'>
    readonly state: FieldRef<"Party", 'String'>
    readonly type: FieldRef<"Party", 'String'>
    readonly shipping_address: FieldRef<"Party", 'String'>
    readonly credit_period: FieldRef<"Party", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Party findUnique
   */
  export type PartyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * Filter, which Party to fetch.
     */
    where: PartyWhereUniqueInput
  }

  /**
   * Party findUniqueOrThrow
   */
  export type PartyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * Filter, which Party to fetch.
     */
    where: PartyWhereUniqueInput
  }

  /**
   * Party findFirst
   */
  export type PartyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * Filter, which Party to fetch.
     */
    where?: PartyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parties to fetch.
     */
    orderBy?: PartyOrderByWithRelationInput | PartyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parties.
     */
    cursor?: PartyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parties.
     */
    distinct?: PartyScalarFieldEnum | PartyScalarFieldEnum[]
  }

  /**
   * Party findFirstOrThrow
   */
  export type PartyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * Filter, which Party to fetch.
     */
    where?: PartyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parties to fetch.
     */
    orderBy?: PartyOrderByWithRelationInput | PartyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parties.
     */
    cursor?: PartyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parties.
     */
    distinct?: PartyScalarFieldEnum | PartyScalarFieldEnum[]
  }

  /**
   * Party findMany
   */
  export type PartyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * Filter, which Parties to fetch.
     */
    where?: PartyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parties to fetch.
     */
    orderBy?: PartyOrderByWithRelationInput | PartyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parties.
     */
    cursor?: PartyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parties.
     */
    skip?: number
    distinct?: PartyScalarFieldEnum | PartyScalarFieldEnum[]
  }

  /**
   * Party create
   */
  export type PartyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * The data needed to create a Party.
     */
    data: XOR<PartyCreateInput, PartyUncheckedCreateInput>
  }

  /**
   * Party createMany
   */
  export type PartyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parties.
     */
    data: PartyCreateManyInput | PartyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Party createManyAndReturn
   */
  export type PartyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * The data used to create many Parties.
     */
    data: PartyCreateManyInput | PartyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Party update
   */
  export type PartyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * The data needed to update a Party.
     */
    data: XOR<PartyUpdateInput, PartyUncheckedUpdateInput>
    /**
     * Choose, which Party to update.
     */
    where: PartyWhereUniqueInput
  }

  /**
   * Party updateMany
   */
  export type PartyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parties.
     */
    data: XOR<PartyUpdateManyMutationInput, PartyUncheckedUpdateManyInput>
    /**
     * Filter which Parties to update
     */
    where?: PartyWhereInput
    /**
     * Limit how many Parties to update.
     */
    limit?: number
  }

  /**
   * Party updateManyAndReturn
   */
  export type PartyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * The data used to update Parties.
     */
    data: XOR<PartyUpdateManyMutationInput, PartyUncheckedUpdateManyInput>
    /**
     * Filter which Parties to update
     */
    where?: PartyWhereInput
    /**
     * Limit how many Parties to update.
     */
    limit?: number
  }

  /**
   * Party upsert
   */
  export type PartyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * The filter to search for the Party to update in case it exists.
     */
    where: PartyWhereUniqueInput
    /**
     * In case the Party found by the `where` argument doesn't exist, create a new Party with this data.
     */
    create: XOR<PartyCreateInput, PartyUncheckedCreateInput>
    /**
     * In case the Party was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartyUpdateInput, PartyUncheckedUpdateInput>
  }

  /**
   * Party delete
   */
  export type PartyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyInclude<ExtArgs> | null
    /**
     * Filter which Party to delete.
     */
    where: PartyWhereUniqueInput
  }

  /**
   * Party deleteMany
   */
  export type PartyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parties to delete
     */
    where?: PartyWhereInput
    /**
     * Limit how many Parties to delete.
     */
    limit?: number
  }

  /**
   * Party.pricingRules
   */
  export type Party$pricingRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingRule
     */
    select?: CustomerPricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingRule
     */
    omit?: CustomerPricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingRuleInclude<ExtArgs> | null
    where?: CustomerPricingRuleWhereInput
    orderBy?: CustomerPricingRuleOrderByWithRelationInput | CustomerPricingRuleOrderByWithRelationInput[]
    cursor?: CustomerPricingRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerPricingRuleScalarFieldEnum | CustomerPricingRuleScalarFieldEnum[]
  }

  /**
   * Party without action
   */
  export type PartyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Party
     */
    select?: PartySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Party
     */
    omit?: PartyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartyInclude<ExtArgs> | null
  }


  /**
   * Model Courier
   */

  export type AggregateCourier = {
    _count: CourierCountAggregateOutputType | null
    _avg: CourierAvgAggregateOutputType | null
    _sum: CourierSumAggregateOutputType | null
    _min: CourierMinAggregateOutputType | null
    _max: CourierMaxAggregateOutputType | null
  }

  export type CourierAvgAggregateOutputType = {
    id: number | null
  }

  export type CourierSumAggregateOutputType = {
    id: number | null
  }

  export type CourierMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CourierMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CourierCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CourierAvgAggregateInputType = {
    id?: true
  }

  export type CourierSumAggregateInputType = {
    id?: true
  }

  export type CourierMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CourierMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CourierCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CourierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courier to aggregate.
     */
    where?: CourierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Couriers to fetch.
     */
    orderBy?: CourierOrderByWithRelationInput | CourierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Couriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Couriers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Couriers
    **/
    _count?: true | CourierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourierMaxAggregateInputType
  }

  export type GetCourierAggregateType<T extends CourierAggregateArgs> = {
        [P in keyof T & keyof AggregateCourier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourier[P]>
      : GetScalarType<T[P], AggregateCourier[P]>
  }




  export type CourierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourierWhereInput
    orderBy?: CourierOrderByWithAggregationInput | CourierOrderByWithAggregationInput[]
    by: CourierScalarFieldEnum[] | CourierScalarFieldEnum
    having?: CourierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourierCountAggregateInputType | true
    _avg?: CourierAvgAggregateInputType
    _sum?: CourierSumAggregateInputType
    _min?: CourierMinAggregateInputType
    _max?: CourierMaxAggregateInputType
  }

  export type CourierGroupByOutputType = {
    id: number
    name: string
    _count: CourierCountAggregateOutputType | null
    _avg: CourierAvgAggregateOutputType | null
    _sum: CourierSumAggregateOutputType | null
    _min: CourierMinAggregateOutputType | null
    _max: CourierMaxAggregateOutputType | null
  }

  type GetCourierGroupByPayload<T extends CourierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourierGroupByOutputType[P]>
            : GetScalarType<T[P], CourierGroupByOutputType[P]>
        }
      >
    >


  export type CourierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["courier"]>

  export type CourierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["courier"]>

  export type CourierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["courier"]>

  export type CourierSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type CourierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["courier"]>

  export type $CourierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Courier"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["courier"]>
    composites: {}
  }

  type CourierGetPayload<S extends boolean | null | undefined | CourierDefaultArgs> = $Result.GetResult<Prisma.$CourierPayload, S>

  type CourierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourierCountAggregateInputType | true
    }

  export interface CourierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Courier'], meta: { name: 'Courier' } }
    /**
     * Find zero or one Courier that matches the filter.
     * @param {CourierFindUniqueArgs} args - Arguments to find a Courier
     * @example
     * // Get one Courier
     * const courier = await prisma.courier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourierFindUniqueArgs>(args: SelectSubset<T, CourierFindUniqueArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Courier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourierFindUniqueOrThrowArgs} args - Arguments to find a Courier
     * @example
     * // Get one Courier
     * const courier = await prisma.courier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourierFindUniqueOrThrowArgs>(args: SelectSubset<T, CourierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Courier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierFindFirstArgs} args - Arguments to find a Courier
     * @example
     * // Get one Courier
     * const courier = await prisma.courier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourierFindFirstArgs>(args?: SelectSubset<T, CourierFindFirstArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Courier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierFindFirstOrThrowArgs} args - Arguments to find a Courier
     * @example
     * // Get one Courier
     * const courier = await prisma.courier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourierFindFirstOrThrowArgs>(args?: SelectSubset<T, CourierFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Couriers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Couriers
     * const couriers = await prisma.courier.findMany()
     * 
     * // Get first 10 Couriers
     * const couriers = await prisma.courier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courierWithIdOnly = await prisma.courier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourierFindManyArgs>(args?: SelectSubset<T, CourierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Courier.
     * @param {CourierCreateArgs} args - Arguments to create a Courier.
     * @example
     * // Create one Courier
     * const Courier = await prisma.courier.create({
     *   data: {
     *     // ... data to create a Courier
     *   }
     * })
     * 
     */
    create<T extends CourierCreateArgs>(args: SelectSubset<T, CourierCreateArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Couriers.
     * @param {CourierCreateManyArgs} args - Arguments to create many Couriers.
     * @example
     * // Create many Couriers
     * const courier = await prisma.courier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourierCreateManyArgs>(args?: SelectSubset<T, CourierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Couriers and returns the data saved in the database.
     * @param {CourierCreateManyAndReturnArgs} args - Arguments to create many Couriers.
     * @example
     * // Create many Couriers
     * const courier = await prisma.courier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Couriers and only return the `id`
     * const courierWithIdOnly = await prisma.courier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourierCreateManyAndReturnArgs>(args?: SelectSubset<T, CourierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Courier.
     * @param {CourierDeleteArgs} args - Arguments to delete one Courier.
     * @example
     * // Delete one Courier
     * const Courier = await prisma.courier.delete({
     *   where: {
     *     // ... filter to delete one Courier
     *   }
     * })
     * 
     */
    delete<T extends CourierDeleteArgs>(args: SelectSubset<T, CourierDeleteArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Courier.
     * @param {CourierUpdateArgs} args - Arguments to update one Courier.
     * @example
     * // Update one Courier
     * const courier = await prisma.courier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourierUpdateArgs>(args: SelectSubset<T, CourierUpdateArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Couriers.
     * @param {CourierDeleteManyArgs} args - Arguments to filter Couriers to delete.
     * @example
     * // Delete a few Couriers
     * const { count } = await prisma.courier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourierDeleteManyArgs>(args?: SelectSubset<T, CourierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Couriers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Couriers
     * const courier = await prisma.courier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourierUpdateManyArgs>(args: SelectSubset<T, CourierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Couriers and returns the data updated in the database.
     * @param {CourierUpdateManyAndReturnArgs} args - Arguments to update many Couriers.
     * @example
     * // Update many Couriers
     * const courier = await prisma.courier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Couriers and only return the `id`
     * const courierWithIdOnly = await prisma.courier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourierUpdateManyAndReturnArgs>(args: SelectSubset<T, CourierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Courier.
     * @param {CourierUpsertArgs} args - Arguments to update or create a Courier.
     * @example
     * // Update or create a Courier
     * const courier = await prisma.courier.upsert({
     *   create: {
     *     // ... data to create a Courier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Courier we want to update
     *   }
     * })
     */
    upsert<T extends CourierUpsertArgs>(args: SelectSubset<T, CourierUpsertArgs<ExtArgs>>): Prisma__CourierClient<$Result.GetResult<Prisma.$CourierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Couriers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierCountArgs} args - Arguments to filter Couriers to count.
     * @example
     * // Count the number of Couriers
     * const count = await prisma.courier.count({
     *   where: {
     *     // ... the filter for the Couriers we want to count
     *   }
     * })
    **/
    count<T extends CourierCountArgs>(
      args?: Subset<T, CourierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Courier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourierAggregateArgs>(args: Subset<T, CourierAggregateArgs>): Prisma.PrismaPromise<GetCourierAggregateType<T>>

    /**
     * Group by Courier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourierGroupByArgs['orderBy'] }
        : { orderBy?: CourierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Courier model
   */
  readonly fields: CourierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Courier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Courier model
   */
  interface CourierFieldRefs {
    readonly id: FieldRef<"Courier", 'Int'>
    readonly name: FieldRef<"Courier", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Courier findUnique
   */
  export type CourierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * Filter, which Courier to fetch.
     */
    where: CourierWhereUniqueInput
  }

  /**
   * Courier findUniqueOrThrow
   */
  export type CourierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * Filter, which Courier to fetch.
     */
    where: CourierWhereUniqueInput
  }

  /**
   * Courier findFirst
   */
  export type CourierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * Filter, which Courier to fetch.
     */
    where?: CourierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Couriers to fetch.
     */
    orderBy?: CourierOrderByWithRelationInput | CourierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Couriers.
     */
    cursor?: CourierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Couriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Couriers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Couriers.
     */
    distinct?: CourierScalarFieldEnum | CourierScalarFieldEnum[]
  }

  /**
   * Courier findFirstOrThrow
   */
  export type CourierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * Filter, which Courier to fetch.
     */
    where?: CourierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Couriers to fetch.
     */
    orderBy?: CourierOrderByWithRelationInput | CourierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Couriers.
     */
    cursor?: CourierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Couriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Couriers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Couriers.
     */
    distinct?: CourierScalarFieldEnum | CourierScalarFieldEnum[]
  }

  /**
   * Courier findMany
   */
  export type CourierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * Filter, which Couriers to fetch.
     */
    where?: CourierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Couriers to fetch.
     */
    orderBy?: CourierOrderByWithRelationInput | CourierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Couriers.
     */
    cursor?: CourierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Couriers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Couriers.
     */
    skip?: number
    distinct?: CourierScalarFieldEnum | CourierScalarFieldEnum[]
  }

  /**
   * Courier create
   */
  export type CourierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * The data needed to create a Courier.
     */
    data: XOR<CourierCreateInput, CourierUncheckedCreateInput>
  }

  /**
   * Courier createMany
   */
  export type CourierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Couriers.
     */
    data: CourierCreateManyInput | CourierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Courier createManyAndReturn
   */
  export type CourierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * The data used to create many Couriers.
     */
    data: CourierCreateManyInput | CourierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Courier update
   */
  export type CourierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * The data needed to update a Courier.
     */
    data: XOR<CourierUpdateInput, CourierUncheckedUpdateInput>
    /**
     * Choose, which Courier to update.
     */
    where: CourierWhereUniqueInput
  }

  /**
   * Courier updateMany
   */
  export type CourierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Couriers.
     */
    data: XOR<CourierUpdateManyMutationInput, CourierUncheckedUpdateManyInput>
    /**
     * Filter which Couriers to update
     */
    where?: CourierWhereInput
    /**
     * Limit how many Couriers to update.
     */
    limit?: number
  }

  /**
   * Courier updateManyAndReturn
   */
  export type CourierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * The data used to update Couriers.
     */
    data: XOR<CourierUpdateManyMutationInput, CourierUncheckedUpdateManyInput>
    /**
     * Filter which Couriers to update
     */
    where?: CourierWhereInput
    /**
     * Limit how many Couriers to update.
     */
    limit?: number
  }

  /**
   * Courier upsert
   */
  export type CourierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * The filter to search for the Courier to update in case it exists.
     */
    where: CourierWhereUniqueInput
    /**
     * In case the Courier found by the `where` argument doesn't exist, create a new Courier with this data.
     */
    create: XOR<CourierCreateInput, CourierUncheckedCreateInput>
    /**
     * In case the Courier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourierUpdateInput, CourierUncheckedUpdateInput>
  }

  /**
   * Courier delete
   */
  export type CourierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
    /**
     * Filter which Courier to delete.
     */
    where: CourierWhereUniqueInput
  }

  /**
   * Courier deleteMany
   */
  export type CourierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Couriers to delete
     */
    where?: CourierWhereInput
    /**
     * Limit how many Couriers to delete.
     */
    limit?: number
  }

  /**
   * Courier without action
   */
  export type CourierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Courier
     */
    select?: CourierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Courier
     */
    omit?: CourierOmit<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentAvgAggregateOutputType = {
    id: number | null
  }

  export type DepartmentSumAggregateOutputType = {
    id: number | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type DepartmentAvgAggregateInputType = {
    id?: true
  }

  export type DepartmentSumAggregateInputType = {
    id?: true
  }

  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _avg?: DepartmentAvgAggregateInputType
    _sum?: DepartmentSumAggregateInputType
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: number
    name: string
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["department"]>

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'Int'>
    readonly name: FieldRef<"Department", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
  }


  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    id: number | null
    hsn: number | null
    min: number | null
    rate: number | null
    tax: number | null
    mrp: Decimal | null
    stockIn: number | null
    stockHold: number | null
    stockOut: number | null
  }

  export type ItemSumAggregateOutputType = {
    id: number | null
    hsn: number | null
    min: number | null
    rate: number | null
    tax: number | null
    mrp: Decimal | null
    stockIn: number | null
    stockHold: number | null
    stockOut: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: number | null
    name: string | null
    hsn: number | null
    min: number | null
    rate: number | null
    tax: number | null
    vendor: string | null
    mrp: Decimal | null
    stockIn: number | null
    stockHold: number | null
    stockOut: number | null
    productType: string | null
  }

  export type ItemMaxAggregateOutputType = {
    id: number | null
    name: string | null
    hsn: number | null
    min: number | null
    rate: number | null
    tax: number | null
    vendor: string | null
    mrp: Decimal | null
    stockIn: number | null
    stockHold: number | null
    stockOut: number | null
    productType: string | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    name: number
    hsn: number
    min: number
    rate: number
    tax: number
    vendor: number
    mrp: number
    stockIn: number
    stockHold: number
    stockOut: number
    effectiveStock: number
    productType: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    id?: true
    hsn?: true
    min?: true
    rate?: true
    tax?: true
    mrp?: true
    stockIn?: true
    stockHold?: true
    stockOut?: true
  }

  export type ItemSumAggregateInputType = {
    id?: true
    hsn?: true
    min?: true
    rate?: true
    tax?: true
    mrp?: true
    stockIn?: true
    stockHold?: true
    stockOut?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    name?: true
    hsn?: true
    min?: true
    rate?: true
    tax?: true
    vendor?: true
    mrp?: true
    stockIn?: true
    stockHold?: true
    stockOut?: true
    productType?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    name?: true
    hsn?: true
    min?: true
    rate?: true
    tax?: true
    vendor?: true
    mrp?: true
    stockIn?: true
    stockHold?: true
    stockOut?: true
    productType?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    name?: true
    hsn?: true
    min?: true
    rate?: true
    tax?: true
    vendor?: true
    mrp?: true
    stockIn?: true
    stockHold?: true
    stockOut?: true
    effectiveStock?: true
    productType?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: number
    name: string
    hsn: number | null
    min: number | null
    rate: number | null
    tax: number | null
    vendor: string | null
    mrp: Decimal | null
    stockIn: number | null
    stockHold: number | null
    stockOut: number | null
    effectiveStock: number
    productType: string | null
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    hsn?: boolean
    min?: boolean
    rate?: boolean
    tax?: boolean
    vendor?: boolean
    mrp?: boolean
    stockIn?: boolean
    stockHold?: boolean
    stockOut?: boolean
    productType?: boolean
    pricingRules?: boolean | Item$pricingRulesArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    hsn?: boolean
    min?: boolean
    rate?: boolean
    tax?: boolean
    vendor?: boolean
    mrp?: boolean
    stockIn?: boolean
    stockHold?: boolean
    stockOut?: boolean
    effectiveStock?: boolean
    productType?: boolean
  }, ExtArgs["result"]["item"]>

  export type ItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    hsn?: boolean
    min?: boolean
    rate?: boolean
    tax?: boolean
    vendor?: boolean
    mrp?: boolean
    stockIn?: boolean
    stockHold?: boolean
    stockOut?: boolean
    effectiveStock?: boolean
    productType?: boolean
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    id?: boolean
    name?: boolean
    hsn?: boolean
    min?: boolean
    rate?: boolean
    tax?: boolean
    vendor?: boolean
    mrp?: boolean
    stockIn?: boolean
    stockHold?: boolean
    stockOut?: boolean
    productType?: boolean
  }

  export type ItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "hsn" | "min" | "rate" | "tax" | "vendor" | "mrp" | "stockIn" | "stockHold" | "stockOut" | "productType", ExtArgs["result"]["item"]>
  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pricingRules?: boolean | Item$pricingRulesArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      pricingRules: Prisma.$CustomerPricingRulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      hsn: number | null
      min: number | null
      rate: number | null
      tax: number | null
      vendor: string | null
      mrp: Prisma.Decimal | null
      stockIn: number | null
      stockHold: number | null
      stockOut: number | null
      productType: string | null
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemFindUniqueArgs>(args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemFindFirstArgs>(args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemFindManyArgs>(args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends ItemCreateArgs>(args: SelectSubset<T, ItemCreateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Items.
     * @param {ItemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCreateManyArgs>(args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Items and returns the data saved in the database.
     * @param {ItemCreateManyAndReturnArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends ItemDeleteArgs>(args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemUpdateArgs>(args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemDeleteManyArgs>(args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemUpdateManyArgs>(args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items and returns the data updated in the database.
     * @param {ItemUpdateManyAndReturnArgs} args - Arguments to update many Items.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends ItemUpsertArgs>(args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pricingRules<T extends Item$pricingRulesArgs<ExtArgs> = {}>(args?: Subset<T, Item$pricingRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPricingRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Item model
   */
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'Int'>
    readonly name: FieldRef<"Item", 'String'>
    readonly hsn: FieldRef<"Item", 'Int'>
    readonly min: FieldRef<"Item", 'Int'>
    readonly rate: FieldRef<"Item", 'Float'>
    readonly tax: FieldRef<"Item", 'Float'>
    readonly vendor: FieldRef<"Item", 'String'>
    readonly mrp: FieldRef<"Item", 'Decimal'>
    readonly stockIn: FieldRef<"Item", 'Int'>
    readonly stockHold: FieldRef<"Item", 'Int'>
    readonly stockOut: FieldRef<"Item", 'Int'>
    readonly productType: FieldRef<"Item", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }

  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item createManyAndReturn
   */
  export type ItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item updateManyAndReturn
   */
  export type ItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to update.
     */
    limit?: number
  }

  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }

  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
    /**
     * Limit how many Items to delete.
     */
    limit?: number
  }

  /**
   * Item.pricingRules
   */
  export type Item$pricingRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingRule
     */
    select?: CustomerPricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingRule
     */
    omit?: CustomerPricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingRuleInclude<ExtArgs> | null
    where?: CustomerPricingRuleWhereInput
    orderBy?: CustomerPricingRuleOrderByWithRelationInput | CustomerPricingRuleOrderByWithRelationInput[]
    cursor?: CustomerPricingRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerPricingRuleScalarFieldEnum | CustomerPricingRuleScalarFieldEnum[]
  }

  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Item
     */
    omit?: ItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
  }


  /**
   * Model inRegister
   */

  export type AggregateInRegister = {
    _count: InRegisterCountAggregateOutputType | null
    _avg: InRegisterAvgAggregateOutputType | null
    _sum: InRegisterSumAggregateOutputType | null
    _min: InRegisterMinAggregateOutputType | null
    _max: InRegisterMaxAggregateOutputType | null
  }

  export type InRegisterAvgAggregateOutputType = {
    id: number | null
    regNo: number | null
    qty: number | null
  }

  export type InRegisterSumAggregateOutputType = {
    id: number | null
    regNo: number | null
    qty: number | null
  }

  export type InRegisterMinAggregateOutputType = {
    id: number | null
    regNo: number | null
    party: string | null
    item: string | null
    qty: number | null
    department: string | null
    deptRef: string | null
    remark: string | null
    others: string | null
    courier: string | null
    complete: string | null
    date: Date | null
  }

  export type InRegisterMaxAggregateOutputType = {
    id: number | null
    regNo: number | null
    party: string | null
    item: string | null
    qty: number | null
    department: string | null
    deptRef: string | null
    remark: string | null
    others: string | null
    courier: string | null
    complete: string | null
    date: Date | null
  }

  export type InRegisterCountAggregateOutputType = {
    id: number
    regNo: number
    party: number
    item: number
    qty: number
    department: number
    deptRef: number
    remark: number
    others: number
    courier: number
    complete: number
    date: number
    _all: number
  }


  export type InRegisterAvgAggregateInputType = {
    id?: true
    regNo?: true
    qty?: true
  }

  export type InRegisterSumAggregateInputType = {
    id?: true
    regNo?: true
    qty?: true
  }

  export type InRegisterMinAggregateInputType = {
    id?: true
    regNo?: true
    party?: true
    item?: true
    qty?: true
    department?: true
    deptRef?: true
    remark?: true
    others?: true
    courier?: true
    complete?: true
    date?: true
  }

  export type InRegisterMaxAggregateInputType = {
    id?: true
    regNo?: true
    party?: true
    item?: true
    qty?: true
    department?: true
    deptRef?: true
    remark?: true
    others?: true
    courier?: true
    complete?: true
    date?: true
  }

  export type InRegisterCountAggregateInputType = {
    id?: true
    regNo?: true
    party?: true
    item?: true
    qty?: true
    department?: true
    deptRef?: true
    remark?: true
    others?: true
    courier?: true
    complete?: true
    date?: true
    _all?: true
  }

  export type InRegisterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inRegister to aggregate.
     */
    where?: inRegisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inRegisters to fetch.
     */
    orderBy?: inRegisterOrderByWithRelationInput | inRegisterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inRegisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inRegisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inRegisters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned inRegisters
    **/
    _count?: true | InRegisterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InRegisterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InRegisterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InRegisterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InRegisterMaxAggregateInputType
  }

  export type GetInRegisterAggregateType<T extends InRegisterAggregateArgs> = {
        [P in keyof T & keyof AggregateInRegister]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInRegister[P]>
      : GetScalarType<T[P], AggregateInRegister[P]>
  }




  export type inRegisterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inRegisterWhereInput
    orderBy?: inRegisterOrderByWithAggregationInput | inRegisterOrderByWithAggregationInput[]
    by: InRegisterScalarFieldEnum[] | InRegisterScalarFieldEnum
    having?: inRegisterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InRegisterCountAggregateInputType | true
    _avg?: InRegisterAvgAggregateInputType
    _sum?: InRegisterSumAggregateInputType
    _min?: InRegisterMinAggregateInputType
    _max?: InRegisterMaxAggregateInputType
  }

  export type InRegisterGroupByOutputType = {
    id: number
    regNo: number
    party: string | null
    item: string | null
    qty: number
    department: string | null
    deptRef: string | null
    remark: string | null
    others: string | null
    courier: string | null
    complete: string | null
    date: Date
    _count: InRegisterCountAggregateOutputType | null
    _avg: InRegisterAvgAggregateOutputType | null
    _sum: InRegisterSumAggregateOutputType | null
    _min: InRegisterMinAggregateOutputType | null
    _max: InRegisterMaxAggregateOutputType | null
  }

  type GetInRegisterGroupByPayload<T extends inRegisterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InRegisterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InRegisterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InRegisterGroupByOutputType[P]>
            : GetScalarType<T[P], InRegisterGroupByOutputType[P]>
        }
      >
    >


  export type inRegisterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regNo?: boolean
    party?: boolean
    item?: boolean
    qty?: boolean
    department?: boolean
    deptRef?: boolean
    remark?: boolean
    others?: boolean
    courier?: boolean
    complete?: boolean
    date?: boolean
  }, ExtArgs["result"]["inRegister"]>

  export type inRegisterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regNo?: boolean
    party?: boolean
    item?: boolean
    qty?: boolean
    department?: boolean
    deptRef?: boolean
    remark?: boolean
    others?: boolean
    courier?: boolean
    complete?: boolean
    date?: boolean
  }, ExtArgs["result"]["inRegister"]>

  export type inRegisterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regNo?: boolean
    party?: boolean
    item?: boolean
    qty?: boolean
    department?: boolean
    deptRef?: boolean
    remark?: boolean
    others?: boolean
    courier?: boolean
    complete?: boolean
    date?: boolean
  }, ExtArgs["result"]["inRegister"]>

  export type inRegisterSelectScalar = {
    id?: boolean
    regNo?: boolean
    party?: boolean
    item?: boolean
    qty?: boolean
    department?: boolean
    deptRef?: boolean
    remark?: boolean
    others?: boolean
    courier?: boolean
    complete?: boolean
    date?: boolean
  }

  export type inRegisterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "regNo" | "party" | "item" | "qty" | "department" | "deptRef" | "remark" | "others" | "courier" | "complete" | "date", ExtArgs["result"]["inRegister"]>

  export type $inRegisterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "inRegister"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      regNo: number
      party: string | null
      item: string | null
      qty: number
      department: string | null
      deptRef: string | null
      remark: string | null
      others: string | null
      courier: string | null
      complete: string | null
      date: Date
    }, ExtArgs["result"]["inRegister"]>
    composites: {}
  }

  type inRegisterGetPayload<S extends boolean | null | undefined | inRegisterDefaultArgs> = $Result.GetResult<Prisma.$inRegisterPayload, S>

  type inRegisterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<inRegisterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InRegisterCountAggregateInputType | true
    }

  export interface inRegisterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['inRegister'], meta: { name: 'inRegister' } }
    /**
     * Find zero or one InRegister that matches the filter.
     * @param {inRegisterFindUniqueArgs} args - Arguments to find a InRegister
     * @example
     * // Get one InRegister
     * const inRegister = await prisma.inRegister.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends inRegisterFindUniqueArgs>(args: SelectSubset<T, inRegisterFindUniqueArgs<ExtArgs>>): Prisma__inRegisterClient<$Result.GetResult<Prisma.$inRegisterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InRegister that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {inRegisterFindUniqueOrThrowArgs} args - Arguments to find a InRegister
     * @example
     * // Get one InRegister
     * const inRegister = await prisma.inRegister.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends inRegisterFindUniqueOrThrowArgs>(args: SelectSubset<T, inRegisterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__inRegisterClient<$Result.GetResult<Prisma.$inRegisterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InRegister that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inRegisterFindFirstArgs} args - Arguments to find a InRegister
     * @example
     * // Get one InRegister
     * const inRegister = await prisma.inRegister.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends inRegisterFindFirstArgs>(args?: SelectSubset<T, inRegisterFindFirstArgs<ExtArgs>>): Prisma__inRegisterClient<$Result.GetResult<Prisma.$inRegisterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InRegister that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inRegisterFindFirstOrThrowArgs} args - Arguments to find a InRegister
     * @example
     * // Get one InRegister
     * const inRegister = await prisma.inRegister.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends inRegisterFindFirstOrThrowArgs>(args?: SelectSubset<T, inRegisterFindFirstOrThrowArgs<ExtArgs>>): Prisma__inRegisterClient<$Result.GetResult<Prisma.$inRegisterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InRegisters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inRegisterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InRegisters
     * const inRegisters = await prisma.inRegister.findMany()
     * 
     * // Get first 10 InRegisters
     * const inRegisters = await prisma.inRegister.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inRegisterWithIdOnly = await prisma.inRegister.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends inRegisterFindManyArgs>(args?: SelectSubset<T, inRegisterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inRegisterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InRegister.
     * @param {inRegisterCreateArgs} args - Arguments to create a InRegister.
     * @example
     * // Create one InRegister
     * const InRegister = await prisma.inRegister.create({
     *   data: {
     *     // ... data to create a InRegister
     *   }
     * })
     * 
     */
    create<T extends inRegisterCreateArgs>(args: SelectSubset<T, inRegisterCreateArgs<ExtArgs>>): Prisma__inRegisterClient<$Result.GetResult<Prisma.$inRegisterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InRegisters.
     * @param {inRegisterCreateManyArgs} args - Arguments to create many InRegisters.
     * @example
     * // Create many InRegisters
     * const inRegister = await prisma.inRegister.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends inRegisterCreateManyArgs>(args?: SelectSubset<T, inRegisterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InRegisters and returns the data saved in the database.
     * @param {inRegisterCreateManyAndReturnArgs} args - Arguments to create many InRegisters.
     * @example
     * // Create many InRegisters
     * const inRegister = await prisma.inRegister.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InRegisters and only return the `id`
     * const inRegisterWithIdOnly = await prisma.inRegister.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends inRegisterCreateManyAndReturnArgs>(args?: SelectSubset<T, inRegisterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inRegisterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InRegister.
     * @param {inRegisterDeleteArgs} args - Arguments to delete one InRegister.
     * @example
     * // Delete one InRegister
     * const InRegister = await prisma.inRegister.delete({
     *   where: {
     *     // ... filter to delete one InRegister
     *   }
     * })
     * 
     */
    delete<T extends inRegisterDeleteArgs>(args: SelectSubset<T, inRegisterDeleteArgs<ExtArgs>>): Prisma__inRegisterClient<$Result.GetResult<Prisma.$inRegisterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InRegister.
     * @param {inRegisterUpdateArgs} args - Arguments to update one InRegister.
     * @example
     * // Update one InRegister
     * const inRegister = await prisma.inRegister.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends inRegisterUpdateArgs>(args: SelectSubset<T, inRegisterUpdateArgs<ExtArgs>>): Prisma__inRegisterClient<$Result.GetResult<Prisma.$inRegisterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InRegisters.
     * @param {inRegisterDeleteManyArgs} args - Arguments to filter InRegisters to delete.
     * @example
     * // Delete a few InRegisters
     * const { count } = await prisma.inRegister.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends inRegisterDeleteManyArgs>(args?: SelectSubset<T, inRegisterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InRegisters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inRegisterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InRegisters
     * const inRegister = await prisma.inRegister.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends inRegisterUpdateManyArgs>(args: SelectSubset<T, inRegisterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InRegisters and returns the data updated in the database.
     * @param {inRegisterUpdateManyAndReturnArgs} args - Arguments to update many InRegisters.
     * @example
     * // Update many InRegisters
     * const inRegister = await prisma.inRegister.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InRegisters and only return the `id`
     * const inRegisterWithIdOnly = await prisma.inRegister.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends inRegisterUpdateManyAndReturnArgs>(args: SelectSubset<T, inRegisterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$inRegisterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InRegister.
     * @param {inRegisterUpsertArgs} args - Arguments to update or create a InRegister.
     * @example
     * // Update or create a InRegister
     * const inRegister = await prisma.inRegister.upsert({
     *   create: {
     *     // ... data to create a InRegister
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InRegister we want to update
     *   }
     * })
     */
    upsert<T extends inRegisterUpsertArgs>(args: SelectSubset<T, inRegisterUpsertArgs<ExtArgs>>): Prisma__inRegisterClient<$Result.GetResult<Prisma.$inRegisterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InRegisters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inRegisterCountArgs} args - Arguments to filter InRegisters to count.
     * @example
     * // Count the number of InRegisters
     * const count = await prisma.inRegister.count({
     *   where: {
     *     // ... the filter for the InRegisters we want to count
     *   }
     * })
    **/
    count<T extends inRegisterCountArgs>(
      args?: Subset<T, inRegisterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InRegisterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InRegister.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InRegisterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InRegisterAggregateArgs>(args: Subset<T, InRegisterAggregateArgs>): Prisma.PrismaPromise<GetInRegisterAggregateType<T>>

    /**
     * Group by InRegister.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inRegisterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inRegisterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inRegisterGroupByArgs['orderBy'] }
        : { orderBy?: inRegisterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inRegisterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInRegisterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the inRegister model
   */
  readonly fields: inRegisterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for inRegister.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inRegisterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the inRegister model
   */
  interface inRegisterFieldRefs {
    readonly id: FieldRef<"inRegister", 'Int'>
    readonly regNo: FieldRef<"inRegister", 'Int'>
    readonly party: FieldRef<"inRegister", 'String'>
    readonly item: FieldRef<"inRegister", 'String'>
    readonly qty: FieldRef<"inRegister", 'Int'>
    readonly department: FieldRef<"inRegister", 'String'>
    readonly deptRef: FieldRef<"inRegister", 'String'>
    readonly remark: FieldRef<"inRegister", 'String'>
    readonly others: FieldRef<"inRegister", 'String'>
    readonly courier: FieldRef<"inRegister", 'String'>
    readonly complete: FieldRef<"inRegister", 'String'>
    readonly date: FieldRef<"inRegister", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * inRegister findUnique
   */
  export type inRegisterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inRegister
     */
    select?: inRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inRegister
     */
    omit?: inRegisterOmit<ExtArgs> | null
    /**
     * Filter, which inRegister to fetch.
     */
    where: inRegisterWhereUniqueInput
  }

  /**
   * inRegister findUniqueOrThrow
   */
  export type inRegisterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inRegister
     */
    select?: inRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inRegister
     */
    omit?: inRegisterOmit<ExtArgs> | null
    /**
     * Filter, which inRegister to fetch.
     */
    where: inRegisterWhereUniqueInput
  }

  /**
   * inRegister findFirst
   */
  export type inRegisterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inRegister
     */
    select?: inRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inRegister
     */
    omit?: inRegisterOmit<ExtArgs> | null
    /**
     * Filter, which inRegister to fetch.
     */
    where?: inRegisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inRegisters to fetch.
     */
    orderBy?: inRegisterOrderByWithRelationInput | inRegisterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inRegisters.
     */
    cursor?: inRegisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inRegisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inRegisters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inRegisters.
     */
    distinct?: InRegisterScalarFieldEnum | InRegisterScalarFieldEnum[]
  }

  /**
   * inRegister findFirstOrThrow
   */
  export type inRegisterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inRegister
     */
    select?: inRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inRegister
     */
    omit?: inRegisterOmit<ExtArgs> | null
    /**
     * Filter, which inRegister to fetch.
     */
    where?: inRegisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inRegisters to fetch.
     */
    orderBy?: inRegisterOrderByWithRelationInput | inRegisterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for inRegisters.
     */
    cursor?: inRegisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inRegisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inRegisters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of inRegisters.
     */
    distinct?: InRegisterScalarFieldEnum | InRegisterScalarFieldEnum[]
  }

  /**
   * inRegister findMany
   */
  export type inRegisterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inRegister
     */
    select?: inRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inRegister
     */
    omit?: inRegisterOmit<ExtArgs> | null
    /**
     * Filter, which inRegisters to fetch.
     */
    where?: inRegisterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of inRegisters to fetch.
     */
    orderBy?: inRegisterOrderByWithRelationInput | inRegisterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing inRegisters.
     */
    cursor?: inRegisterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` inRegisters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` inRegisters.
     */
    skip?: number
    distinct?: InRegisterScalarFieldEnum | InRegisterScalarFieldEnum[]
  }

  /**
   * inRegister create
   */
  export type inRegisterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inRegister
     */
    select?: inRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inRegister
     */
    omit?: inRegisterOmit<ExtArgs> | null
    /**
     * The data needed to create a inRegister.
     */
    data: XOR<inRegisterCreateInput, inRegisterUncheckedCreateInput>
  }

  /**
   * inRegister createMany
   */
  export type inRegisterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many inRegisters.
     */
    data: inRegisterCreateManyInput | inRegisterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * inRegister createManyAndReturn
   */
  export type inRegisterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inRegister
     */
    select?: inRegisterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the inRegister
     */
    omit?: inRegisterOmit<ExtArgs> | null
    /**
     * The data used to create many inRegisters.
     */
    data: inRegisterCreateManyInput | inRegisterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * inRegister update
   */
  export type inRegisterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inRegister
     */
    select?: inRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inRegister
     */
    omit?: inRegisterOmit<ExtArgs> | null
    /**
     * The data needed to update a inRegister.
     */
    data: XOR<inRegisterUpdateInput, inRegisterUncheckedUpdateInput>
    /**
     * Choose, which inRegister to update.
     */
    where: inRegisterWhereUniqueInput
  }

  /**
   * inRegister updateMany
   */
  export type inRegisterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update inRegisters.
     */
    data: XOR<inRegisterUpdateManyMutationInput, inRegisterUncheckedUpdateManyInput>
    /**
     * Filter which inRegisters to update
     */
    where?: inRegisterWhereInput
    /**
     * Limit how many inRegisters to update.
     */
    limit?: number
  }

  /**
   * inRegister updateManyAndReturn
   */
  export type inRegisterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inRegister
     */
    select?: inRegisterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the inRegister
     */
    omit?: inRegisterOmit<ExtArgs> | null
    /**
     * The data used to update inRegisters.
     */
    data: XOR<inRegisterUpdateManyMutationInput, inRegisterUncheckedUpdateManyInput>
    /**
     * Filter which inRegisters to update
     */
    where?: inRegisterWhereInput
    /**
     * Limit how many inRegisters to update.
     */
    limit?: number
  }

  /**
   * inRegister upsert
   */
  export type inRegisterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inRegister
     */
    select?: inRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inRegister
     */
    omit?: inRegisterOmit<ExtArgs> | null
    /**
     * The filter to search for the inRegister to update in case it exists.
     */
    where: inRegisterWhereUniqueInput
    /**
     * In case the inRegister found by the `where` argument doesn't exist, create a new inRegister with this data.
     */
    create: XOR<inRegisterCreateInput, inRegisterUncheckedCreateInput>
    /**
     * In case the inRegister was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inRegisterUpdateInput, inRegisterUncheckedUpdateInput>
  }

  /**
   * inRegister delete
   */
  export type inRegisterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inRegister
     */
    select?: inRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inRegister
     */
    omit?: inRegisterOmit<ExtArgs> | null
    /**
     * Filter which inRegister to delete.
     */
    where: inRegisterWhereUniqueInput
  }

  /**
   * inRegister deleteMany
   */
  export type inRegisterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which inRegisters to delete
     */
    where?: inRegisterWhereInput
    /**
     * Limit how many inRegisters to delete.
     */
    limit?: number
  }

  /**
   * inRegister without action
   */
  export type inRegisterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the inRegister
     */
    select?: inRegisterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the inRegister
     */
    omit?: inRegisterOmit<ExtArgs> | null
  }


  /**
   * Model saleEntry
   */

  export type AggregateSaleEntry = {
    _count: SaleEntryCountAggregateOutputType | null
    _avg: SaleEntryAvgAggregateOutputType | null
    _sum: SaleEntrySumAggregateOutputType | null
    _min: SaleEntryMinAggregateOutputType | null
    _max: SaleEntryMaxAggregateOutputType | null
  }

  export type SaleEntryAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    sell_rate: Decimal | null
    profit: Decimal | null
  }

  export type SaleEntrySumAggregateOutputType = {
    id: number | null
    quantity: number | null
    sell_rate: Decimal | null
    profit: Decimal | null
  }

  export type SaleEntryMinAggregateOutputType = {
    id: number | null
    date: Date | null
    party_name: string | null
    invoice_number: string | null
    item_name: string | null
    quantity: number | null
    sell_rate: Decimal | null
    profit: Decimal | null
  }

  export type SaleEntryMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    party_name: string | null
    invoice_number: string | null
    item_name: string | null
    quantity: number | null
    sell_rate: Decimal | null
    profit: Decimal | null
  }

  export type SaleEntryCountAggregateOutputType = {
    id: number
    date: number
    party_name: number
    invoice_number: number
    item_name: number
    quantity: number
    sell_rate: number
    profit: number
    _all: number
  }


  export type SaleEntryAvgAggregateInputType = {
    id?: true
    quantity?: true
    sell_rate?: true
    profit?: true
  }

  export type SaleEntrySumAggregateInputType = {
    id?: true
    quantity?: true
    sell_rate?: true
    profit?: true
  }

  export type SaleEntryMinAggregateInputType = {
    id?: true
    date?: true
    party_name?: true
    invoice_number?: true
    item_name?: true
    quantity?: true
    sell_rate?: true
    profit?: true
  }

  export type SaleEntryMaxAggregateInputType = {
    id?: true
    date?: true
    party_name?: true
    invoice_number?: true
    item_name?: true
    quantity?: true
    sell_rate?: true
    profit?: true
  }

  export type SaleEntryCountAggregateInputType = {
    id?: true
    date?: true
    party_name?: true
    invoice_number?: true
    item_name?: true
    quantity?: true
    sell_rate?: true
    profit?: true
    _all?: true
  }

  export type SaleEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which saleEntry to aggregate.
     */
    where?: saleEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saleEntries to fetch.
     */
    orderBy?: saleEntryOrderByWithRelationInput | saleEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: saleEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saleEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saleEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned saleEntries
    **/
    _count?: true | SaleEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleEntryMaxAggregateInputType
  }

  export type GetSaleEntryAggregateType<T extends SaleEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleEntry[P]>
      : GetScalarType<T[P], AggregateSaleEntry[P]>
  }




  export type saleEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: saleEntryWhereInput
    orderBy?: saleEntryOrderByWithAggregationInput | saleEntryOrderByWithAggregationInput[]
    by: SaleEntryScalarFieldEnum[] | SaleEntryScalarFieldEnum
    having?: saleEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleEntryCountAggregateInputType | true
    _avg?: SaleEntryAvgAggregateInputType
    _sum?: SaleEntrySumAggregateInputType
    _min?: SaleEntryMinAggregateInputType
    _max?: SaleEntryMaxAggregateInputType
  }

  export type SaleEntryGroupByOutputType = {
    id: number
    date: Date
    party_name: string
    invoice_number: string
    item_name: string
    quantity: number
    sell_rate: Decimal
    profit: Decimal | null
    _count: SaleEntryCountAggregateOutputType | null
    _avg: SaleEntryAvgAggregateOutputType | null
    _sum: SaleEntrySumAggregateOutputType | null
    _min: SaleEntryMinAggregateOutputType | null
    _max: SaleEntryMaxAggregateOutputType | null
  }

  type GetSaleEntryGroupByPayload<T extends saleEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleEntryGroupByOutputType[P]>
            : GetScalarType<T[P], SaleEntryGroupByOutputType[P]>
        }
      >
    >


  export type saleEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    party_name?: boolean
    invoice_number?: boolean
    item_name?: boolean
    quantity?: boolean
    sell_rate?: boolean
    profit?: boolean
  }, ExtArgs["result"]["saleEntry"]>

  export type saleEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    party_name?: boolean
    invoice_number?: boolean
    item_name?: boolean
    quantity?: boolean
    sell_rate?: boolean
    profit?: boolean
  }, ExtArgs["result"]["saleEntry"]>

  export type saleEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    party_name?: boolean
    invoice_number?: boolean
    item_name?: boolean
    quantity?: boolean
    sell_rate?: boolean
    profit?: boolean
  }, ExtArgs["result"]["saleEntry"]>

  export type saleEntrySelectScalar = {
    id?: boolean
    date?: boolean
    party_name?: boolean
    invoice_number?: boolean
    item_name?: boolean
    quantity?: boolean
    sell_rate?: boolean
    profit?: boolean
  }

  export type saleEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "party_name" | "invoice_number" | "item_name" | "quantity" | "sell_rate" | "profit", ExtArgs["result"]["saleEntry"]>

  export type $saleEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "saleEntry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      party_name: string
      invoice_number: string
      item_name: string
      quantity: number
      sell_rate: Prisma.Decimal
      profit: Prisma.Decimal | null
    }, ExtArgs["result"]["saleEntry"]>
    composites: {}
  }

  type saleEntryGetPayload<S extends boolean | null | undefined | saleEntryDefaultArgs> = $Result.GetResult<Prisma.$saleEntryPayload, S>

  type saleEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<saleEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleEntryCountAggregateInputType | true
    }

  export interface saleEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['saleEntry'], meta: { name: 'saleEntry' } }
    /**
     * Find zero or one SaleEntry that matches the filter.
     * @param {saleEntryFindUniqueArgs} args - Arguments to find a SaleEntry
     * @example
     * // Get one SaleEntry
     * const saleEntry = await prisma.saleEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends saleEntryFindUniqueArgs>(args: SelectSubset<T, saleEntryFindUniqueArgs<ExtArgs>>): Prisma__saleEntryClient<$Result.GetResult<Prisma.$saleEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SaleEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {saleEntryFindUniqueOrThrowArgs} args - Arguments to find a SaleEntry
     * @example
     * // Get one SaleEntry
     * const saleEntry = await prisma.saleEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends saleEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, saleEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__saleEntryClient<$Result.GetResult<Prisma.$saleEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saleEntryFindFirstArgs} args - Arguments to find a SaleEntry
     * @example
     * // Get one SaleEntry
     * const saleEntry = await prisma.saleEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends saleEntryFindFirstArgs>(args?: SelectSubset<T, saleEntryFindFirstArgs<ExtArgs>>): Prisma__saleEntryClient<$Result.GetResult<Prisma.$saleEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saleEntryFindFirstOrThrowArgs} args - Arguments to find a SaleEntry
     * @example
     * // Get one SaleEntry
     * const saleEntry = await prisma.saleEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends saleEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, saleEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__saleEntryClient<$Result.GetResult<Prisma.$saleEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SaleEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saleEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleEntries
     * const saleEntries = await prisma.saleEntry.findMany()
     * 
     * // Get first 10 SaleEntries
     * const saleEntries = await prisma.saleEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleEntryWithIdOnly = await prisma.saleEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends saleEntryFindManyArgs>(args?: SelectSubset<T, saleEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saleEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SaleEntry.
     * @param {saleEntryCreateArgs} args - Arguments to create a SaleEntry.
     * @example
     * // Create one SaleEntry
     * const SaleEntry = await prisma.saleEntry.create({
     *   data: {
     *     // ... data to create a SaleEntry
     *   }
     * })
     * 
     */
    create<T extends saleEntryCreateArgs>(args: SelectSubset<T, saleEntryCreateArgs<ExtArgs>>): Prisma__saleEntryClient<$Result.GetResult<Prisma.$saleEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SaleEntries.
     * @param {saleEntryCreateManyArgs} args - Arguments to create many SaleEntries.
     * @example
     * // Create many SaleEntries
     * const saleEntry = await prisma.saleEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends saleEntryCreateManyArgs>(args?: SelectSubset<T, saleEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleEntries and returns the data saved in the database.
     * @param {saleEntryCreateManyAndReturnArgs} args - Arguments to create many SaleEntries.
     * @example
     * // Create many SaleEntries
     * const saleEntry = await prisma.saleEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleEntries and only return the `id`
     * const saleEntryWithIdOnly = await prisma.saleEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends saleEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, saleEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saleEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SaleEntry.
     * @param {saleEntryDeleteArgs} args - Arguments to delete one SaleEntry.
     * @example
     * // Delete one SaleEntry
     * const SaleEntry = await prisma.saleEntry.delete({
     *   where: {
     *     // ... filter to delete one SaleEntry
     *   }
     * })
     * 
     */
    delete<T extends saleEntryDeleteArgs>(args: SelectSubset<T, saleEntryDeleteArgs<ExtArgs>>): Prisma__saleEntryClient<$Result.GetResult<Prisma.$saleEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SaleEntry.
     * @param {saleEntryUpdateArgs} args - Arguments to update one SaleEntry.
     * @example
     * // Update one SaleEntry
     * const saleEntry = await prisma.saleEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends saleEntryUpdateArgs>(args: SelectSubset<T, saleEntryUpdateArgs<ExtArgs>>): Prisma__saleEntryClient<$Result.GetResult<Prisma.$saleEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SaleEntries.
     * @param {saleEntryDeleteManyArgs} args - Arguments to filter SaleEntries to delete.
     * @example
     * // Delete a few SaleEntries
     * const { count } = await prisma.saleEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends saleEntryDeleteManyArgs>(args?: SelectSubset<T, saleEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saleEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleEntries
     * const saleEntry = await prisma.saleEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends saleEntryUpdateManyArgs>(args: SelectSubset<T, saleEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleEntries and returns the data updated in the database.
     * @param {saleEntryUpdateManyAndReturnArgs} args - Arguments to update many SaleEntries.
     * @example
     * // Update many SaleEntries
     * const saleEntry = await prisma.saleEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SaleEntries and only return the `id`
     * const saleEntryWithIdOnly = await prisma.saleEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends saleEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, saleEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saleEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SaleEntry.
     * @param {saleEntryUpsertArgs} args - Arguments to update or create a SaleEntry.
     * @example
     * // Update or create a SaleEntry
     * const saleEntry = await prisma.saleEntry.upsert({
     *   create: {
     *     // ... data to create a SaleEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleEntry we want to update
     *   }
     * })
     */
    upsert<T extends saleEntryUpsertArgs>(args: SelectSubset<T, saleEntryUpsertArgs<ExtArgs>>): Prisma__saleEntryClient<$Result.GetResult<Prisma.$saleEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SaleEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saleEntryCountArgs} args - Arguments to filter SaleEntries to count.
     * @example
     * // Count the number of SaleEntries
     * const count = await prisma.saleEntry.count({
     *   where: {
     *     // ... the filter for the SaleEntries we want to count
     *   }
     * })
    **/
    count<T extends saleEntryCountArgs>(
      args?: Subset<T, saleEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleEntryAggregateArgs>(args: Subset<T, SaleEntryAggregateArgs>): Prisma.PrismaPromise<GetSaleEntryAggregateType<T>>

    /**
     * Group by SaleEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saleEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends saleEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: saleEntryGroupByArgs['orderBy'] }
        : { orderBy?: saleEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, saleEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the saleEntry model
   */
  readonly fields: saleEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for saleEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__saleEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the saleEntry model
   */
  interface saleEntryFieldRefs {
    readonly id: FieldRef<"saleEntry", 'Int'>
    readonly date: FieldRef<"saleEntry", 'DateTime'>
    readonly party_name: FieldRef<"saleEntry", 'String'>
    readonly invoice_number: FieldRef<"saleEntry", 'String'>
    readonly item_name: FieldRef<"saleEntry", 'String'>
    readonly quantity: FieldRef<"saleEntry", 'Int'>
    readonly sell_rate: FieldRef<"saleEntry", 'Decimal'>
    readonly profit: FieldRef<"saleEntry", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * saleEntry findUnique
   */
  export type saleEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleEntry
     */
    select?: saleEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the saleEntry
     */
    omit?: saleEntryOmit<ExtArgs> | null
    /**
     * Filter, which saleEntry to fetch.
     */
    where: saleEntryWhereUniqueInput
  }

  /**
   * saleEntry findUniqueOrThrow
   */
  export type saleEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleEntry
     */
    select?: saleEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the saleEntry
     */
    omit?: saleEntryOmit<ExtArgs> | null
    /**
     * Filter, which saleEntry to fetch.
     */
    where: saleEntryWhereUniqueInput
  }

  /**
   * saleEntry findFirst
   */
  export type saleEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleEntry
     */
    select?: saleEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the saleEntry
     */
    omit?: saleEntryOmit<ExtArgs> | null
    /**
     * Filter, which saleEntry to fetch.
     */
    where?: saleEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saleEntries to fetch.
     */
    orderBy?: saleEntryOrderByWithRelationInput | saleEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for saleEntries.
     */
    cursor?: saleEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saleEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saleEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of saleEntries.
     */
    distinct?: SaleEntryScalarFieldEnum | SaleEntryScalarFieldEnum[]
  }

  /**
   * saleEntry findFirstOrThrow
   */
  export type saleEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleEntry
     */
    select?: saleEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the saleEntry
     */
    omit?: saleEntryOmit<ExtArgs> | null
    /**
     * Filter, which saleEntry to fetch.
     */
    where?: saleEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saleEntries to fetch.
     */
    orderBy?: saleEntryOrderByWithRelationInput | saleEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for saleEntries.
     */
    cursor?: saleEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saleEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saleEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of saleEntries.
     */
    distinct?: SaleEntryScalarFieldEnum | SaleEntryScalarFieldEnum[]
  }

  /**
   * saleEntry findMany
   */
  export type saleEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleEntry
     */
    select?: saleEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the saleEntry
     */
    omit?: saleEntryOmit<ExtArgs> | null
    /**
     * Filter, which saleEntries to fetch.
     */
    where?: saleEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saleEntries to fetch.
     */
    orderBy?: saleEntryOrderByWithRelationInput | saleEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing saleEntries.
     */
    cursor?: saleEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saleEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saleEntries.
     */
    skip?: number
    distinct?: SaleEntryScalarFieldEnum | SaleEntryScalarFieldEnum[]
  }

  /**
   * saleEntry create
   */
  export type saleEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleEntry
     */
    select?: saleEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the saleEntry
     */
    omit?: saleEntryOmit<ExtArgs> | null
    /**
     * The data needed to create a saleEntry.
     */
    data: XOR<saleEntryCreateInput, saleEntryUncheckedCreateInput>
  }

  /**
   * saleEntry createMany
   */
  export type saleEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many saleEntries.
     */
    data: saleEntryCreateManyInput | saleEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * saleEntry createManyAndReturn
   */
  export type saleEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleEntry
     */
    select?: saleEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the saleEntry
     */
    omit?: saleEntryOmit<ExtArgs> | null
    /**
     * The data used to create many saleEntries.
     */
    data: saleEntryCreateManyInput | saleEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * saleEntry update
   */
  export type saleEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleEntry
     */
    select?: saleEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the saleEntry
     */
    omit?: saleEntryOmit<ExtArgs> | null
    /**
     * The data needed to update a saleEntry.
     */
    data: XOR<saleEntryUpdateInput, saleEntryUncheckedUpdateInput>
    /**
     * Choose, which saleEntry to update.
     */
    where: saleEntryWhereUniqueInput
  }

  /**
   * saleEntry updateMany
   */
  export type saleEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update saleEntries.
     */
    data: XOR<saleEntryUpdateManyMutationInput, saleEntryUncheckedUpdateManyInput>
    /**
     * Filter which saleEntries to update
     */
    where?: saleEntryWhereInput
    /**
     * Limit how many saleEntries to update.
     */
    limit?: number
  }

  /**
   * saleEntry updateManyAndReturn
   */
  export type saleEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleEntry
     */
    select?: saleEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the saleEntry
     */
    omit?: saleEntryOmit<ExtArgs> | null
    /**
     * The data used to update saleEntries.
     */
    data: XOR<saleEntryUpdateManyMutationInput, saleEntryUncheckedUpdateManyInput>
    /**
     * Filter which saleEntries to update
     */
    where?: saleEntryWhereInput
    /**
     * Limit how many saleEntries to update.
     */
    limit?: number
  }

  /**
   * saleEntry upsert
   */
  export type saleEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleEntry
     */
    select?: saleEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the saleEntry
     */
    omit?: saleEntryOmit<ExtArgs> | null
    /**
     * The filter to search for the saleEntry to update in case it exists.
     */
    where: saleEntryWhereUniqueInput
    /**
     * In case the saleEntry found by the `where` argument doesn't exist, create a new saleEntry with this data.
     */
    create: XOR<saleEntryCreateInput, saleEntryUncheckedCreateInput>
    /**
     * In case the saleEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<saleEntryUpdateInput, saleEntryUncheckedUpdateInput>
  }

  /**
   * saleEntry delete
   */
  export type saleEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleEntry
     */
    select?: saleEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the saleEntry
     */
    omit?: saleEntryOmit<ExtArgs> | null
    /**
     * Filter which saleEntry to delete.
     */
    where: saleEntryWhereUniqueInput
  }

  /**
   * saleEntry deleteMany
   */
  export type saleEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which saleEntries to delete
     */
    where?: saleEntryWhereInput
    /**
     * Limit how many saleEntries to delete.
     */
    limit?: number
  }

  /**
   * saleEntry without action
   */
  export type saleEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleEntry
     */
    select?: saleEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the saleEntry
     */
    omit?: saleEntryOmit<ExtArgs> | null
  }


  /**
   * Model SalesByItem
   */

  export type AggregateSalesByItem = {
    _count: SalesByItemCountAggregateOutputType | null
    _avg: SalesByItemAvgAggregateOutputType | null
    _sum: SalesByItemSumAggregateOutputType | null
    _min: SalesByItemMinAggregateOutputType | null
    _max: SalesByItemMaxAggregateOutputType | null
  }

  export type SalesByItemAvgAggregateOutputType = {
    id: number | null
    qty: number | null
  }

  export type SalesByItemSumAggregateOutputType = {
    id: number | null
    qty: number | null
  }

  export type SalesByItemMinAggregateOutputType = {
    id: number | null
    date: Date | null
    itemname: string | null
    qty: number | null
  }

  export type SalesByItemMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    itemname: string | null
    qty: number | null
  }

  export type SalesByItemCountAggregateOutputType = {
    id: number
    date: number
    itemname: number
    qty: number
    _all: number
  }


  export type SalesByItemAvgAggregateInputType = {
    id?: true
    qty?: true
  }

  export type SalesByItemSumAggregateInputType = {
    id?: true
    qty?: true
  }

  export type SalesByItemMinAggregateInputType = {
    id?: true
    date?: true
    itemname?: true
    qty?: true
  }

  export type SalesByItemMaxAggregateInputType = {
    id?: true
    date?: true
    itemname?: true
    qty?: true
  }

  export type SalesByItemCountAggregateInputType = {
    id?: true
    date?: true
    itemname?: true
    qty?: true
    _all?: true
  }

  export type SalesByItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesByItem to aggregate.
     */
    where?: SalesByItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesByItems to fetch.
     */
    orderBy?: SalesByItemOrderByWithRelationInput | SalesByItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesByItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesByItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesByItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesByItems
    **/
    _count?: true | SalesByItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesByItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesByItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesByItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesByItemMaxAggregateInputType
  }

  export type GetSalesByItemAggregateType<T extends SalesByItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesByItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesByItem[P]>
      : GetScalarType<T[P], AggregateSalesByItem[P]>
  }




  export type SalesByItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesByItemWhereInput
    orderBy?: SalesByItemOrderByWithAggregationInput | SalesByItemOrderByWithAggregationInput[]
    by: SalesByItemScalarFieldEnum[] | SalesByItemScalarFieldEnum
    having?: SalesByItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesByItemCountAggregateInputType | true
    _avg?: SalesByItemAvgAggregateInputType
    _sum?: SalesByItemSumAggregateInputType
    _min?: SalesByItemMinAggregateInputType
    _max?: SalesByItemMaxAggregateInputType
  }

  export type SalesByItemGroupByOutputType = {
    id: number
    date: Date
    itemname: string
    qty: number
    _count: SalesByItemCountAggregateOutputType | null
    _avg: SalesByItemAvgAggregateOutputType | null
    _sum: SalesByItemSumAggregateOutputType | null
    _min: SalesByItemMinAggregateOutputType | null
    _max: SalesByItemMaxAggregateOutputType | null
  }

  type GetSalesByItemGroupByPayload<T extends SalesByItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesByItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesByItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesByItemGroupByOutputType[P]>
            : GetScalarType<T[P], SalesByItemGroupByOutputType[P]>
        }
      >
    >


  export type SalesByItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    itemname?: boolean
    qty?: boolean
  }, ExtArgs["result"]["salesByItem"]>

  export type SalesByItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    itemname?: boolean
    qty?: boolean
  }, ExtArgs["result"]["salesByItem"]>

  export type SalesByItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    itemname?: boolean
    qty?: boolean
  }, ExtArgs["result"]["salesByItem"]>

  export type SalesByItemSelectScalar = {
    id?: boolean
    date?: boolean
    itemname?: boolean
    qty?: boolean
  }

  export type SalesByItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "itemname" | "qty", ExtArgs["result"]["salesByItem"]>

  export type $SalesByItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesByItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      itemname: string
      qty: number
    }, ExtArgs["result"]["salesByItem"]>
    composites: {}
  }

  type SalesByItemGetPayload<S extends boolean | null | undefined | SalesByItemDefaultArgs> = $Result.GetResult<Prisma.$SalesByItemPayload, S>

  type SalesByItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesByItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesByItemCountAggregateInputType | true
    }

  export interface SalesByItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesByItem'], meta: { name: 'SalesByItem' } }
    /**
     * Find zero or one SalesByItem that matches the filter.
     * @param {SalesByItemFindUniqueArgs} args - Arguments to find a SalesByItem
     * @example
     * // Get one SalesByItem
     * const salesByItem = await prisma.salesByItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesByItemFindUniqueArgs>(args: SelectSubset<T, SalesByItemFindUniqueArgs<ExtArgs>>): Prisma__SalesByItemClient<$Result.GetResult<Prisma.$SalesByItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesByItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesByItemFindUniqueOrThrowArgs} args - Arguments to find a SalesByItem
     * @example
     * // Get one SalesByItem
     * const salesByItem = await prisma.salesByItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesByItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesByItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesByItemClient<$Result.GetResult<Prisma.$SalesByItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesByItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesByItemFindFirstArgs} args - Arguments to find a SalesByItem
     * @example
     * // Get one SalesByItem
     * const salesByItem = await prisma.salesByItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesByItemFindFirstArgs>(args?: SelectSubset<T, SalesByItemFindFirstArgs<ExtArgs>>): Prisma__SalesByItemClient<$Result.GetResult<Prisma.$SalesByItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesByItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesByItemFindFirstOrThrowArgs} args - Arguments to find a SalesByItem
     * @example
     * // Get one SalesByItem
     * const salesByItem = await prisma.salesByItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesByItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesByItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesByItemClient<$Result.GetResult<Prisma.$SalesByItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesByItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesByItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesByItems
     * const salesByItems = await prisma.salesByItem.findMany()
     * 
     * // Get first 10 SalesByItems
     * const salesByItems = await prisma.salesByItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesByItemWithIdOnly = await prisma.salesByItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesByItemFindManyArgs>(args?: SelectSubset<T, SalesByItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesByItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesByItem.
     * @param {SalesByItemCreateArgs} args - Arguments to create a SalesByItem.
     * @example
     * // Create one SalesByItem
     * const SalesByItem = await prisma.salesByItem.create({
     *   data: {
     *     // ... data to create a SalesByItem
     *   }
     * })
     * 
     */
    create<T extends SalesByItemCreateArgs>(args: SelectSubset<T, SalesByItemCreateArgs<ExtArgs>>): Prisma__SalesByItemClient<$Result.GetResult<Prisma.$SalesByItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesByItems.
     * @param {SalesByItemCreateManyArgs} args - Arguments to create many SalesByItems.
     * @example
     * // Create many SalesByItems
     * const salesByItem = await prisma.salesByItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesByItemCreateManyArgs>(args?: SelectSubset<T, SalesByItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesByItems and returns the data saved in the database.
     * @param {SalesByItemCreateManyAndReturnArgs} args - Arguments to create many SalesByItems.
     * @example
     * // Create many SalesByItems
     * const salesByItem = await prisma.salesByItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesByItems and only return the `id`
     * const salesByItemWithIdOnly = await prisma.salesByItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesByItemCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesByItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesByItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesByItem.
     * @param {SalesByItemDeleteArgs} args - Arguments to delete one SalesByItem.
     * @example
     * // Delete one SalesByItem
     * const SalesByItem = await prisma.salesByItem.delete({
     *   where: {
     *     // ... filter to delete one SalesByItem
     *   }
     * })
     * 
     */
    delete<T extends SalesByItemDeleteArgs>(args: SelectSubset<T, SalesByItemDeleteArgs<ExtArgs>>): Prisma__SalesByItemClient<$Result.GetResult<Prisma.$SalesByItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesByItem.
     * @param {SalesByItemUpdateArgs} args - Arguments to update one SalesByItem.
     * @example
     * // Update one SalesByItem
     * const salesByItem = await prisma.salesByItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesByItemUpdateArgs>(args: SelectSubset<T, SalesByItemUpdateArgs<ExtArgs>>): Prisma__SalesByItemClient<$Result.GetResult<Prisma.$SalesByItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesByItems.
     * @param {SalesByItemDeleteManyArgs} args - Arguments to filter SalesByItems to delete.
     * @example
     * // Delete a few SalesByItems
     * const { count } = await prisma.salesByItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesByItemDeleteManyArgs>(args?: SelectSubset<T, SalesByItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesByItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesByItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesByItems
     * const salesByItem = await prisma.salesByItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesByItemUpdateManyArgs>(args: SelectSubset<T, SalesByItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesByItems and returns the data updated in the database.
     * @param {SalesByItemUpdateManyAndReturnArgs} args - Arguments to update many SalesByItems.
     * @example
     * // Update many SalesByItems
     * const salesByItem = await prisma.salesByItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesByItems and only return the `id`
     * const salesByItemWithIdOnly = await prisma.salesByItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesByItemUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesByItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesByItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesByItem.
     * @param {SalesByItemUpsertArgs} args - Arguments to update or create a SalesByItem.
     * @example
     * // Update or create a SalesByItem
     * const salesByItem = await prisma.salesByItem.upsert({
     *   create: {
     *     // ... data to create a SalesByItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesByItem we want to update
     *   }
     * })
     */
    upsert<T extends SalesByItemUpsertArgs>(args: SelectSubset<T, SalesByItemUpsertArgs<ExtArgs>>): Prisma__SalesByItemClient<$Result.GetResult<Prisma.$SalesByItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesByItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesByItemCountArgs} args - Arguments to filter SalesByItems to count.
     * @example
     * // Count the number of SalesByItems
     * const count = await prisma.salesByItem.count({
     *   where: {
     *     // ... the filter for the SalesByItems we want to count
     *   }
     * })
    **/
    count<T extends SalesByItemCountArgs>(
      args?: Subset<T, SalesByItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesByItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesByItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesByItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesByItemAggregateArgs>(args: Subset<T, SalesByItemAggregateArgs>): Prisma.PrismaPromise<GetSalesByItemAggregateType<T>>

    /**
     * Group by SalesByItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesByItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesByItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesByItemGroupByArgs['orderBy'] }
        : { orderBy?: SalesByItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesByItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesByItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesByItem model
   */
  readonly fields: SalesByItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesByItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesByItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesByItem model
   */
  interface SalesByItemFieldRefs {
    readonly id: FieldRef<"SalesByItem", 'Int'>
    readonly date: FieldRef<"SalesByItem", 'DateTime'>
    readonly itemname: FieldRef<"SalesByItem", 'String'>
    readonly qty: FieldRef<"SalesByItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SalesByItem findUnique
   */
  export type SalesByItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesByItem
     */
    select?: SalesByItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesByItem
     */
    omit?: SalesByItemOmit<ExtArgs> | null
    /**
     * Filter, which SalesByItem to fetch.
     */
    where: SalesByItemWhereUniqueInput
  }

  /**
   * SalesByItem findUniqueOrThrow
   */
  export type SalesByItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesByItem
     */
    select?: SalesByItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesByItem
     */
    omit?: SalesByItemOmit<ExtArgs> | null
    /**
     * Filter, which SalesByItem to fetch.
     */
    where: SalesByItemWhereUniqueInput
  }

  /**
   * SalesByItem findFirst
   */
  export type SalesByItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesByItem
     */
    select?: SalesByItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesByItem
     */
    omit?: SalesByItemOmit<ExtArgs> | null
    /**
     * Filter, which SalesByItem to fetch.
     */
    where?: SalesByItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesByItems to fetch.
     */
    orderBy?: SalesByItemOrderByWithRelationInput | SalesByItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesByItems.
     */
    cursor?: SalesByItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesByItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesByItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesByItems.
     */
    distinct?: SalesByItemScalarFieldEnum | SalesByItemScalarFieldEnum[]
  }

  /**
   * SalesByItem findFirstOrThrow
   */
  export type SalesByItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesByItem
     */
    select?: SalesByItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesByItem
     */
    omit?: SalesByItemOmit<ExtArgs> | null
    /**
     * Filter, which SalesByItem to fetch.
     */
    where?: SalesByItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesByItems to fetch.
     */
    orderBy?: SalesByItemOrderByWithRelationInput | SalesByItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesByItems.
     */
    cursor?: SalesByItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesByItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesByItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesByItems.
     */
    distinct?: SalesByItemScalarFieldEnum | SalesByItemScalarFieldEnum[]
  }

  /**
   * SalesByItem findMany
   */
  export type SalesByItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesByItem
     */
    select?: SalesByItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesByItem
     */
    omit?: SalesByItemOmit<ExtArgs> | null
    /**
     * Filter, which SalesByItems to fetch.
     */
    where?: SalesByItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesByItems to fetch.
     */
    orderBy?: SalesByItemOrderByWithRelationInput | SalesByItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesByItems.
     */
    cursor?: SalesByItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesByItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesByItems.
     */
    skip?: number
    distinct?: SalesByItemScalarFieldEnum | SalesByItemScalarFieldEnum[]
  }

  /**
   * SalesByItem create
   */
  export type SalesByItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesByItem
     */
    select?: SalesByItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesByItem
     */
    omit?: SalesByItemOmit<ExtArgs> | null
    /**
     * The data needed to create a SalesByItem.
     */
    data: XOR<SalesByItemCreateInput, SalesByItemUncheckedCreateInput>
  }

  /**
   * SalesByItem createMany
   */
  export type SalesByItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesByItems.
     */
    data: SalesByItemCreateManyInput | SalesByItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesByItem createManyAndReturn
   */
  export type SalesByItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesByItem
     */
    select?: SalesByItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesByItem
     */
    omit?: SalesByItemOmit<ExtArgs> | null
    /**
     * The data used to create many SalesByItems.
     */
    data: SalesByItemCreateManyInput | SalesByItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesByItem update
   */
  export type SalesByItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesByItem
     */
    select?: SalesByItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesByItem
     */
    omit?: SalesByItemOmit<ExtArgs> | null
    /**
     * The data needed to update a SalesByItem.
     */
    data: XOR<SalesByItemUpdateInput, SalesByItemUncheckedUpdateInput>
    /**
     * Choose, which SalesByItem to update.
     */
    where: SalesByItemWhereUniqueInput
  }

  /**
   * SalesByItem updateMany
   */
  export type SalesByItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesByItems.
     */
    data: XOR<SalesByItemUpdateManyMutationInput, SalesByItemUncheckedUpdateManyInput>
    /**
     * Filter which SalesByItems to update
     */
    where?: SalesByItemWhereInput
    /**
     * Limit how many SalesByItems to update.
     */
    limit?: number
  }

  /**
   * SalesByItem updateManyAndReturn
   */
  export type SalesByItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesByItem
     */
    select?: SalesByItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesByItem
     */
    omit?: SalesByItemOmit<ExtArgs> | null
    /**
     * The data used to update SalesByItems.
     */
    data: XOR<SalesByItemUpdateManyMutationInput, SalesByItemUncheckedUpdateManyInput>
    /**
     * Filter which SalesByItems to update
     */
    where?: SalesByItemWhereInput
    /**
     * Limit how many SalesByItems to update.
     */
    limit?: number
  }

  /**
   * SalesByItem upsert
   */
  export type SalesByItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesByItem
     */
    select?: SalesByItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesByItem
     */
    omit?: SalesByItemOmit<ExtArgs> | null
    /**
     * The filter to search for the SalesByItem to update in case it exists.
     */
    where: SalesByItemWhereUniqueInput
    /**
     * In case the SalesByItem found by the `where` argument doesn't exist, create a new SalesByItem with this data.
     */
    create: XOR<SalesByItemCreateInput, SalesByItemUncheckedCreateInput>
    /**
     * In case the SalesByItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesByItemUpdateInput, SalesByItemUncheckedUpdateInput>
  }

  /**
   * SalesByItem delete
   */
  export type SalesByItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesByItem
     */
    select?: SalesByItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesByItem
     */
    omit?: SalesByItemOmit<ExtArgs> | null
    /**
     * Filter which SalesByItem to delete.
     */
    where: SalesByItemWhereUniqueInput
  }

  /**
   * SalesByItem deleteMany
   */
  export type SalesByItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesByItems to delete
     */
    where?: SalesByItemWhereInput
    /**
     * Limit how many SalesByItems to delete.
     */
    limit?: number
  }

  /**
   * SalesByItem without action
   */
  export type SalesByItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesByItem
     */
    select?: SalesByItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesByItem
     */
    omit?: SalesByItemOmit<ExtArgs> | null
  }


  /**
   * Model SaleData2425
   */

  export type AggregateSaleData2425 = {
    _count: SaleData2425CountAggregateOutputType | null
    _avg: SaleData2425AvgAggregateOutputType | null
    _sum: SaleData2425SumAggregateOutputType | null
    _min: SaleData2425MinAggregateOutputType | null
    _max: SaleData2425MaxAggregateOutputType | null
  }

  export type SaleData2425AvgAggregateOutputType = {
    quantity: number | null
    rate: Decimal | null
  }

  export type SaleData2425SumAggregateOutputType = {
    quantity: number | null
    rate: Decimal | null
  }

  export type SaleData2425MinAggregateOutputType = {
    party_name: string | null
    invoice_date: Date | null
    invoice_no: string | null
    item_name: string | null
    quantity: number | null
    rate: Decimal | null
    uid: string | null
    id: string | null
  }

  export type SaleData2425MaxAggregateOutputType = {
    party_name: string | null
    invoice_date: Date | null
    invoice_no: string | null
    item_name: string | null
    quantity: number | null
    rate: Decimal | null
    uid: string | null
    id: string | null
  }

  export type SaleData2425CountAggregateOutputType = {
    party_name: number
    invoice_date: number
    invoice_no: number
    item_name: number
    quantity: number
    rate: number
    uid: number
    id: number
    _all: number
  }


  export type SaleData2425AvgAggregateInputType = {
    quantity?: true
    rate?: true
  }

  export type SaleData2425SumAggregateInputType = {
    quantity?: true
    rate?: true
  }

  export type SaleData2425MinAggregateInputType = {
    party_name?: true
    invoice_date?: true
    invoice_no?: true
    item_name?: true
    quantity?: true
    rate?: true
    uid?: true
    id?: true
  }

  export type SaleData2425MaxAggregateInputType = {
    party_name?: true
    invoice_date?: true
    invoice_no?: true
    item_name?: true
    quantity?: true
    rate?: true
    uid?: true
    id?: true
  }

  export type SaleData2425CountAggregateInputType = {
    party_name?: true
    invoice_date?: true
    invoice_no?: true
    item_name?: true
    quantity?: true
    rate?: true
    uid?: true
    id?: true
    _all?: true
  }

  export type SaleData2425AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleData2425 to aggregate.
     */
    where?: SaleData2425WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleData2425s to fetch.
     */
    orderBy?: SaleData2425OrderByWithRelationInput | SaleData2425OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleData2425WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleData2425s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleData2425s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleData2425s
    **/
    _count?: true | SaleData2425CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleData2425AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleData2425SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleData2425MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleData2425MaxAggregateInputType
  }

  export type GetSaleData2425AggregateType<T extends SaleData2425AggregateArgs> = {
        [P in keyof T & keyof AggregateSaleData2425]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleData2425[P]>
      : GetScalarType<T[P], AggregateSaleData2425[P]>
  }




  export type SaleData2425GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleData2425WhereInput
    orderBy?: SaleData2425OrderByWithAggregationInput | SaleData2425OrderByWithAggregationInput[]
    by: SaleData2425ScalarFieldEnum[] | SaleData2425ScalarFieldEnum
    having?: SaleData2425ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleData2425CountAggregateInputType | true
    _avg?: SaleData2425AvgAggregateInputType
    _sum?: SaleData2425SumAggregateInputType
    _min?: SaleData2425MinAggregateInputType
    _max?: SaleData2425MaxAggregateInputType
  }

  export type SaleData2425GroupByOutputType = {
    party_name: string | null
    invoice_date: Date | null
    invoice_no: string | null
    item_name: string | null
    quantity: number | null
    rate: Decimal | null
    uid: string | null
    id: string
    _count: SaleData2425CountAggregateOutputType | null
    _avg: SaleData2425AvgAggregateOutputType | null
    _sum: SaleData2425SumAggregateOutputType | null
    _min: SaleData2425MinAggregateOutputType | null
    _max: SaleData2425MaxAggregateOutputType | null
  }

  type GetSaleData2425GroupByPayload<T extends SaleData2425GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleData2425GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleData2425GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleData2425GroupByOutputType[P]>
            : GetScalarType<T[P], SaleData2425GroupByOutputType[P]>
        }
      >
    >


  export type SaleData2425Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    party_name?: boolean
    invoice_date?: boolean
    invoice_no?: boolean
    item_name?: boolean
    quantity?: boolean
    rate?: boolean
    uid?: boolean
    id?: boolean
  }, ExtArgs["result"]["saleData2425"]>

  export type SaleData2425SelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    party_name?: boolean
    invoice_date?: boolean
    invoice_no?: boolean
    item_name?: boolean
    quantity?: boolean
    rate?: boolean
    uid?: boolean
    id?: boolean
  }, ExtArgs["result"]["saleData2425"]>

  export type SaleData2425SelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    party_name?: boolean
    invoice_date?: boolean
    invoice_no?: boolean
    item_name?: boolean
    quantity?: boolean
    rate?: boolean
    uid?: boolean
    id?: boolean
  }, ExtArgs["result"]["saleData2425"]>

  export type SaleData2425SelectScalar = {
    party_name?: boolean
    invoice_date?: boolean
    invoice_no?: boolean
    item_name?: boolean
    quantity?: boolean
    rate?: boolean
    uid?: boolean
    id?: boolean
  }

  export type SaleData2425Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"party_name" | "invoice_date" | "invoice_no" | "item_name" | "quantity" | "rate" | "uid" | "id", ExtArgs["result"]["saleData2425"]>

  export type $SaleData2425Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleData2425"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      party_name: string | null
      invoice_date: Date | null
      invoice_no: string | null
      item_name: string | null
      quantity: number | null
      rate: Prisma.Decimal | null
      uid: string | null
      id: string
    }, ExtArgs["result"]["saleData2425"]>
    composites: {}
  }

  type SaleData2425GetPayload<S extends boolean | null | undefined | SaleData2425DefaultArgs> = $Result.GetResult<Prisma.$SaleData2425Payload, S>

  type SaleData2425CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleData2425FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleData2425CountAggregateInputType | true
    }

  export interface SaleData2425Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleData2425'], meta: { name: 'SaleData2425' } }
    /**
     * Find zero or one SaleData2425 that matches the filter.
     * @param {SaleData2425FindUniqueArgs} args - Arguments to find a SaleData2425
     * @example
     * // Get one SaleData2425
     * const saleData2425 = await prisma.saleData2425.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleData2425FindUniqueArgs>(args: SelectSubset<T, SaleData2425FindUniqueArgs<ExtArgs>>): Prisma__SaleData2425Client<$Result.GetResult<Prisma.$SaleData2425Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SaleData2425 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleData2425FindUniqueOrThrowArgs} args - Arguments to find a SaleData2425
     * @example
     * // Get one SaleData2425
     * const saleData2425 = await prisma.saleData2425.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleData2425FindUniqueOrThrowArgs>(args: SelectSubset<T, SaleData2425FindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleData2425Client<$Result.GetResult<Prisma.$SaleData2425Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleData2425 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleData2425FindFirstArgs} args - Arguments to find a SaleData2425
     * @example
     * // Get one SaleData2425
     * const saleData2425 = await prisma.saleData2425.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleData2425FindFirstArgs>(args?: SelectSubset<T, SaleData2425FindFirstArgs<ExtArgs>>): Prisma__SaleData2425Client<$Result.GetResult<Prisma.$SaleData2425Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleData2425 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleData2425FindFirstOrThrowArgs} args - Arguments to find a SaleData2425
     * @example
     * // Get one SaleData2425
     * const saleData2425 = await prisma.saleData2425.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleData2425FindFirstOrThrowArgs>(args?: SelectSubset<T, SaleData2425FindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleData2425Client<$Result.GetResult<Prisma.$SaleData2425Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SaleData2425s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleData2425FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleData2425s
     * const saleData2425s = await prisma.saleData2425.findMany()
     * 
     * // Get first 10 SaleData2425s
     * const saleData2425s = await prisma.saleData2425.findMany({ take: 10 })
     * 
     * // Only select the `party_name`
     * const saleData2425WithParty_nameOnly = await prisma.saleData2425.findMany({ select: { party_name: true } })
     * 
     */
    findMany<T extends SaleData2425FindManyArgs>(args?: SelectSubset<T, SaleData2425FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleData2425Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SaleData2425.
     * @param {SaleData2425CreateArgs} args - Arguments to create a SaleData2425.
     * @example
     * // Create one SaleData2425
     * const SaleData2425 = await prisma.saleData2425.create({
     *   data: {
     *     // ... data to create a SaleData2425
     *   }
     * })
     * 
     */
    create<T extends SaleData2425CreateArgs>(args: SelectSubset<T, SaleData2425CreateArgs<ExtArgs>>): Prisma__SaleData2425Client<$Result.GetResult<Prisma.$SaleData2425Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SaleData2425s.
     * @param {SaleData2425CreateManyArgs} args - Arguments to create many SaleData2425s.
     * @example
     * // Create many SaleData2425s
     * const saleData2425 = await prisma.saleData2425.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleData2425CreateManyArgs>(args?: SelectSubset<T, SaleData2425CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleData2425s and returns the data saved in the database.
     * @param {SaleData2425CreateManyAndReturnArgs} args - Arguments to create many SaleData2425s.
     * @example
     * // Create many SaleData2425s
     * const saleData2425 = await prisma.saleData2425.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleData2425s and only return the `party_name`
     * const saleData2425WithParty_nameOnly = await prisma.saleData2425.createManyAndReturn({
     *   select: { party_name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleData2425CreateManyAndReturnArgs>(args?: SelectSubset<T, SaleData2425CreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleData2425Payload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SaleData2425.
     * @param {SaleData2425DeleteArgs} args - Arguments to delete one SaleData2425.
     * @example
     * // Delete one SaleData2425
     * const SaleData2425 = await prisma.saleData2425.delete({
     *   where: {
     *     // ... filter to delete one SaleData2425
     *   }
     * })
     * 
     */
    delete<T extends SaleData2425DeleteArgs>(args: SelectSubset<T, SaleData2425DeleteArgs<ExtArgs>>): Prisma__SaleData2425Client<$Result.GetResult<Prisma.$SaleData2425Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SaleData2425.
     * @param {SaleData2425UpdateArgs} args - Arguments to update one SaleData2425.
     * @example
     * // Update one SaleData2425
     * const saleData2425 = await prisma.saleData2425.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleData2425UpdateArgs>(args: SelectSubset<T, SaleData2425UpdateArgs<ExtArgs>>): Prisma__SaleData2425Client<$Result.GetResult<Prisma.$SaleData2425Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SaleData2425s.
     * @param {SaleData2425DeleteManyArgs} args - Arguments to filter SaleData2425s to delete.
     * @example
     * // Delete a few SaleData2425s
     * const { count } = await prisma.saleData2425.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleData2425DeleteManyArgs>(args?: SelectSubset<T, SaleData2425DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleData2425s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleData2425UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleData2425s
     * const saleData2425 = await prisma.saleData2425.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleData2425UpdateManyArgs>(args: SelectSubset<T, SaleData2425UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleData2425s and returns the data updated in the database.
     * @param {SaleData2425UpdateManyAndReturnArgs} args - Arguments to update many SaleData2425s.
     * @example
     * // Update many SaleData2425s
     * const saleData2425 = await prisma.saleData2425.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SaleData2425s and only return the `party_name`
     * const saleData2425WithParty_nameOnly = await prisma.saleData2425.updateManyAndReturn({
     *   select: { party_name: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SaleData2425UpdateManyAndReturnArgs>(args: SelectSubset<T, SaleData2425UpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleData2425Payload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SaleData2425.
     * @param {SaleData2425UpsertArgs} args - Arguments to update or create a SaleData2425.
     * @example
     * // Update or create a SaleData2425
     * const saleData2425 = await prisma.saleData2425.upsert({
     *   create: {
     *     // ... data to create a SaleData2425
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleData2425 we want to update
     *   }
     * })
     */
    upsert<T extends SaleData2425UpsertArgs>(args: SelectSubset<T, SaleData2425UpsertArgs<ExtArgs>>): Prisma__SaleData2425Client<$Result.GetResult<Prisma.$SaleData2425Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SaleData2425s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleData2425CountArgs} args - Arguments to filter SaleData2425s to count.
     * @example
     * // Count the number of SaleData2425s
     * const count = await prisma.saleData2425.count({
     *   where: {
     *     // ... the filter for the SaleData2425s we want to count
     *   }
     * })
    **/
    count<T extends SaleData2425CountArgs>(
      args?: Subset<T, SaleData2425CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleData2425CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleData2425.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleData2425AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleData2425AggregateArgs>(args: Subset<T, SaleData2425AggregateArgs>): Prisma.PrismaPromise<GetSaleData2425AggregateType<T>>

    /**
     * Group by SaleData2425.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleData2425GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleData2425GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleData2425GroupByArgs['orderBy'] }
        : { orderBy?: SaleData2425GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleData2425GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleData2425GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleData2425 model
   */
  readonly fields: SaleData2425FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleData2425.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleData2425Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleData2425 model
   */
  interface SaleData2425FieldRefs {
    readonly party_name: FieldRef<"SaleData2425", 'String'>
    readonly invoice_date: FieldRef<"SaleData2425", 'DateTime'>
    readonly invoice_no: FieldRef<"SaleData2425", 'String'>
    readonly item_name: FieldRef<"SaleData2425", 'String'>
    readonly quantity: FieldRef<"SaleData2425", 'Int'>
    readonly rate: FieldRef<"SaleData2425", 'Decimal'>
    readonly uid: FieldRef<"SaleData2425", 'String'>
    readonly id: FieldRef<"SaleData2425", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SaleData2425 findUnique
   */
  export type SaleData2425FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleData2425
     */
    select?: SaleData2425Select<ExtArgs> | null
    /**
     * Omit specific fields from the SaleData2425
     */
    omit?: SaleData2425Omit<ExtArgs> | null
    /**
     * Filter, which SaleData2425 to fetch.
     */
    where: SaleData2425WhereUniqueInput
  }

  /**
   * SaleData2425 findUniqueOrThrow
   */
  export type SaleData2425FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleData2425
     */
    select?: SaleData2425Select<ExtArgs> | null
    /**
     * Omit specific fields from the SaleData2425
     */
    omit?: SaleData2425Omit<ExtArgs> | null
    /**
     * Filter, which SaleData2425 to fetch.
     */
    where: SaleData2425WhereUniqueInput
  }

  /**
   * SaleData2425 findFirst
   */
  export type SaleData2425FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleData2425
     */
    select?: SaleData2425Select<ExtArgs> | null
    /**
     * Omit specific fields from the SaleData2425
     */
    omit?: SaleData2425Omit<ExtArgs> | null
    /**
     * Filter, which SaleData2425 to fetch.
     */
    where?: SaleData2425WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleData2425s to fetch.
     */
    orderBy?: SaleData2425OrderByWithRelationInput | SaleData2425OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleData2425s.
     */
    cursor?: SaleData2425WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleData2425s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleData2425s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleData2425s.
     */
    distinct?: SaleData2425ScalarFieldEnum | SaleData2425ScalarFieldEnum[]
  }

  /**
   * SaleData2425 findFirstOrThrow
   */
  export type SaleData2425FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleData2425
     */
    select?: SaleData2425Select<ExtArgs> | null
    /**
     * Omit specific fields from the SaleData2425
     */
    omit?: SaleData2425Omit<ExtArgs> | null
    /**
     * Filter, which SaleData2425 to fetch.
     */
    where?: SaleData2425WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleData2425s to fetch.
     */
    orderBy?: SaleData2425OrderByWithRelationInput | SaleData2425OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleData2425s.
     */
    cursor?: SaleData2425WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleData2425s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleData2425s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleData2425s.
     */
    distinct?: SaleData2425ScalarFieldEnum | SaleData2425ScalarFieldEnum[]
  }

  /**
   * SaleData2425 findMany
   */
  export type SaleData2425FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleData2425
     */
    select?: SaleData2425Select<ExtArgs> | null
    /**
     * Omit specific fields from the SaleData2425
     */
    omit?: SaleData2425Omit<ExtArgs> | null
    /**
     * Filter, which SaleData2425s to fetch.
     */
    where?: SaleData2425WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleData2425s to fetch.
     */
    orderBy?: SaleData2425OrderByWithRelationInput | SaleData2425OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleData2425s.
     */
    cursor?: SaleData2425WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleData2425s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleData2425s.
     */
    skip?: number
    distinct?: SaleData2425ScalarFieldEnum | SaleData2425ScalarFieldEnum[]
  }

  /**
   * SaleData2425 create
   */
  export type SaleData2425CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleData2425
     */
    select?: SaleData2425Select<ExtArgs> | null
    /**
     * Omit specific fields from the SaleData2425
     */
    omit?: SaleData2425Omit<ExtArgs> | null
    /**
     * The data needed to create a SaleData2425.
     */
    data?: XOR<SaleData2425CreateInput, SaleData2425UncheckedCreateInput>
  }

  /**
   * SaleData2425 createMany
   */
  export type SaleData2425CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleData2425s.
     */
    data: SaleData2425CreateManyInput | SaleData2425CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleData2425 createManyAndReturn
   */
  export type SaleData2425CreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleData2425
     */
    select?: SaleData2425SelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleData2425
     */
    omit?: SaleData2425Omit<ExtArgs> | null
    /**
     * The data used to create many SaleData2425s.
     */
    data: SaleData2425CreateManyInput | SaleData2425CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleData2425 update
   */
  export type SaleData2425UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleData2425
     */
    select?: SaleData2425Select<ExtArgs> | null
    /**
     * Omit specific fields from the SaleData2425
     */
    omit?: SaleData2425Omit<ExtArgs> | null
    /**
     * The data needed to update a SaleData2425.
     */
    data: XOR<SaleData2425UpdateInput, SaleData2425UncheckedUpdateInput>
    /**
     * Choose, which SaleData2425 to update.
     */
    where: SaleData2425WhereUniqueInput
  }

  /**
   * SaleData2425 updateMany
   */
  export type SaleData2425UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleData2425s.
     */
    data: XOR<SaleData2425UpdateManyMutationInput, SaleData2425UncheckedUpdateManyInput>
    /**
     * Filter which SaleData2425s to update
     */
    where?: SaleData2425WhereInput
    /**
     * Limit how many SaleData2425s to update.
     */
    limit?: number
  }

  /**
   * SaleData2425 updateManyAndReturn
   */
  export type SaleData2425UpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleData2425
     */
    select?: SaleData2425SelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleData2425
     */
    omit?: SaleData2425Omit<ExtArgs> | null
    /**
     * The data used to update SaleData2425s.
     */
    data: XOR<SaleData2425UpdateManyMutationInput, SaleData2425UncheckedUpdateManyInput>
    /**
     * Filter which SaleData2425s to update
     */
    where?: SaleData2425WhereInput
    /**
     * Limit how many SaleData2425s to update.
     */
    limit?: number
  }

  /**
   * SaleData2425 upsert
   */
  export type SaleData2425UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleData2425
     */
    select?: SaleData2425Select<ExtArgs> | null
    /**
     * Omit specific fields from the SaleData2425
     */
    omit?: SaleData2425Omit<ExtArgs> | null
    /**
     * The filter to search for the SaleData2425 to update in case it exists.
     */
    where: SaleData2425WhereUniqueInput
    /**
     * In case the SaleData2425 found by the `where` argument doesn't exist, create a new SaleData2425 with this data.
     */
    create: XOR<SaleData2425CreateInput, SaleData2425UncheckedCreateInput>
    /**
     * In case the SaleData2425 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleData2425UpdateInput, SaleData2425UncheckedUpdateInput>
  }

  /**
   * SaleData2425 delete
   */
  export type SaleData2425DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleData2425
     */
    select?: SaleData2425Select<ExtArgs> | null
    /**
     * Omit specific fields from the SaleData2425
     */
    omit?: SaleData2425Omit<ExtArgs> | null
    /**
     * Filter which SaleData2425 to delete.
     */
    where: SaleData2425WhereUniqueInput
  }

  /**
   * SaleData2425 deleteMany
   */
  export type SaleData2425DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleData2425s to delete
     */
    where?: SaleData2425WhereInput
    /**
     * Limit how many SaleData2425s to delete.
     */
    limit?: number
  }

  /**
   * SaleData2425 without action
   */
  export type SaleData2425DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleData2425
     */
    select?: SaleData2425Select<ExtArgs> | null
    /**
     * Omit specific fields from the SaleData2425
     */
    omit?: SaleData2425Omit<ExtArgs> | null
  }


  /**
   * Model StockItem
   */

  export type AggregateStockItem = {
    _count: StockItemCountAggregateOutputType | null
    _avg: StockItemAvgAggregateOutputType | null
    _sum: StockItemSumAggregateOutputType | null
    _min: StockItemMinAggregateOutputType | null
    _max: StockItemMaxAggregateOutputType | null
  }

  export type StockItemAvgAggregateOutputType = {
    id: number | null
    buyingprice: number | null
    tax: number | null
    stock: number | null
  }

  export type StockItemSumAggregateOutputType = {
    id: number | null
    buyingprice: number | null
    tax: number | null
    stock: number | null
  }

  export type StockItemMinAggregateOutputType = {
    id: number | null
    uid: string | null
    name: string | null
    hsncode: string | null
    buyingprice: number | null
    supplier: string | null
    tax: number | null
    stock: number | null
  }

  export type StockItemMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    name: string | null
    hsncode: string | null
    buyingprice: number | null
    supplier: string | null
    tax: number | null
    stock: number | null
  }

  export type StockItemCountAggregateOutputType = {
    id: number
    uid: number
    name: number
    hsncode: number
    buyingprice: number
    supplier: number
    tax: number
    stock: number
    _all: number
  }


  export type StockItemAvgAggregateInputType = {
    id?: true
    buyingprice?: true
    tax?: true
    stock?: true
  }

  export type StockItemSumAggregateInputType = {
    id?: true
    buyingprice?: true
    tax?: true
    stock?: true
  }

  export type StockItemMinAggregateInputType = {
    id?: true
    uid?: true
    name?: true
    hsncode?: true
    buyingprice?: true
    supplier?: true
    tax?: true
    stock?: true
  }

  export type StockItemMaxAggregateInputType = {
    id?: true
    uid?: true
    name?: true
    hsncode?: true
    buyingprice?: true
    supplier?: true
    tax?: true
    stock?: true
  }

  export type StockItemCountAggregateInputType = {
    id?: true
    uid?: true
    name?: true
    hsncode?: true
    buyingprice?: true
    supplier?: true
    tax?: true
    stock?: true
    _all?: true
  }

  export type StockItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockItem to aggregate.
     */
    where?: StockItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockItems to fetch.
     */
    orderBy?: StockItemOrderByWithRelationInput | StockItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockItems
    **/
    _count?: true | StockItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockItemMaxAggregateInputType
  }

  export type GetStockItemAggregateType<T extends StockItemAggregateArgs> = {
        [P in keyof T & keyof AggregateStockItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockItem[P]>
      : GetScalarType<T[P], AggregateStockItem[P]>
  }




  export type StockItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockItemWhereInput
    orderBy?: StockItemOrderByWithAggregationInput | StockItemOrderByWithAggregationInput[]
    by: StockItemScalarFieldEnum[] | StockItemScalarFieldEnum
    having?: StockItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockItemCountAggregateInputType | true
    _avg?: StockItemAvgAggregateInputType
    _sum?: StockItemSumAggregateInputType
    _min?: StockItemMinAggregateInputType
    _max?: StockItemMaxAggregateInputType
  }

  export type StockItemGroupByOutputType = {
    id: number
    uid: string
    name: string
    hsncode: string | null
    buyingprice: number
    supplier: string | null
    tax: number | null
    stock: number
    _count: StockItemCountAggregateOutputType | null
    _avg: StockItemAvgAggregateOutputType | null
    _sum: StockItemSumAggregateOutputType | null
    _min: StockItemMinAggregateOutputType | null
    _max: StockItemMaxAggregateOutputType | null
  }

  type GetStockItemGroupByPayload<T extends StockItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockItemGroupByOutputType[P]>
            : GetScalarType<T[P], StockItemGroupByOutputType[P]>
        }
      >
    >


  export type StockItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uid?: boolean
    name?: boolean
    hsncode?: boolean
    buyingprice?: boolean
    supplier?: boolean
    tax?: boolean
    stock?: boolean
    productBatches?: boolean | StockItem$productBatchesArgs<ExtArgs>
    permanentItem?: boolean | StockItem$permanentItemArgs<ExtArgs>
    _count?: boolean | StockItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockItem"]>

  export type StockItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uid?: boolean
    name?: boolean
    hsncode?: boolean
    buyingprice?: boolean
    supplier?: boolean
    tax?: boolean
    stock?: boolean
  }, ExtArgs["result"]["stockItem"]>

  export type StockItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uid?: boolean
    name?: boolean
    hsncode?: boolean
    buyingprice?: boolean
    supplier?: boolean
    tax?: boolean
    stock?: boolean
  }, ExtArgs["result"]["stockItem"]>

  export type StockItemSelectScalar = {
    id?: boolean
    uid?: boolean
    name?: boolean
    hsncode?: boolean
    buyingprice?: boolean
    supplier?: boolean
    tax?: boolean
    stock?: boolean
  }

  export type StockItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uid" | "name" | "hsncode" | "buyingprice" | "supplier" | "tax" | "stock", ExtArgs["result"]["stockItem"]>
  export type StockItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productBatches?: boolean | StockItem$productBatchesArgs<ExtArgs>
    permanentItem?: boolean | StockItem$permanentItemArgs<ExtArgs>
    _count?: boolean | StockItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StockItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StockItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StockItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockItem"
    objects: {
      productBatches: Prisma.$ProductBatchPayload<ExtArgs>[]
      permanentItem: Prisma.$PermanentItemPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uid: string
      name: string
      hsncode: string | null
      buyingprice: number
      supplier: string | null
      tax: number | null
      stock: number
    }, ExtArgs["result"]["stockItem"]>
    composites: {}
  }

  type StockItemGetPayload<S extends boolean | null | undefined | StockItemDefaultArgs> = $Result.GetResult<Prisma.$StockItemPayload, S>

  type StockItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockItemCountAggregateInputType | true
    }

  export interface StockItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockItem'], meta: { name: 'StockItem' } }
    /**
     * Find zero or one StockItem that matches the filter.
     * @param {StockItemFindUniqueArgs} args - Arguments to find a StockItem
     * @example
     * // Get one StockItem
     * const stockItem = await prisma.stockItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockItemFindUniqueArgs>(args: SelectSubset<T, StockItemFindUniqueArgs<ExtArgs>>): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockItemFindUniqueOrThrowArgs} args - Arguments to find a StockItem
     * @example
     * // Get one StockItem
     * const stockItem = await prisma.stockItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockItemFindUniqueOrThrowArgs>(args: SelectSubset<T, StockItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemFindFirstArgs} args - Arguments to find a StockItem
     * @example
     * // Get one StockItem
     * const stockItem = await prisma.stockItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockItemFindFirstArgs>(args?: SelectSubset<T, StockItemFindFirstArgs<ExtArgs>>): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemFindFirstOrThrowArgs} args - Arguments to find a StockItem
     * @example
     * // Get one StockItem
     * const stockItem = await prisma.stockItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockItemFindFirstOrThrowArgs>(args?: SelectSubset<T, StockItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockItems
     * const stockItems = await prisma.stockItem.findMany()
     * 
     * // Get first 10 StockItems
     * const stockItems = await prisma.stockItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockItemWithIdOnly = await prisma.stockItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockItemFindManyArgs>(args?: SelectSubset<T, StockItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockItem.
     * @param {StockItemCreateArgs} args - Arguments to create a StockItem.
     * @example
     * // Create one StockItem
     * const StockItem = await prisma.stockItem.create({
     *   data: {
     *     // ... data to create a StockItem
     *   }
     * })
     * 
     */
    create<T extends StockItemCreateArgs>(args: SelectSubset<T, StockItemCreateArgs<ExtArgs>>): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockItems.
     * @param {StockItemCreateManyArgs} args - Arguments to create many StockItems.
     * @example
     * // Create many StockItems
     * const stockItem = await prisma.stockItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockItemCreateManyArgs>(args?: SelectSubset<T, StockItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockItems and returns the data saved in the database.
     * @param {StockItemCreateManyAndReturnArgs} args - Arguments to create many StockItems.
     * @example
     * // Create many StockItems
     * const stockItem = await prisma.stockItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockItems and only return the `id`
     * const stockItemWithIdOnly = await prisma.stockItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockItemCreateManyAndReturnArgs>(args?: SelectSubset<T, StockItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockItem.
     * @param {StockItemDeleteArgs} args - Arguments to delete one StockItem.
     * @example
     * // Delete one StockItem
     * const StockItem = await prisma.stockItem.delete({
     *   where: {
     *     // ... filter to delete one StockItem
     *   }
     * })
     * 
     */
    delete<T extends StockItemDeleteArgs>(args: SelectSubset<T, StockItemDeleteArgs<ExtArgs>>): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockItem.
     * @param {StockItemUpdateArgs} args - Arguments to update one StockItem.
     * @example
     * // Update one StockItem
     * const stockItem = await prisma.stockItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockItemUpdateArgs>(args: SelectSubset<T, StockItemUpdateArgs<ExtArgs>>): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockItems.
     * @param {StockItemDeleteManyArgs} args - Arguments to filter StockItems to delete.
     * @example
     * // Delete a few StockItems
     * const { count } = await prisma.stockItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockItemDeleteManyArgs>(args?: SelectSubset<T, StockItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockItems
     * const stockItem = await prisma.stockItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockItemUpdateManyArgs>(args: SelectSubset<T, StockItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockItems and returns the data updated in the database.
     * @param {StockItemUpdateManyAndReturnArgs} args - Arguments to update many StockItems.
     * @example
     * // Update many StockItems
     * const stockItem = await prisma.stockItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockItems and only return the `id`
     * const stockItemWithIdOnly = await prisma.stockItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockItemUpdateManyAndReturnArgs>(args: SelectSubset<T, StockItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockItem.
     * @param {StockItemUpsertArgs} args - Arguments to update or create a StockItem.
     * @example
     * // Update or create a StockItem
     * const stockItem = await prisma.stockItem.upsert({
     *   create: {
     *     // ... data to create a StockItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockItem we want to update
     *   }
     * })
     */
    upsert<T extends StockItemUpsertArgs>(args: SelectSubset<T, StockItemUpsertArgs<ExtArgs>>): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemCountArgs} args - Arguments to filter StockItems to count.
     * @example
     * // Count the number of StockItems
     * const count = await prisma.stockItem.count({
     *   where: {
     *     // ... the filter for the StockItems we want to count
     *   }
     * })
    **/
    count<T extends StockItemCountArgs>(
      args?: Subset<T, StockItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockItemAggregateArgs>(args: Subset<T, StockItemAggregateArgs>): Prisma.PrismaPromise<GetStockItemAggregateType<T>>

    /**
     * Group by StockItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockItemGroupByArgs['orderBy'] }
        : { orderBy?: StockItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockItem model
   */
  readonly fields: StockItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productBatches<T extends StockItem$productBatchesArgs<ExtArgs> = {}>(args?: Subset<T, StockItem$productBatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    permanentItem<T extends StockItem$permanentItemArgs<ExtArgs> = {}>(args?: Subset<T, StockItem$permanentItemArgs<ExtArgs>>): Prisma__PermanentItemClient<$Result.GetResult<Prisma.$PermanentItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockItem model
   */
  interface StockItemFieldRefs {
    readonly id: FieldRef<"StockItem", 'Int'>
    readonly uid: FieldRef<"StockItem", 'String'>
    readonly name: FieldRef<"StockItem", 'String'>
    readonly hsncode: FieldRef<"StockItem", 'String'>
    readonly buyingprice: FieldRef<"StockItem", 'Float'>
    readonly supplier: FieldRef<"StockItem", 'String'>
    readonly tax: FieldRef<"StockItem", 'Float'>
    readonly stock: FieldRef<"StockItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StockItem findUnique
   */
  export type StockItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockItemInclude<ExtArgs> | null
    /**
     * Filter, which StockItem to fetch.
     */
    where: StockItemWhereUniqueInput
  }

  /**
   * StockItem findUniqueOrThrow
   */
  export type StockItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockItemInclude<ExtArgs> | null
    /**
     * Filter, which StockItem to fetch.
     */
    where: StockItemWhereUniqueInput
  }

  /**
   * StockItem findFirst
   */
  export type StockItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockItemInclude<ExtArgs> | null
    /**
     * Filter, which StockItem to fetch.
     */
    where?: StockItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockItems to fetch.
     */
    orderBy?: StockItemOrderByWithRelationInput | StockItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockItems.
     */
    cursor?: StockItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockItems.
     */
    distinct?: StockItemScalarFieldEnum | StockItemScalarFieldEnum[]
  }

  /**
   * StockItem findFirstOrThrow
   */
  export type StockItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockItemInclude<ExtArgs> | null
    /**
     * Filter, which StockItem to fetch.
     */
    where?: StockItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockItems to fetch.
     */
    orderBy?: StockItemOrderByWithRelationInput | StockItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockItems.
     */
    cursor?: StockItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockItems.
     */
    distinct?: StockItemScalarFieldEnum | StockItemScalarFieldEnum[]
  }

  /**
   * StockItem findMany
   */
  export type StockItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockItemInclude<ExtArgs> | null
    /**
     * Filter, which StockItems to fetch.
     */
    where?: StockItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockItems to fetch.
     */
    orderBy?: StockItemOrderByWithRelationInput | StockItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockItems.
     */
    cursor?: StockItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockItems.
     */
    skip?: number
    distinct?: StockItemScalarFieldEnum | StockItemScalarFieldEnum[]
  }

  /**
   * StockItem create
   */
  export type StockItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockItemInclude<ExtArgs> | null
    /**
     * The data needed to create a StockItem.
     */
    data: XOR<StockItemCreateInput, StockItemUncheckedCreateInput>
  }

  /**
   * StockItem createMany
   */
  export type StockItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockItems.
     */
    data: StockItemCreateManyInput | StockItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockItem createManyAndReturn
   */
  export type StockItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * The data used to create many StockItems.
     */
    data: StockItemCreateManyInput | StockItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockItem update
   */
  export type StockItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockItemInclude<ExtArgs> | null
    /**
     * The data needed to update a StockItem.
     */
    data: XOR<StockItemUpdateInput, StockItemUncheckedUpdateInput>
    /**
     * Choose, which StockItem to update.
     */
    where: StockItemWhereUniqueInput
  }

  /**
   * StockItem updateMany
   */
  export type StockItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockItems.
     */
    data: XOR<StockItemUpdateManyMutationInput, StockItemUncheckedUpdateManyInput>
    /**
     * Filter which StockItems to update
     */
    where?: StockItemWhereInput
    /**
     * Limit how many StockItems to update.
     */
    limit?: number
  }

  /**
   * StockItem updateManyAndReturn
   */
  export type StockItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * The data used to update StockItems.
     */
    data: XOR<StockItemUpdateManyMutationInput, StockItemUncheckedUpdateManyInput>
    /**
     * Filter which StockItems to update
     */
    where?: StockItemWhereInput
    /**
     * Limit how many StockItems to update.
     */
    limit?: number
  }

  /**
   * StockItem upsert
   */
  export type StockItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockItemInclude<ExtArgs> | null
    /**
     * The filter to search for the StockItem to update in case it exists.
     */
    where: StockItemWhereUniqueInput
    /**
     * In case the StockItem found by the `where` argument doesn't exist, create a new StockItem with this data.
     */
    create: XOR<StockItemCreateInput, StockItemUncheckedCreateInput>
    /**
     * In case the StockItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockItemUpdateInput, StockItemUncheckedUpdateInput>
  }

  /**
   * StockItem delete
   */
  export type StockItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockItemInclude<ExtArgs> | null
    /**
     * Filter which StockItem to delete.
     */
    where: StockItemWhereUniqueInput
  }

  /**
   * StockItem deleteMany
   */
  export type StockItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockItems to delete
     */
    where?: StockItemWhereInput
    /**
     * Limit how many StockItems to delete.
     */
    limit?: number
  }

  /**
   * StockItem.productBatches
   */
  export type StockItem$productBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
    where?: ProductBatchWhereInput
    orderBy?: ProductBatchOrderByWithRelationInput | ProductBatchOrderByWithRelationInput[]
    cursor?: ProductBatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductBatchScalarFieldEnum | ProductBatchScalarFieldEnum[]
  }

  /**
   * StockItem.permanentItem
   */
  export type StockItem$permanentItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermanentItem
     */
    select?: PermanentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermanentItem
     */
    omit?: PermanentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermanentItemInclude<ExtArgs> | null
    where?: PermanentItemWhereInput
  }

  /**
   * StockItem without action
   */
  export type StockItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockItem
     */
    select?: StockItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockItem
     */
    omit?: StockItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockItemInclude<ExtArgs> | null
  }


  /**
   * Model PermanentItem
   */

  export type AggregatePermanentItem = {
    _count: PermanentItemCountAggregateOutputType | null
    _avg: PermanentItemAvgAggregateOutputType | null
    _sum: PermanentItemSumAggregateOutputType | null
    _min: PermanentItemMinAggregateOutputType | null
    _max: PermanentItemMaxAggregateOutputType | null
  }

  export type PermanentItemAvgAggregateOutputType = {
    id: number | null
    reorder_level: number | null
  }

  export type PermanentItemSumAggregateOutputType = {
    id: number | null
    reorder_level: number | null
  }

  export type PermanentItemMinAggregateOutputType = {
    id: number | null
    uid: string | null
    name: string | null
    reorder_level: number | null
    product_note: string | null
    supplier: string | null
    udrl: string | null
  }

  export type PermanentItemMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    name: string | null
    reorder_level: number | null
    product_note: string | null
    supplier: string | null
    udrl: string | null
  }

  export type PermanentItemCountAggregateOutputType = {
    id: number
    uid: number
    name: number
    reorder_level: number
    product_note: number
    supplier: number
    udrl: number
    _all: number
  }


  export type PermanentItemAvgAggregateInputType = {
    id?: true
    reorder_level?: true
  }

  export type PermanentItemSumAggregateInputType = {
    id?: true
    reorder_level?: true
  }

  export type PermanentItemMinAggregateInputType = {
    id?: true
    uid?: true
    name?: true
    reorder_level?: true
    product_note?: true
    supplier?: true
    udrl?: true
  }

  export type PermanentItemMaxAggregateInputType = {
    id?: true
    uid?: true
    name?: true
    reorder_level?: true
    product_note?: true
    supplier?: true
    udrl?: true
  }

  export type PermanentItemCountAggregateInputType = {
    id?: true
    uid?: true
    name?: true
    reorder_level?: true
    product_note?: true
    supplier?: true
    udrl?: true
    _all?: true
  }

  export type PermanentItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PermanentItem to aggregate.
     */
    where?: PermanentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermanentItems to fetch.
     */
    orderBy?: PermanentItemOrderByWithRelationInput | PermanentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermanentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermanentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermanentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PermanentItems
    **/
    _count?: true | PermanentItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermanentItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermanentItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermanentItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermanentItemMaxAggregateInputType
  }

  export type GetPermanentItemAggregateType<T extends PermanentItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePermanentItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermanentItem[P]>
      : GetScalarType<T[P], AggregatePermanentItem[P]>
  }




  export type PermanentItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermanentItemWhereInput
    orderBy?: PermanentItemOrderByWithAggregationInput | PermanentItemOrderByWithAggregationInput[]
    by: PermanentItemScalarFieldEnum[] | PermanentItemScalarFieldEnum
    having?: PermanentItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermanentItemCountAggregateInputType | true
    _avg?: PermanentItemAvgAggregateInputType
    _sum?: PermanentItemSumAggregateInputType
    _min?: PermanentItemMinAggregateInputType
    _max?: PermanentItemMaxAggregateInputType
  }

  export type PermanentItemGroupByOutputType = {
    id: number
    uid: string
    name: string | null
    reorder_level: number | null
    product_note: string | null
    supplier: string | null
    udrl: string | null
    _count: PermanentItemCountAggregateOutputType | null
    _avg: PermanentItemAvgAggregateOutputType | null
    _sum: PermanentItemSumAggregateOutputType | null
    _min: PermanentItemMinAggregateOutputType | null
    _max: PermanentItemMaxAggregateOutputType | null
  }

  type GetPermanentItemGroupByPayload<T extends PermanentItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermanentItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermanentItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermanentItemGroupByOutputType[P]>
            : GetScalarType<T[P], PermanentItemGroupByOutputType[P]>
        }
      >
    >


  export type PermanentItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uid?: boolean
    name?: boolean
    reorder_level?: boolean
    product_note?: boolean
    supplier?: boolean
    udrl?: boolean
    stockItem?: boolean | StockItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permanentItem"]>

  export type PermanentItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uid?: boolean
    name?: boolean
    reorder_level?: boolean
    product_note?: boolean
    supplier?: boolean
    udrl?: boolean
    stockItem?: boolean | StockItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permanentItem"]>

  export type PermanentItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uid?: boolean
    name?: boolean
    reorder_level?: boolean
    product_note?: boolean
    supplier?: boolean
    udrl?: boolean
    stockItem?: boolean | StockItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permanentItem"]>

  export type PermanentItemSelectScalar = {
    id?: boolean
    uid?: boolean
    name?: boolean
    reorder_level?: boolean
    product_note?: boolean
    supplier?: boolean
    udrl?: boolean
  }

  export type PermanentItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uid" | "name" | "reorder_level" | "product_note" | "supplier" | "udrl", ExtArgs["result"]["permanentItem"]>
  export type PermanentItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockItem?: boolean | StockItemDefaultArgs<ExtArgs>
  }
  export type PermanentItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockItem?: boolean | StockItemDefaultArgs<ExtArgs>
  }
  export type PermanentItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockItem?: boolean | StockItemDefaultArgs<ExtArgs>
  }

  export type $PermanentItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PermanentItem"
    objects: {
      stockItem: Prisma.$StockItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uid: string
      name: string | null
      reorder_level: number | null
      product_note: string | null
      supplier: string | null
      udrl: string | null
    }, ExtArgs["result"]["permanentItem"]>
    composites: {}
  }

  type PermanentItemGetPayload<S extends boolean | null | undefined | PermanentItemDefaultArgs> = $Result.GetResult<Prisma.$PermanentItemPayload, S>

  type PermanentItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermanentItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermanentItemCountAggregateInputType | true
    }

  export interface PermanentItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PermanentItem'], meta: { name: 'PermanentItem' } }
    /**
     * Find zero or one PermanentItem that matches the filter.
     * @param {PermanentItemFindUniqueArgs} args - Arguments to find a PermanentItem
     * @example
     * // Get one PermanentItem
     * const permanentItem = await prisma.permanentItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermanentItemFindUniqueArgs>(args: SelectSubset<T, PermanentItemFindUniqueArgs<ExtArgs>>): Prisma__PermanentItemClient<$Result.GetResult<Prisma.$PermanentItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PermanentItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermanentItemFindUniqueOrThrowArgs} args - Arguments to find a PermanentItem
     * @example
     * // Get one PermanentItem
     * const permanentItem = await prisma.permanentItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermanentItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PermanentItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermanentItemClient<$Result.GetResult<Prisma.$PermanentItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PermanentItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermanentItemFindFirstArgs} args - Arguments to find a PermanentItem
     * @example
     * // Get one PermanentItem
     * const permanentItem = await prisma.permanentItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermanentItemFindFirstArgs>(args?: SelectSubset<T, PermanentItemFindFirstArgs<ExtArgs>>): Prisma__PermanentItemClient<$Result.GetResult<Prisma.$PermanentItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PermanentItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermanentItemFindFirstOrThrowArgs} args - Arguments to find a PermanentItem
     * @example
     * // Get one PermanentItem
     * const permanentItem = await prisma.permanentItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermanentItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PermanentItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermanentItemClient<$Result.GetResult<Prisma.$PermanentItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PermanentItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermanentItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PermanentItems
     * const permanentItems = await prisma.permanentItem.findMany()
     * 
     * // Get first 10 PermanentItems
     * const permanentItems = await prisma.permanentItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permanentItemWithIdOnly = await prisma.permanentItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermanentItemFindManyArgs>(args?: SelectSubset<T, PermanentItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermanentItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PermanentItem.
     * @param {PermanentItemCreateArgs} args - Arguments to create a PermanentItem.
     * @example
     * // Create one PermanentItem
     * const PermanentItem = await prisma.permanentItem.create({
     *   data: {
     *     // ... data to create a PermanentItem
     *   }
     * })
     * 
     */
    create<T extends PermanentItemCreateArgs>(args: SelectSubset<T, PermanentItemCreateArgs<ExtArgs>>): Prisma__PermanentItemClient<$Result.GetResult<Prisma.$PermanentItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PermanentItems.
     * @param {PermanentItemCreateManyArgs} args - Arguments to create many PermanentItems.
     * @example
     * // Create many PermanentItems
     * const permanentItem = await prisma.permanentItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermanentItemCreateManyArgs>(args?: SelectSubset<T, PermanentItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PermanentItems and returns the data saved in the database.
     * @param {PermanentItemCreateManyAndReturnArgs} args - Arguments to create many PermanentItems.
     * @example
     * // Create many PermanentItems
     * const permanentItem = await prisma.permanentItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PermanentItems and only return the `id`
     * const permanentItemWithIdOnly = await prisma.permanentItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermanentItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PermanentItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermanentItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PermanentItem.
     * @param {PermanentItemDeleteArgs} args - Arguments to delete one PermanentItem.
     * @example
     * // Delete one PermanentItem
     * const PermanentItem = await prisma.permanentItem.delete({
     *   where: {
     *     // ... filter to delete one PermanentItem
     *   }
     * })
     * 
     */
    delete<T extends PermanentItemDeleteArgs>(args: SelectSubset<T, PermanentItemDeleteArgs<ExtArgs>>): Prisma__PermanentItemClient<$Result.GetResult<Prisma.$PermanentItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PermanentItem.
     * @param {PermanentItemUpdateArgs} args - Arguments to update one PermanentItem.
     * @example
     * // Update one PermanentItem
     * const permanentItem = await prisma.permanentItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermanentItemUpdateArgs>(args: SelectSubset<T, PermanentItemUpdateArgs<ExtArgs>>): Prisma__PermanentItemClient<$Result.GetResult<Prisma.$PermanentItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PermanentItems.
     * @param {PermanentItemDeleteManyArgs} args - Arguments to filter PermanentItems to delete.
     * @example
     * // Delete a few PermanentItems
     * const { count } = await prisma.permanentItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermanentItemDeleteManyArgs>(args?: SelectSubset<T, PermanentItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PermanentItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermanentItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PermanentItems
     * const permanentItem = await prisma.permanentItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermanentItemUpdateManyArgs>(args: SelectSubset<T, PermanentItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PermanentItems and returns the data updated in the database.
     * @param {PermanentItemUpdateManyAndReturnArgs} args - Arguments to update many PermanentItems.
     * @example
     * // Update many PermanentItems
     * const permanentItem = await prisma.permanentItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PermanentItems and only return the `id`
     * const permanentItemWithIdOnly = await prisma.permanentItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermanentItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PermanentItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermanentItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PermanentItem.
     * @param {PermanentItemUpsertArgs} args - Arguments to update or create a PermanentItem.
     * @example
     * // Update or create a PermanentItem
     * const permanentItem = await prisma.permanentItem.upsert({
     *   create: {
     *     // ... data to create a PermanentItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PermanentItem we want to update
     *   }
     * })
     */
    upsert<T extends PermanentItemUpsertArgs>(args: SelectSubset<T, PermanentItemUpsertArgs<ExtArgs>>): Prisma__PermanentItemClient<$Result.GetResult<Prisma.$PermanentItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PermanentItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermanentItemCountArgs} args - Arguments to filter PermanentItems to count.
     * @example
     * // Count the number of PermanentItems
     * const count = await prisma.permanentItem.count({
     *   where: {
     *     // ... the filter for the PermanentItems we want to count
     *   }
     * })
    **/
    count<T extends PermanentItemCountArgs>(
      args?: Subset<T, PermanentItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermanentItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PermanentItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermanentItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermanentItemAggregateArgs>(args: Subset<T, PermanentItemAggregateArgs>): Prisma.PrismaPromise<GetPermanentItemAggregateType<T>>

    /**
     * Group by PermanentItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermanentItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermanentItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermanentItemGroupByArgs['orderBy'] }
        : { orderBy?: PermanentItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermanentItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermanentItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PermanentItem model
   */
  readonly fields: PermanentItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PermanentItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermanentItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stockItem<T extends StockItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockItemDefaultArgs<ExtArgs>>): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PermanentItem model
   */
  interface PermanentItemFieldRefs {
    readonly id: FieldRef<"PermanentItem", 'Int'>
    readonly uid: FieldRef<"PermanentItem", 'String'>
    readonly name: FieldRef<"PermanentItem", 'String'>
    readonly reorder_level: FieldRef<"PermanentItem", 'Int'>
    readonly product_note: FieldRef<"PermanentItem", 'String'>
    readonly supplier: FieldRef<"PermanentItem", 'String'>
    readonly udrl: FieldRef<"PermanentItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PermanentItem findUnique
   */
  export type PermanentItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermanentItem
     */
    select?: PermanentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermanentItem
     */
    omit?: PermanentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermanentItemInclude<ExtArgs> | null
    /**
     * Filter, which PermanentItem to fetch.
     */
    where: PermanentItemWhereUniqueInput
  }

  /**
   * PermanentItem findUniqueOrThrow
   */
  export type PermanentItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermanentItem
     */
    select?: PermanentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermanentItem
     */
    omit?: PermanentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermanentItemInclude<ExtArgs> | null
    /**
     * Filter, which PermanentItem to fetch.
     */
    where: PermanentItemWhereUniqueInput
  }

  /**
   * PermanentItem findFirst
   */
  export type PermanentItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermanentItem
     */
    select?: PermanentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermanentItem
     */
    omit?: PermanentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermanentItemInclude<ExtArgs> | null
    /**
     * Filter, which PermanentItem to fetch.
     */
    where?: PermanentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermanentItems to fetch.
     */
    orderBy?: PermanentItemOrderByWithRelationInput | PermanentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PermanentItems.
     */
    cursor?: PermanentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermanentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermanentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PermanentItems.
     */
    distinct?: PermanentItemScalarFieldEnum | PermanentItemScalarFieldEnum[]
  }

  /**
   * PermanentItem findFirstOrThrow
   */
  export type PermanentItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermanentItem
     */
    select?: PermanentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermanentItem
     */
    omit?: PermanentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermanentItemInclude<ExtArgs> | null
    /**
     * Filter, which PermanentItem to fetch.
     */
    where?: PermanentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermanentItems to fetch.
     */
    orderBy?: PermanentItemOrderByWithRelationInput | PermanentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PermanentItems.
     */
    cursor?: PermanentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermanentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermanentItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PermanentItems.
     */
    distinct?: PermanentItemScalarFieldEnum | PermanentItemScalarFieldEnum[]
  }

  /**
   * PermanentItem findMany
   */
  export type PermanentItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermanentItem
     */
    select?: PermanentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermanentItem
     */
    omit?: PermanentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermanentItemInclude<ExtArgs> | null
    /**
     * Filter, which PermanentItems to fetch.
     */
    where?: PermanentItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermanentItems to fetch.
     */
    orderBy?: PermanentItemOrderByWithRelationInput | PermanentItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PermanentItems.
     */
    cursor?: PermanentItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermanentItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermanentItems.
     */
    skip?: number
    distinct?: PermanentItemScalarFieldEnum | PermanentItemScalarFieldEnum[]
  }

  /**
   * PermanentItem create
   */
  export type PermanentItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermanentItem
     */
    select?: PermanentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermanentItem
     */
    omit?: PermanentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermanentItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PermanentItem.
     */
    data: XOR<PermanentItemCreateInput, PermanentItemUncheckedCreateInput>
  }

  /**
   * PermanentItem createMany
   */
  export type PermanentItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PermanentItems.
     */
    data: PermanentItemCreateManyInput | PermanentItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PermanentItem createManyAndReturn
   */
  export type PermanentItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermanentItem
     */
    select?: PermanentItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PermanentItem
     */
    omit?: PermanentItemOmit<ExtArgs> | null
    /**
     * The data used to create many PermanentItems.
     */
    data: PermanentItemCreateManyInput | PermanentItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermanentItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PermanentItem update
   */
  export type PermanentItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermanentItem
     */
    select?: PermanentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermanentItem
     */
    omit?: PermanentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermanentItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PermanentItem.
     */
    data: XOR<PermanentItemUpdateInput, PermanentItemUncheckedUpdateInput>
    /**
     * Choose, which PermanentItem to update.
     */
    where: PermanentItemWhereUniqueInput
  }

  /**
   * PermanentItem updateMany
   */
  export type PermanentItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PermanentItems.
     */
    data: XOR<PermanentItemUpdateManyMutationInput, PermanentItemUncheckedUpdateManyInput>
    /**
     * Filter which PermanentItems to update
     */
    where?: PermanentItemWhereInput
    /**
     * Limit how many PermanentItems to update.
     */
    limit?: number
  }

  /**
   * PermanentItem updateManyAndReturn
   */
  export type PermanentItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermanentItem
     */
    select?: PermanentItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PermanentItem
     */
    omit?: PermanentItemOmit<ExtArgs> | null
    /**
     * The data used to update PermanentItems.
     */
    data: XOR<PermanentItemUpdateManyMutationInput, PermanentItemUncheckedUpdateManyInput>
    /**
     * Filter which PermanentItems to update
     */
    where?: PermanentItemWhereInput
    /**
     * Limit how many PermanentItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermanentItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PermanentItem upsert
   */
  export type PermanentItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermanentItem
     */
    select?: PermanentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermanentItem
     */
    omit?: PermanentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermanentItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PermanentItem to update in case it exists.
     */
    where: PermanentItemWhereUniqueInput
    /**
     * In case the PermanentItem found by the `where` argument doesn't exist, create a new PermanentItem with this data.
     */
    create: XOR<PermanentItemCreateInput, PermanentItemUncheckedCreateInput>
    /**
     * In case the PermanentItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermanentItemUpdateInput, PermanentItemUncheckedUpdateInput>
  }

  /**
   * PermanentItem delete
   */
  export type PermanentItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermanentItem
     */
    select?: PermanentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermanentItem
     */
    omit?: PermanentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermanentItemInclude<ExtArgs> | null
    /**
     * Filter which PermanentItem to delete.
     */
    where: PermanentItemWhereUniqueInput
  }

  /**
   * PermanentItem deleteMany
   */
  export type PermanentItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PermanentItems to delete
     */
    where?: PermanentItemWhereInput
    /**
     * Limit how many PermanentItems to delete.
     */
    limit?: number
  }

  /**
   * PermanentItem without action
   */
  export type PermanentItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermanentItem
     */
    select?: PermanentItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermanentItem
     */
    omit?: PermanentItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermanentItemInclude<ExtArgs> | null
  }


  /**
   * Model saleTempEntry
   */

  export type AggregateSaleTempEntry = {
    _count: SaleTempEntryCountAggregateOutputType | null
    _avg: SaleTempEntryAvgAggregateOutputType | null
    _sum: SaleTempEntrySumAggregateOutputType | null
    _min: SaleTempEntryMinAggregateOutputType | null
    _max: SaleTempEntryMaxAggregateOutputType | null
  }

  export type SaleTempEntryAvgAggregateOutputType = {
    id: number | null
    qty: number | null
    rate: number | null
  }

  export type SaleTempEntrySumAggregateOutputType = {
    id: number | null
    qty: number | null
    rate: number | null
  }

  export type SaleTempEntryMinAggregateOutputType = {
    id: number | null
    partyname: string | null
    invcdt: Date | null
    itemName: string | null
    disc: string | null
    qty: number | null
    rate: number | null
    shpAdd: string | null
  }

  export type SaleTempEntryMaxAggregateOutputType = {
    id: number | null
    partyname: string | null
    invcdt: Date | null
    itemName: string | null
    disc: string | null
    qty: number | null
    rate: number | null
    shpAdd: string | null
  }

  export type SaleTempEntryCountAggregateOutputType = {
    id: number
    partyname: number
    invcdt: number
    itemName: number
    disc: number
    qty: number
    rate: number
    shpAdd: number
    _all: number
  }


  export type SaleTempEntryAvgAggregateInputType = {
    id?: true
    qty?: true
    rate?: true
  }

  export type SaleTempEntrySumAggregateInputType = {
    id?: true
    qty?: true
    rate?: true
  }

  export type SaleTempEntryMinAggregateInputType = {
    id?: true
    partyname?: true
    invcdt?: true
    itemName?: true
    disc?: true
    qty?: true
    rate?: true
    shpAdd?: true
  }

  export type SaleTempEntryMaxAggregateInputType = {
    id?: true
    partyname?: true
    invcdt?: true
    itemName?: true
    disc?: true
    qty?: true
    rate?: true
    shpAdd?: true
  }

  export type SaleTempEntryCountAggregateInputType = {
    id?: true
    partyname?: true
    invcdt?: true
    itemName?: true
    disc?: true
    qty?: true
    rate?: true
    shpAdd?: true
    _all?: true
  }

  export type SaleTempEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which saleTempEntry to aggregate.
     */
    where?: saleTempEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saleTempEntries to fetch.
     */
    orderBy?: saleTempEntryOrderByWithRelationInput | saleTempEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: saleTempEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saleTempEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saleTempEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned saleTempEntries
    **/
    _count?: true | SaleTempEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleTempEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleTempEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleTempEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleTempEntryMaxAggregateInputType
  }

  export type GetSaleTempEntryAggregateType<T extends SaleTempEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleTempEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleTempEntry[P]>
      : GetScalarType<T[P], AggregateSaleTempEntry[P]>
  }




  export type saleTempEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: saleTempEntryWhereInput
    orderBy?: saleTempEntryOrderByWithAggregationInput | saleTempEntryOrderByWithAggregationInput[]
    by: SaleTempEntryScalarFieldEnum[] | SaleTempEntryScalarFieldEnum
    having?: saleTempEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleTempEntryCountAggregateInputType | true
    _avg?: SaleTempEntryAvgAggregateInputType
    _sum?: SaleTempEntrySumAggregateInputType
    _min?: SaleTempEntryMinAggregateInputType
    _max?: SaleTempEntryMaxAggregateInputType
  }

  export type SaleTempEntryGroupByOutputType = {
    id: number
    partyname: string | null
    invcdt: Date | null
    itemName: string | null
    disc: string | null
    qty: number | null
    rate: number | null
    shpAdd: string | null
    _count: SaleTempEntryCountAggregateOutputType | null
    _avg: SaleTempEntryAvgAggregateOutputType | null
    _sum: SaleTempEntrySumAggregateOutputType | null
    _min: SaleTempEntryMinAggregateOutputType | null
    _max: SaleTempEntryMaxAggregateOutputType | null
  }

  type GetSaleTempEntryGroupByPayload<T extends saleTempEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleTempEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleTempEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleTempEntryGroupByOutputType[P]>
            : GetScalarType<T[P], SaleTempEntryGroupByOutputType[P]>
        }
      >
    >


  export type saleTempEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partyname?: boolean
    invcdt?: boolean
    itemName?: boolean
    disc?: boolean
    qty?: boolean
    rate?: boolean
    shpAdd?: boolean
  }, ExtArgs["result"]["saleTempEntry"]>

  export type saleTempEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partyname?: boolean
    invcdt?: boolean
    itemName?: boolean
    disc?: boolean
    qty?: boolean
    rate?: boolean
    shpAdd?: boolean
  }, ExtArgs["result"]["saleTempEntry"]>

  export type saleTempEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    partyname?: boolean
    invcdt?: boolean
    itemName?: boolean
    disc?: boolean
    qty?: boolean
    rate?: boolean
    shpAdd?: boolean
  }, ExtArgs["result"]["saleTempEntry"]>

  export type saleTempEntrySelectScalar = {
    id?: boolean
    partyname?: boolean
    invcdt?: boolean
    itemName?: boolean
    disc?: boolean
    qty?: boolean
    rate?: boolean
    shpAdd?: boolean
  }

  export type saleTempEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "partyname" | "invcdt" | "itemName" | "disc" | "qty" | "rate" | "shpAdd", ExtArgs["result"]["saleTempEntry"]>

  export type $saleTempEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "saleTempEntry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      partyname: string | null
      invcdt: Date | null
      itemName: string | null
      disc: string | null
      qty: number | null
      rate: number | null
      shpAdd: string | null
    }, ExtArgs["result"]["saleTempEntry"]>
    composites: {}
  }

  type saleTempEntryGetPayload<S extends boolean | null | undefined | saleTempEntryDefaultArgs> = $Result.GetResult<Prisma.$saleTempEntryPayload, S>

  type saleTempEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<saleTempEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleTempEntryCountAggregateInputType | true
    }

  export interface saleTempEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['saleTempEntry'], meta: { name: 'saleTempEntry' } }
    /**
     * Find zero or one SaleTempEntry that matches the filter.
     * @param {saleTempEntryFindUniqueArgs} args - Arguments to find a SaleTempEntry
     * @example
     * // Get one SaleTempEntry
     * const saleTempEntry = await prisma.saleTempEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends saleTempEntryFindUniqueArgs>(args: SelectSubset<T, saleTempEntryFindUniqueArgs<ExtArgs>>): Prisma__saleTempEntryClient<$Result.GetResult<Prisma.$saleTempEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SaleTempEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {saleTempEntryFindUniqueOrThrowArgs} args - Arguments to find a SaleTempEntry
     * @example
     * // Get one SaleTempEntry
     * const saleTempEntry = await prisma.saleTempEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends saleTempEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, saleTempEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__saleTempEntryClient<$Result.GetResult<Prisma.$saleTempEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleTempEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saleTempEntryFindFirstArgs} args - Arguments to find a SaleTempEntry
     * @example
     * // Get one SaleTempEntry
     * const saleTempEntry = await prisma.saleTempEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends saleTempEntryFindFirstArgs>(args?: SelectSubset<T, saleTempEntryFindFirstArgs<ExtArgs>>): Prisma__saleTempEntryClient<$Result.GetResult<Prisma.$saleTempEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleTempEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saleTempEntryFindFirstOrThrowArgs} args - Arguments to find a SaleTempEntry
     * @example
     * // Get one SaleTempEntry
     * const saleTempEntry = await prisma.saleTempEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends saleTempEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, saleTempEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__saleTempEntryClient<$Result.GetResult<Prisma.$saleTempEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SaleTempEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saleTempEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleTempEntries
     * const saleTempEntries = await prisma.saleTempEntry.findMany()
     * 
     * // Get first 10 SaleTempEntries
     * const saleTempEntries = await prisma.saleTempEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleTempEntryWithIdOnly = await prisma.saleTempEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends saleTempEntryFindManyArgs>(args?: SelectSubset<T, saleTempEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saleTempEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SaleTempEntry.
     * @param {saleTempEntryCreateArgs} args - Arguments to create a SaleTempEntry.
     * @example
     * // Create one SaleTempEntry
     * const SaleTempEntry = await prisma.saleTempEntry.create({
     *   data: {
     *     // ... data to create a SaleTempEntry
     *   }
     * })
     * 
     */
    create<T extends saleTempEntryCreateArgs>(args: SelectSubset<T, saleTempEntryCreateArgs<ExtArgs>>): Prisma__saleTempEntryClient<$Result.GetResult<Prisma.$saleTempEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SaleTempEntries.
     * @param {saleTempEntryCreateManyArgs} args - Arguments to create many SaleTempEntries.
     * @example
     * // Create many SaleTempEntries
     * const saleTempEntry = await prisma.saleTempEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends saleTempEntryCreateManyArgs>(args?: SelectSubset<T, saleTempEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleTempEntries and returns the data saved in the database.
     * @param {saleTempEntryCreateManyAndReturnArgs} args - Arguments to create many SaleTempEntries.
     * @example
     * // Create many SaleTempEntries
     * const saleTempEntry = await prisma.saleTempEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleTempEntries and only return the `id`
     * const saleTempEntryWithIdOnly = await prisma.saleTempEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends saleTempEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, saleTempEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saleTempEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SaleTempEntry.
     * @param {saleTempEntryDeleteArgs} args - Arguments to delete one SaleTempEntry.
     * @example
     * // Delete one SaleTempEntry
     * const SaleTempEntry = await prisma.saleTempEntry.delete({
     *   where: {
     *     // ... filter to delete one SaleTempEntry
     *   }
     * })
     * 
     */
    delete<T extends saleTempEntryDeleteArgs>(args: SelectSubset<T, saleTempEntryDeleteArgs<ExtArgs>>): Prisma__saleTempEntryClient<$Result.GetResult<Prisma.$saleTempEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SaleTempEntry.
     * @param {saleTempEntryUpdateArgs} args - Arguments to update one SaleTempEntry.
     * @example
     * // Update one SaleTempEntry
     * const saleTempEntry = await prisma.saleTempEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends saleTempEntryUpdateArgs>(args: SelectSubset<T, saleTempEntryUpdateArgs<ExtArgs>>): Prisma__saleTempEntryClient<$Result.GetResult<Prisma.$saleTempEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SaleTempEntries.
     * @param {saleTempEntryDeleteManyArgs} args - Arguments to filter SaleTempEntries to delete.
     * @example
     * // Delete a few SaleTempEntries
     * const { count } = await prisma.saleTempEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends saleTempEntryDeleteManyArgs>(args?: SelectSubset<T, saleTempEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleTempEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saleTempEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleTempEntries
     * const saleTempEntry = await prisma.saleTempEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends saleTempEntryUpdateManyArgs>(args: SelectSubset<T, saleTempEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleTempEntries and returns the data updated in the database.
     * @param {saleTempEntryUpdateManyAndReturnArgs} args - Arguments to update many SaleTempEntries.
     * @example
     * // Update many SaleTempEntries
     * const saleTempEntry = await prisma.saleTempEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SaleTempEntries and only return the `id`
     * const saleTempEntryWithIdOnly = await prisma.saleTempEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends saleTempEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, saleTempEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$saleTempEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SaleTempEntry.
     * @param {saleTempEntryUpsertArgs} args - Arguments to update or create a SaleTempEntry.
     * @example
     * // Update or create a SaleTempEntry
     * const saleTempEntry = await prisma.saleTempEntry.upsert({
     *   create: {
     *     // ... data to create a SaleTempEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleTempEntry we want to update
     *   }
     * })
     */
    upsert<T extends saleTempEntryUpsertArgs>(args: SelectSubset<T, saleTempEntryUpsertArgs<ExtArgs>>): Prisma__saleTempEntryClient<$Result.GetResult<Prisma.$saleTempEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SaleTempEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saleTempEntryCountArgs} args - Arguments to filter SaleTempEntries to count.
     * @example
     * // Count the number of SaleTempEntries
     * const count = await prisma.saleTempEntry.count({
     *   where: {
     *     // ... the filter for the SaleTempEntries we want to count
     *   }
     * })
    **/
    count<T extends saleTempEntryCountArgs>(
      args?: Subset<T, saleTempEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleTempEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleTempEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleTempEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleTempEntryAggregateArgs>(args: Subset<T, SaleTempEntryAggregateArgs>): Prisma.PrismaPromise<GetSaleTempEntryAggregateType<T>>

    /**
     * Group by SaleTempEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {saleTempEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends saleTempEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: saleTempEntryGroupByArgs['orderBy'] }
        : { orderBy?: saleTempEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, saleTempEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleTempEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the saleTempEntry model
   */
  readonly fields: saleTempEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for saleTempEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__saleTempEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the saleTempEntry model
   */
  interface saleTempEntryFieldRefs {
    readonly id: FieldRef<"saleTempEntry", 'Int'>
    readonly partyname: FieldRef<"saleTempEntry", 'String'>
    readonly invcdt: FieldRef<"saleTempEntry", 'DateTime'>
    readonly itemName: FieldRef<"saleTempEntry", 'String'>
    readonly disc: FieldRef<"saleTempEntry", 'String'>
    readonly qty: FieldRef<"saleTempEntry", 'Float'>
    readonly rate: FieldRef<"saleTempEntry", 'Float'>
    readonly shpAdd: FieldRef<"saleTempEntry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * saleTempEntry findUnique
   */
  export type saleTempEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleTempEntry
     */
    select?: saleTempEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the saleTempEntry
     */
    omit?: saleTempEntryOmit<ExtArgs> | null
    /**
     * Filter, which saleTempEntry to fetch.
     */
    where: saleTempEntryWhereUniqueInput
  }

  /**
   * saleTempEntry findUniqueOrThrow
   */
  export type saleTempEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleTempEntry
     */
    select?: saleTempEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the saleTempEntry
     */
    omit?: saleTempEntryOmit<ExtArgs> | null
    /**
     * Filter, which saleTempEntry to fetch.
     */
    where: saleTempEntryWhereUniqueInput
  }

  /**
   * saleTempEntry findFirst
   */
  export type saleTempEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleTempEntry
     */
    select?: saleTempEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the saleTempEntry
     */
    omit?: saleTempEntryOmit<ExtArgs> | null
    /**
     * Filter, which saleTempEntry to fetch.
     */
    where?: saleTempEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saleTempEntries to fetch.
     */
    orderBy?: saleTempEntryOrderByWithRelationInput | saleTempEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for saleTempEntries.
     */
    cursor?: saleTempEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saleTempEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saleTempEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of saleTempEntries.
     */
    distinct?: SaleTempEntryScalarFieldEnum | SaleTempEntryScalarFieldEnum[]
  }

  /**
   * saleTempEntry findFirstOrThrow
   */
  export type saleTempEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleTempEntry
     */
    select?: saleTempEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the saleTempEntry
     */
    omit?: saleTempEntryOmit<ExtArgs> | null
    /**
     * Filter, which saleTempEntry to fetch.
     */
    where?: saleTempEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saleTempEntries to fetch.
     */
    orderBy?: saleTempEntryOrderByWithRelationInput | saleTempEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for saleTempEntries.
     */
    cursor?: saleTempEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saleTempEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saleTempEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of saleTempEntries.
     */
    distinct?: SaleTempEntryScalarFieldEnum | SaleTempEntryScalarFieldEnum[]
  }

  /**
   * saleTempEntry findMany
   */
  export type saleTempEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleTempEntry
     */
    select?: saleTempEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the saleTempEntry
     */
    omit?: saleTempEntryOmit<ExtArgs> | null
    /**
     * Filter, which saleTempEntries to fetch.
     */
    where?: saleTempEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of saleTempEntries to fetch.
     */
    orderBy?: saleTempEntryOrderByWithRelationInput | saleTempEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing saleTempEntries.
     */
    cursor?: saleTempEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` saleTempEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` saleTempEntries.
     */
    skip?: number
    distinct?: SaleTempEntryScalarFieldEnum | SaleTempEntryScalarFieldEnum[]
  }

  /**
   * saleTempEntry create
   */
  export type saleTempEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleTempEntry
     */
    select?: saleTempEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the saleTempEntry
     */
    omit?: saleTempEntryOmit<ExtArgs> | null
    /**
     * The data needed to create a saleTempEntry.
     */
    data?: XOR<saleTempEntryCreateInput, saleTempEntryUncheckedCreateInput>
  }

  /**
   * saleTempEntry createMany
   */
  export type saleTempEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many saleTempEntries.
     */
    data: saleTempEntryCreateManyInput | saleTempEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * saleTempEntry createManyAndReturn
   */
  export type saleTempEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleTempEntry
     */
    select?: saleTempEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the saleTempEntry
     */
    omit?: saleTempEntryOmit<ExtArgs> | null
    /**
     * The data used to create many saleTempEntries.
     */
    data: saleTempEntryCreateManyInput | saleTempEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * saleTempEntry update
   */
  export type saleTempEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleTempEntry
     */
    select?: saleTempEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the saleTempEntry
     */
    omit?: saleTempEntryOmit<ExtArgs> | null
    /**
     * The data needed to update a saleTempEntry.
     */
    data: XOR<saleTempEntryUpdateInput, saleTempEntryUncheckedUpdateInput>
    /**
     * Choose, which saleTempEntry to update.
     */
    where: saleTempEntryWhereUniqueInput
  }

  /**
   * saleTempEntry updateMany
   */
  export type saleTempEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update saleTempEntries.
     */
    data: XOR<saleTempEntryUpdateManyMutationInput, saleTempEntryUncheckedUpdateManyInput>
    /**
     * Filter which saleTempEntries to update
     */
    where?: saleTempEntryWhereInput
    /**
     * Limit how many saleTempEntries to update.
     */
    limit?: number
  }

  /**
   * saleTempEntry updateManyAndReturn
   */
  export type saleTempEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleTempEntry
     */
    select?: saleTempEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the saleTempEntry
     */
    omit?: saleTempEntryOmit<ExtArgs> | null
    /**
     * The data used to update saleTempEntries.
     */
    data: XOR<saleTempEntryUpdateManyMutationInput, saleTempEntryUncheckedUpdateManyInput>
    /**
     * Filter which saleTempEntries to update
     */
    where?: saleTempEntryWhereInput
    /**
     * Limit how many saleTempEntries to update.
     */
    limit?: number
  }

  /**
   * saleTempEntry upsert
   */
  export type saleTempEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleTempEntry
     */
    select?: saleTempEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the saleTempEntry
     */
    omit?: saleTempEntryOmit<ExtArgs> | null
    /**
     * The filter to search for the saleTempEntry to update in case it exists.
     */
    where: saleTempEntryWhereUniqueInput
    /**
     * In case the saleTempEntry found by the `where` argument doesn't exist, create a new saleTempEntry with this data.
     */
    create: XOR<saleTempEntryCreateInput, saleTempEntryUncheckedCreateInput>
    /**
     * In case the saleTempEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<saleTempEntryUpdateInput, saleTempEntryUncheckedUpdateInput>
  }

  /**
   * saleTempEntry delete
   */
  export type saleTempEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleTempEntry
     */
    select?: saleTempEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the saleTempEntry
     */
    omit?: saleTempEntryOmit<ExtArgs> | null
    /**
     * Filter which saleTempEntry to delete.
     */
    where: saleTempEntryWhereUniqueInput
  }

  /**
   * saleTempEntry deleteMany
   */
  export type saleTempEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which saleTempEntries to delete
     */
    where?: saleTempEntryWhereInput
    /**
     * Limit how many saleTempEntries to delete.
     */
    limit?: number
  }

  /**
   * saleTempEntry without action
   */
  export type saleTempEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the saleTempEntry
     */
    select?: saleTempEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the saleTempEntry
     */
    omit?: saleTempEntryOmit<ExtArgs> | null
  }


  /**
   * Model CustomerPricingRule
   */

  export type AggregateCustomerPricingRule = {
    _count: CustomerPricingRuleCountAggregateOutputType | null
    _avg: CustomerPricingRuleAvgAggregateOutputType | null
    _sum: CustomerPricingRuleSumAggregateOutputType | null
    _min: CustomerPricingRuleMinAggregateOutputType | null
    _max: CustomerPricingRuleMaxAggregateOutputType | null
  }

  export type CustomerPricingRuleAvgAggregateOutputType = {
    id: number | null
    party_id: number | null
    item_id: number | null
    min_qty: number | null
    fixed_price: Decimal | null
  }

  export type CustomerPricingRuleSumAggregateOutputType = {
    id: number | null
    party_id: number | null
    item_id: number | null
    min_qty: number | null
    fixed_price: Decimal | null
  }

  export type CustomerPricingRuleMinAggregateOutputType = {
    id: number | null
    party_id: number | null
    item_id: number | null
    min_qty: number | null
    fixed_price: Decimal | null
    effective_from: Date | null
    effective_to: Date | null
  }

  export type CustomerPricingRuleMaxAggregateOutputType = {
    id: number | null
    party_id: number | null
    item_id: number | null
    min_qty: number | null
    fixed_price: Decimal | null
    effective_from: Date | null
    effective_to: Date | null
  }

  export type CustomerPricingRuleCountAggregateOutputType = {
    id: number
    party_id: number
    item_id: number
    min_qty: number
    fixed_price: number
    effective_from: number
    effective_to: number
    _all: number
  }


  export type CustomerPricingRuleAvgAggregateInputType = {
    id?: true
    party_id?: true
    item_id?: true
    min_qty?: true
    fixed_price?: true
  }

  export type CustomerPricingRuleSumAggregateInputType = {
    id?: true
    party_id?: true
    item_id?: true
    min_qty?: true
    fixed_price?: true
  }

  export type CustomerPricingRuleMinAggregateInputType = {
    id?: true
    party_id?: true
    item_id?: true
    min_qty?: true
    fixed_price?: true
    effective_from?: true
    effective_to?: true
  }

  export type CustomerPricingRuleMaxAggregateInputType = {
    id?: true
    party_id?: true
    item_id?: true
    min_qty?: true
    fixed_price?: true
    effective_from?: true
    effective_to?: true
  }

  export type CustomerPricingRuleCountAggregateInputType = {
    id?: true
    party_id?: true
    item_id?: true
    min_qty?: true
    fixed_price?: true
    effective_from?: true
    effective_to?: true
    _all?: true
  }

  export type CustomerPricingRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerPricingRule to aggregate.
     */
    where?: CustomerPricingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPricingRules to fetch.
     */
    orderBy?: CustomerPricingRuleOrderByWithRelationInput | CustomerPricingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerPricingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPricingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPricingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerPricingRules
    **/
    _count?: true | CustomerPricingRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerPricingRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerPricingRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerPricingRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerPricingRuleMaxAggregateInputType
  }

  export type GetCustomerPricingRuleAggregateType<T extends CustomerPricingRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerPricingRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerPricingRule[P]>
      : GetScalarType<T[P], AggregateCustomerPricingRule[P]>
  }




  export type CustomerPricingRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerPricingRuleWhereInput
    orderBy?: CustomerPricingRuleOrderByWithAggregationInput | CustomerPricingRuleOrderByWithAggregationInput[]
    by: CustomerPricingRuleScalarFieldEnum[] | CustomerPricingRuleScalarFieldEnum
    having?: CustomerPricingRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerPricingRuleCountAggregateInputType | true
    _avg?: CustomerPricingRuleAvgAggregateInputType
    _sum?: CustomerPricingRuleSumAggregateInputType
    _min?: CustomerPricingRuleMinAggregateInputType
    _max?: CustomerPricingRuleMaxAggregateInputType
  }

  export type CustomerPricingRuleGroupByOutputType = {
    id: number
    party_id: number
    item_id: number
    min_qty: number | null
    fixed_price: Decimal
    effective_from: Date
    effective_to: Date | null
    _count: CustomerPricingRuleCountAggregateOutputType | null
    _avg: CustomerPricingRuleAvgAggregateOutputType | null
    _sum: CustomerPricingRuleSumAggregateOutputType | null
    _min: CustomerPricingRuleMinAggregateOutputType | null
    _max: CustomerPricingRuleMaxAggregateOutputType | null
  }

  type GetCustomerPricingRuleGroupByPayload<T extends CustomerPricingRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerPricingRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerPricingRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerPricingRuleGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerPricingRuleGroupByOutputType[P]>
        }
      >
    >


  export type CustomerPricingRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    party_id?: boolean
    item_id?: boolean
    min_qty?: boolean
    fixed_price?: boolean
    effective_from?: boolean
    effective_to?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    party?: boolean | PartyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerPricingRule"]>

  export type CustomerPricingRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    party_id?: boolean
    item_id?: boolean
    min_qty?: boolean
    fixed_price?: boolean
    effective_from?: boolean
    effective_to?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    party?: boolean | PartyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerPricingRule"]>

  export type CustomerPricingRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    party_id?: boolean
    item_id?: boolean
    min_qty?: boolean
    fixed_price?: boolean
    effective_from?: boolean
    effective_to?: boolean
    item?: boolean | ItemDefaultArgs<ExtArgs>
    party?: boolean | PartyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerPricingRule"]>

  export type CustomerPricingRuleSelectScalar = {
    id?: boolean
    party_id?: boolean
    item_id?: boolean
    min_qty?: boolean
    fixed_price?: boolean
    effective_from?: boolean
    effective_to?: boolean
  }

  export type CustomerPricingRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "party_id" | "item_id" | "min_qty" | "fixed_price" | "effective_from" | "effective_to", ExtArgs["result"]["customerPricingRule"]>
  export type CustomerPricingRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    party?: boolean | PartyDefaultArgs<ExtArgs>
  }
  export type CustomerPricingRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    party?: boolean | PartyDefaultArgs<ExtArgs>
  }
  export type CustomerPricingRuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | ItemDefaultArgs<ExtArgs>
    party?: boolean | PartyDefaultArgs<ExtArgs>
  }

  export type $CustomerPricingRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerPricingRule"
    objects: {
      item: Prisma.$ItemPayload<ExtArgs>
      party: Prisma.$PartyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      party_id: number
      item_id: number
      min_qty: number | null
      fixed_price: Prisma.Decimal
      effective_from: Date
      effective_to: Date | null
    }, ExtArgs["result"]["customerPricingRule"]>
    composites: {}
  }

  type CustomerPricingRuleGetPayload<S extends boolean | null | undefined | CustomerPricingRuleDefaultArgs> = $Result.GetResult<Prisma.$CustomerPricingRulePayload, S>

  type CustomerPricingRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerPricingRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerPricingRuleCountAggregateInputType | true
    }

  export interface CustomerPricingRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerPricingRule'], meta: { name: 'CustomerPricingRule' } }
    /**
     * Find zero or one CustomerPricingRule that matches the filter.
     * @param {CustomerPricingRuleFindUniqueArgs} args - Arguments to find a CustomerPricingRule
     * @example
     * // Get one CustomerPricingRule
     * const customerPricingRule = await prisma.customerPricingRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerPricingRuleFindUniqueArgs>(args: SelectSubset<T, CustomerPricingRuleFindUniqueArgs<ExtArgs>>): Prisma__CustomerPricingRuleClient<$Result.GetResult<Prisma.$CustomerPricingRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerPricingRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerPricingRuleFindUniqueOrThrowArgs} args - Arguments to find a CustomerPricingRule
     * @example
     * // Get one CustomerPricingRule
     * const customerPricingRule = await prisma.customerPricingRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerPricingRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerPricingRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerPricingRuleClient<$Result.GetResult<Prisma.$CustomerPricingRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerPricingRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPricingRuleFindFirstArgs} args - Arguments to find a CustomerPricingRule
     * @example
     * // Get one CustomerPricingRule
     * const customerPricingRule = await prisma.customerPricingRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerPricingRuleFindFirstArgs>(args?: SelectSubset<T, CustomerPricingRuleFindFirstArgs<ExtArgs>>): Prisma__CustomerPricingRuleClient<$Result.GetResult<Prisma.$CustomerPricingRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerPricingRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPricingRuleFindFirstOrThrowArgs} args - Arguments to find a CustomerPricingRule
     * @example
     * // Get one CustomerPricingRule
     * const customerPricingRule = await prisma.customerPricingRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerPricingRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerPricingRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerPricingRuleClient<$Result.GetResult<Prisma.$CustomerPricingRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerPricingRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPricingRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerPricingRules
     * const customerPricingRules = await prisma.customerPricingRule.findMany()
     * 
     * // Get first 10 CustomerPricingRules
     * const customerPricingRules = await prisma.customerPricingRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerPricingRuleWithIdOnly = await prisma.customerPricingRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerPricingRuleFindManyArgs>(args?: SelectSubset<T, CustomerPricingRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPricingRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerPricingRule.
     * @param {CustomerPricingRuleCreateArgs} args - Arguments to create a CustomerPricingRule.
     * @example
     * // Create one CustomerPricingRule
     * const CustomerPricingRule = await prisma.customerPricingRule.create({
     *   data: {
     *     // ... data to create a CustomerPricingRule
     *   }
     * })
     * 
     */
    create<T extends CustomerPricingRuleCreateArgs>(args: SelectSubset<T, CustomerPricingRuleCreateArgs<ExtArgs>>): Prisma__CustomerPricingRuleClient<$Result.GetResult<Prisma.$CustomerPricingRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerPricingRules.
     * @param {CustomerPricingRuleCreateManyArgs} args - Arguments to create many CustomerPricingRules.
     * @example
     * // Create many CustomerPricingRules
     * const customerPricingRule = await prisma.customerPricingRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerPricingRuleCreateManyArgs>(args?: SelectSubset<T, CustomerPricingRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerPricingRules and returns the data saved in the database.
     * @param {CustomerPricingRuleCreateManyAndReturnArgs} args - Arguments to create many CustomerPricingRules.
     * @example
     * // Create many CustomerPricingRules
     * const customerPricingRule = await prisma.customerPricingRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerPricingRules and only return the `id`
     * const customerPricingRuleWithIdOnly = await prisma.customerPricingRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerPricingRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerPricingRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPricingRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerPricingRule.
     * @param {CustomerPricingRuleDeleteArgs} args - Arguments to delete one CustomerPricingRule.
     * @example
     * // Delete one CustomerPricingRule
     * const CustomerPricingRule = await prisma.customerPricingRule.delete({
     *   where: {
     *     // ... filter to delete one CustomerPricingRule
     *   }
     * })
     * 
     */
    delete<T extends CustomerPricingRuleDeleteArgs>(args: SelectSubset<T, CustomerPricingRuleDeleteArgs<ExtArgs>>): Prisma__CustomerPricingRuleClient<$Result.GetResult<Prisma.$CustomerPricingRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerPricingRule.
     * @param {CustomerPricingRuleUpdateArgs} args - Arguments to update one CustomerPricingRule.
     * @example
     * // Update one CustomerPricingRule
     * const customerPricingRule = await prisma.customerPricingRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerPricingRuleUpdateArgs>(args: SelectSubset<T, CustomerPricingRuleUpdateArgs<ExtArgs>>): Prisma__CustomerPricingRuleClient<$Result.GetResult<Prisma.$CustomerPricingRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerPricingRules.
     * @param {CustomerPricingRuleDeleteManyArgs} args - Arguments to filter CustomerPricingRules to delete.
     * @example
     * // Delete a few CustomerPricingRules
     * const { count } = await prisma.customerPricingRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerPricingRuleDeleteManyArgs>(args?: SelectSubset<T, CustomerPricingRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerPricingRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPricingRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerPricingRules
     * const customerPricingRule = await prisma.customerPricingRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerPricingRuleUpdateManyArgs>(args: SelectSubset<T, CustomerPricingRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerPricingRules and returns the data updated in the database.
     * @param {CustomerPricingRuleUpdateManyAndReturnArgs} args - Arguments to update many CustomerPricingRules.
     * @example
     * // Update many CustomerPricingRules
     * const customerPricingRule = await prisma.customerPricingRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerPricingRules and only return the `id`
     * const customerPricingRuleWithIdOnly = await prisma.customerPricingRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerPricingRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerPricingRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPricingRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerPricingRule.
     * @param {CustomerPricingRuleUpsertArgs} args - Arguments to update or create a CustomerPricingRule.
     * @example
     * // Update or create a CustomerPricingRule
     * const customerPricingRule = await prisma.customerPricingRule.upsert({
     *   create: {
     *     // ... data to create a CustomerPricingRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerPricingRule we want to update
     *   }
     * })
     */
    upsert<T extends CustomerPricingRuleUpsertArgs>(args: SelectSubset<T, CustomerPricingRuleUpsertArgs<ExtArgs>>): Prisma__CustomerPricingRuleClient<$Result.GetResult<Prisma.$CustomerPricingRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerPricingRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPricingRuleCountArgs} args - Arguments to filter CustomerPricingRules to count.
     * @example
     * // Count the number of CustomerPricingRules
     * const count = await prisma.customerPricingRule.count({
     *   where: {
     *     // ... the filter for the CustomerPricingRules we want to count
     *   }
     * })
    **/
    count<T extends CustomerPricingRuleCountArgs>(
      args?: Subset<T, CustomerPricingRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerPricingRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerPricingRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPricingRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerPricingRuleAggregateArgs>(args: Subset<T, CustomerPricingRuleAggregateArgs>): Prisma.PrismaPromise<GetCustomerPricingRuleAggregateType<T>>

    /**
     * Group by CustomerPricingRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPricingRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerPricingRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerPricingRuleGroupByArgs['orderBy'] }
        : { orderBy?: CustomerPricingRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerPricingRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerPricingRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerPricingRule model
   */
  readonly fields: CustomerPricingRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerPricingRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerPricingRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    party<T extends PartyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PartyDefaultArgs<ExtArgs>>): Prisma__PartyClient<$Result.GetResult<Prisma.$PartyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerPricingRule model
   */
  interface CustomerPricingRuleFieldRefs {
    readonly id: FieldRef<"CustomerPricingRule", 'Int'>
    readonly party_id: FieldRef<"CustomerPricingRule", 'Int'>
    readonly item_id: FieldRef<"CustomerPricingRule", 'Int'>
    readonly min_qty: FieldRef<"CustomerPricingRule", 'Int'>
    readonly fixed_price: FieldRef<"CustomerPricingRule", 'Decimal'>
    readonly effective_from: FieldRef<"CustomerPricingRule", 'DateTime'>
    readonly effective_to: FieldRef<"CustomerPricingRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerPricingRule findUnique
   */
  export type CustomerPricingRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingRule
     */
    select?: CustomerPricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingRule
     */
    omit?: CustomerPricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingRuleInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPricingRule to fetch.
     */
    where: CustomerPricingRuleWhereUniqueInput
  }

  /**
   * CustomerPricingRule findUniqueOrThrow
   */
  export type CustomerPricingRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingRule
     */
    select?: CustomerPricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingRule
     */
    omit?: CustomerPricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingRuleInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPricingRule to fetch.
     */
    where: CustomerPricingRuleWhereUniqueInput
  }

  /**
   * CustomerPricingRule findFirst
   */
  export type CustomerPricingRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingRule
     */
    select?: CustomerPricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingRule
     */
    omit?: CustomerPricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingRuleInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPricingRule to fetch.
     */
    where?: CustomerPricingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPricingRules to fetch.
     */
    orderBy?: CustomerPricingRuleOrderByWithRelationInput | CustomerPricingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerPricingRules.
     */
    cursor?: CustomerPricingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPricingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPricingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerPricingRules.
     */
    distinct?: CustomerPricingRuleScalarFieldEnum | CustomerPricingRuleScalarFieldEnum[]
  }

  /**
   * CustomerPricingRule findFirstOrThrow
   */
  export type CustomerPricingRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingRule
     */
    select?: CustomerPricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingRule
     */
    omit?: CustomerPricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingRuleInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPricingRule to fetch.
     */
    where?: CustomerPricingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPricingRules to fetch.
     */
    orderBy?: CustomerPricingRuleOrderByWithRelationInput | CustomerPricingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerPricingRules.
     */
    cursor?: CustomerPricingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPricingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPricingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerPricingRules.
     */
    distinct?: CustomerPricingRuleScalarFieldEnum | CustomerPricingRuleScalarFieldEnum[]
  }

  /**
   * CustomerPricingRule findMany
   */
  export type CustomerPricingRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingRule
     */
    select?: CustomerPricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingRule
     */
    omit?: CustomerPricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingRuleInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPricingRules to fetch.
     */
    where?: CustomerPricingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPricingRules to fetch.
     */
    orderBy?: CustomerPricingRuleOrderByWithRelationInput | CustomerPricingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerPricingRules.
     */
    cursor?: CustomerPricingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPricingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPricingRules.
     */
    skip?: number
    distinct?: CustomerPricingRuleScalarFieldEnum | CustomerPricingRuleScalarFieldEnum[]
  }

  /**
   * CustomerPricingRule create
   */
  export type CustomerPricingRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingRule
     */
    select?: CustomerPricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingRule
     */
    omit?: CustomerPricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerPricingRule.
     */
    data: XOR<CustomerPricingRuleCreateInput, CustomerPricingRuleUncheckedCreateInput>
  }

  /**
   * CustomerPricingRule createMany
   */
  export type CustomerPricingRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerPricingRules.
     */
    data: CustomerPricingRuleCreateManyInput | CustomerPricingRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerPricingRule createManyAndReturn
   */
  export type CustomerPricingRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingRule
     */
    select?: CustomerPricingRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingRule
     */
    omit?: CustomerPricingRuleOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerPricingRules.
     */
    data: CustomerPricingRuleCreateManyInput | CustomerPricingRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerPricingRule update
   */
  export type CustomerPricingRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingRule
     */
    select?: CustomerPricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingRule
     */
    omit?: CustomerPricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerPricingRule.
     */
    data: XOR<CustomerPricingRuleUpdateInput, CustomerPricingRuleUncheckedUpdateInput>
    /**
     * Choose, which CustomerPricingRule to update.
     */
    where: CustomerPricingRuleWhereUniqueInput
  }

  /**
   * CustomerPricingRule updateMany
   */
  export type CustomerPricingRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerPricingRules.
     */
    data: XOR<CustomerPricingRuleUpdateManyMutationInput, CustomerPricingRuleUncheckedUpdateManyInput>
    /**
     * Filter which CustomerPricingRules to update
     */
    where?: CustomerPricingRuleWhereInput
    /**
     * Limit how many CustomerPricingRules to update.
     */
    limit?: number
  }

  /**
   * CustomerPricingRule updateManyAndReturn
   */
  export type CustomerPricingRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingRule
     */
    select?: CustomerPricingRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingRule
     */
    omit?: CustomerPricingRuleOmit<ExtArgs> | null
    /**
     * The data used to update CustomerPricingRules.
     */
    data: XOR<CustomerPricingRuleUpdateManyMutationInput, CustomerPricingRuleUncheckedUpdateManyInput>
    /**
     * Filter which CustomerPricingRules to update
     */
    where?: CustomerPricingRuleWhereInput
    /**
     * Limit how many CustomerPricingRules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingRuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerPricingRule upsert
   */
  export type CustomerPricingRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingRule
     */
    select?: CustomerPricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingRule
     */
    omit?: CustomerPricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerPricingRule to update in case it exists.
     */
    where: CustomerPricingRuleWhereUniqueInput
    /**
     * In case the CustomerPricingRule found by the `where` argument doesn't exist, create a new CustomerPricingRule with this data.
     */
    create: XOR<CustomerPricingRuleCreateInput, CustomerPricingRuleUncheckedCreateInput>
    /**
     * In case the CustomerPricingRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerPricingRuleUpdateInput, CustomerPricingRuleUncheckedUpdateInput>
  }

  /**
   * CustomerPricingRule delete
   */
  export type CustomerPricingRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingRule
     */
    select?: CustomerPricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingRule
     */
    omit?: CustomerPricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingRuleInclude<ExtArgs> | null
    /**
     * Filter which CustomerPricingRule to delete.
     */
    where: CustomerPricingRuleWhereUniqueInput
  }

  /**
   * CustomerPricingRule deleteMany
   */
  export type CustomerPricingRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerPricingRules to delete
     */
    where?: CustomerPricingRuleWhereInput
    /**
     * Limit how many CustomerPricingRules to delete.
     */
    limit?: number
  }

  /**
   * CustomerPricingRule without action
   */
  export type CustomerPricingRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPricingRule
     */
    select?: CustomerPricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPricingRule
     */
    omit?: CustomerPricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPricingRuleInclude<ExtArgs> | null
  }


  /**
   * Model ProductBatch
   */

  export type AggregateProductBatch = {
    _count: ProductBatchCountAggregateOutputType | null
    _avg: ProductBatchAvgAggregateOutputType | null
    _sum: ProductBatchSumAggregateOutputType | null
    _min: ProductBatchMinAggregateOutputType | null
    _max: ProductBatchMaxAggregateOutputType | null
  }

  export type ProductBatchAvgAggregateOutputType = {
    id: number | null
    stockitemId: number | null
    quantity: number | null
  }

  export type ProductBatchSumAggregateOutputType = {
    id: number | null
    stockitemId: number | null
    quantity: number | null
  }

  export type ProductBatchMinAggregateOutputType = {
    id: number | null
    stockitemId: number | null
    batchNo: string | null
    serialNo: string | null
    expiryDate: Date | null
    mfgDate: Date | null
    quantity: number | null
    createdAt: Date | null
  }

  export type ProductBatchMaxAggregateOutputType = {
    id: number | null
    stockitemId: number | null
    batchNo: string | null
    serialNo: string | null
    expiryDate: Date | null
    mfgDate: Date | null
    quantity: number | null
    createdAt: Date | null
  }

  export type ProductBatchCountAggregateOutputType = {
    id: number
    stockitemId: number
    batchNo: number
    serialNo: number
    expiryDate: number
    mfgDate: number
    quantity: number
    createdAt: number
    _all: number
  }


  export type ProductBatchAvgAggregateInputType = {
    id?: true
    stockitemId?: true
    quantity?: true
  }

  export type ProductBatchSumAggregateInputType = {
    id?: true
    stockitemId?: true
    quantity?: true
  }

  export type ProductBatchMinAggregateInputType = {
    id?: true
    stockitemId?: true
    batchNo?: true
    serialNo?: true
    expiryDate?: true
    mfgDate?: true
    quantity?: true
    createdAt?: true
  }

  export type ProductBatchMaxAggregateInputType = {
    id?: true
    stockitemId?: true
    batchNo?: true
    serialNo?: true
    expiryDate?: true
    mfgDate?: true
    quantity?: true
    createdAt?: true
  }

  export type ProductBatchCountAggregateInputType = {
    id?: true
    stockitemId?: true
    batchNo?: true
    serialNo?: true
    expiryDate?: true
    mfgDate?: true
    quantity?: true
    createdAt?: true
    _all?: true
  }

  export type ProductBatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductBatch to aggregate.
     */
    where?: ProductBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBatches to fetch.
     */
    orderBy?: ProductBatchOrderByWithRelationInput | ProductBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductBatches
    **/
    _count?: true | ProductBatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductBatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductBatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductBatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductBatchMaxAggregateInputType
  }

  export type GetProductBatchAggregateType<T extends ProductBatchAggregateArgs> = {
        [P in keyof T & keyof AggregateProductBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductBatch[P]>
      : GetScalarType<T[P], AggregateProductBatch[P]>
  }




  export type ProductBatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductBatchWhereInput
    orderBy?: ProductBatchOrderByWithAggregationInput | ProductBatchOrderByWithAggregationInput[]
    by: ProductBatchScalarFieldEnum[] | ProductBatchScalarFieldEnum
    having?: ProductBatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductBatchCountAggregateInputType | true
    _avg?: ProductBatchAvgAggregateInputType
    _sum?: ProductBatchSumAggregateInputType
    _min?: ProductBatchMinAggregateInputType
    _max?: ProductBatchMaxAggregateInputType
  }

  export type ProductBatchGroupByOutputType = {
    id: number
    stockitemId: number
    batchNo: string
    serialNo: string | null
    expiryDate: Date | null
    mfgDate: Date | null
    quantity: number
    createdAt: Date
    _count: ProductBatchCountAggregateOutputType | null
    _avg: ProductBatchAvgAggregateOutputType | null
    _sum: ProductBatchSumAggregateOutputType | null
    _min: ProductBatchMinAggregateOutputType | null
    _max: ProductBatchMaxAggregateOutputType | null
  }

  type GetProductBatchGroupByPayload<T extends ProductBatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductBatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductBatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductBatchGroupByOutputType[P]>
            : GetScalarType<T[P], ProductBatchGroupByOutputType[P]>
        }
      >
    >


  export type ProductBatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stockitemId?: boolean
    batchNo?: boolean
    serialNo?: boolean
    expiryDate?: boolean
    mfgDate?: boolean
    quantity?: boolean
    createdAt?: boolean
    stockItem?: boolean | StockItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productBatch"]>

  export type ProductBatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stockitemId?: boolean
    batchNo?: boolean
    serialNo?: boolean
    expiryDate?: boolean
    mfgDate?: boolean
    quantity?: boolean
    createdAt?: boolean
    stockItem?: boolean | StockItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productBatch"]>

  export type ProductBatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stockitemId?: boolean
    batchNo?: boolean
    serialNo?: boolean
    expiryDate?: boolean
    mfgDate?: boolean
    quantity?: boolean
    createdAt?: boolean
    stockItem?: boolean | StockItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productBatch"]>

  export type ProductBatchSelectScalar = {
    id?: boolean
    stockitemId?: boolean
    batchNo?: boolean
    serialNo?: boolean
    expiryDate?: boolean
    mfgDate?: boolean
    quantity?: boolean
    createdAt?: boolean
  }

  export type ProductBatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "stockitemId" | "batchNo" | "serialNo" | "expiryDate" | "mfgDate" | "quantity" | "createdAt", ExtArgs["result"]["productBatch"]>
  export type ProductBatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockItem?: boolean | StockItemDefaultArgs<ExtArgs>
  }
  export type ProductBatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockItem?: boolean | StockItemDefaultArgs<ExtArgs>
  }
  export type ProductBatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stockItem?: boolean | StockItemDefaultArgs<ExtArgs>
  }

  export type $ProductBatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductBatch"
    objects: {
      stockItem: Prisma.$StockItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      stockitemId: number
      batchNo: string
      serialNo: string | null
      expiryDate: Date | null
      mfgDate: Date | null
      quantity: number
      createdAt: Date
    }, ExtArgs["result"]["productBatch"]>
    composites: {}
  }

  type ProductBatchGetPayload<S extends boolean | null | undefined | ProductBatchDefaultArgs> = $Result.GetResult<Prisma.$ProductBatchPayload, S>

  type ProductBatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductBatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductBatchCountAggregateInputType | true
    }

  export interface ProductBatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductBatch'], meta: { name: 'ProductBatch' } }
    /**
     * Find zero or one ProductBatch that matches the filter.
     * @param {ProductBatchFindUniqueArgs} args - Arguments to find a ProductBatch
     * @example
     * // Get one ProductBatch
     * const productBatch = await prisma.productBatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductBatchFindUniqueArgs>(args: SelectSubset<T, ProductBatchFindUniqueArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductBatch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductBatchFindUniqueOrThrowArgs} args - Arguments to find a ProductBatch
     * @example
     * // Get one ProductBatch
     * const productBatch = await prisma.productBatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductBatchFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductBatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductBatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBatchFindFirstArgs} args - Arguments to find a ProductBatch
     * @example
     * // Get one ProductBatch
     * const productBatch = await prisma.productBatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductBatchFindFirstArgs>(args?: SelectSubset<T, ProductBatchFindFirstArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductBatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBatchFindFirstOrThrowArgs} args - Arguments to find a ProductBatch
     * @example
     * // Get one ProductBatch
     * const productBatch = await prisma.productBatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductBatchFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductBatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductBatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductBatches
     * const productBatches = await prisma.productBatch.findMany()
     * 
     * // Get first 10 ProductBatches
     * const productBatches = await prisma.productBatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productBatchWithIdOnly = await prisma.productBatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductBatchFindManyArgs>(args?: SelectSubset<T, ProductBatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductBatch.
     * @param {ProductBatchCreateArgs} args - Arguments to create a ProductBatch.
     * @example
     * // Create one ProductBatch
     * const ProductBatch = await prisma.productBatch.create({
     *   data: {
     *     // ... data to create a ProductBatch
     *   }
     * })
     * 
     */
    create<T extends ProductBatchCreateArgs>(args: SelectSubset<T, ProductBatchCreateArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductBatches.
     * @param {ProductBatchCreateManyArgs} args - Arguments to create many ProductBatches.
     * @example
     * // Create many ProductBatches
     * const productBatch = await prisma.productBatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductBatchCreateManyArgs>(args?: SelectSubset<T, ProductBatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductBatches and returns the data saved in the database.
     * @param {ProductBatchCreateManyAndReturnArgs} args - Arguments to create many ProductBatches.
     * @example
     * // Create many ProductBatches
     * const productBatch = await prisma.productBatch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductBatches and only return the `id`
     * const productBatchWithIdOnly = await prisma.productBatch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductBatchCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductBatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductBatch.
     * @param {ProductBatchDeleteArgs} args - Arguments to delete one ProductBatch.
     * @example
     * // Delete one ProductBatch
     * const ProductBatch = await prisma.productBatch.delete({
     *   where: {
     *     // ... filter to delete one ProductBatch
     *   }
     * })
     * 
     */
    delete<T extends ProductBatchDeleteArgs>(args: SelectSubset<T, ProductBatchDeleteArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductBatch.
     * @param {ProductBatchUpdateArgs} args - Arguments to update one ProductBatch.
     * @example
     * // Update one ProductBatch
     * const productBatch = await prisma.productBatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductBatchUpdateArgs>(args: SelectSubset<T, ProductBatchUpdateArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductBatches.
     * @param {ProductBatchDeleteManyArgs} args - Arguments to filter ProductBatches to delete.
     * @example
     * // Delete a few ProductBatches
     * const { count } = await prisma.productBatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductBatchDeleteManyArgs>(args?: SelectSubset<T, ProductBatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductBatches
     * const productBatch = await prisma.productBatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductBatchUpdateManyArgs>(args: SelectSubset<T, ProductBatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductBatches and returns the data updated in the database.
     * @param {ProductBatchUpdateManyAndReturnArgs} args - Arguments to update many ProductBatches.
     * @example
     * // Update many ProductBatches
     * const productBatch = await prisma.productBatch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductBatches and only return the `id`
     * const productBatchWithIdOnly = await prisma.productBatch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductBatchUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductBatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductBatch.
     * @param {ProductBatchUpsertArgs} args - Arguments to update or create a ProductBatch.
     * @example
     * // Update or create a ProductBatch
     * const productBatch = await prisma.productBatch.upsert({
     *   create: {
     *     // ... data to create a ProductBatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductBatch we want to update
     *   }
     * })
     */
    upsert<T extends ProductBatchUpsertArgs>(args: SelectSubset<T, ProductBatchUpsertArgs<ExtArgs>>): Prisma__ProductBatchClient<$Result.GetResult<Prisma.$ProductBatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBatchCountArgs} args - Arguments to filter ProductBatches to count.
     * @example
     * // Count the number of ProductBatches
     * const count = await prisma.productBatch.count({
     *   where: {
     *     // ... the filter for the ProductBatches we want to count
     *   }
     * })
    **/
    count<T extends ProductBatchCountArgs>(
      args?: Subset<T, ProductBatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductBatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductBatchAggregateArgs>(args: Subset<T, ProductBatchAggregateArgs>): Prisma.PrismaPromise<GetProductBatchAggregateType<T>>

    /**
     * Group by ProductBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductBatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductBatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductBatchGroupByArgs['orderBy'] }
        : { orderBy?: ProductBatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductBatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductBatch model
   */
  readonly fields: ProductBatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductBatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductBatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stockItem<T extends StockItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockItemDefaultArgs<ExtArgs>>): Prisma__StockItemClient<$Result.GetResult<Prisma.$StockItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductBatch model
   */
  interface ProductBatchFieldRefs {
    readonly id: FieldRef<"ProductBatch", 'Int'>
    readonly stockitemId: FieldRef<"ProductBatch", 'Int'>
    readonly batchNo: FieldRef<"ProductBatch", 'String'>
    readonly serialNo: FieldRef<"ProductBatch", 'String'>
    readonly expiryDate: FieldRef<"ProductBatch", 'DateTime'>
    readonly mfgDate: FieldRef<"ProductBatch", 'DateTime'>
    readonly quantity: FieldRef<"ProductBatch", 'Int'>
    readonly createdAt: FieldRef<"ProductBatch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductBatch findUnique
   */
  export type ProductBatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
    /**
     * Filter, which ProductBatch to fetch.
     */
    where: ProductBatchWhereUniqueInput
  }

  /**
   * ProductBatch findUniqueOrThrow
   */
  export type ProductBatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
    /**
     * Filter, which ProductBatch to fetch.
     */
    where: ProductBatchWhereUniqueInput
  }

  /**
   * ProductBatch findFirst
   */
  export type ProductBatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
    /**
     * Filter, which ProductBatch to fetch.
     */
    where?: ProductBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBatches to fetch.
     */
    orderBy?: ProductBatchOrderByWithRelationInput | ProductBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductBatches.
     */
    cursor?: ProductBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductBatches.
     */
    distinct?: ProductBatchScalarFieldEnum | ProductBatchScalarFieldEnum[]
  }

  /**
   * ProductBatch findFirstOrThrow
   */
  export type ProductBatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
    /**
     * Filter, which ProductBatch to fetch.
     */
    where?: ProductBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBatches to fetch.
     */
    orderBy?: ProductBatchOrderByWithRelationInput | ProductBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductBatches.
     */
    cursor?: ProductBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductBatches.
     */
    distinct?: ProductBatchScalarFieldEnum | ProductBatchScalarFieldEnum[]
  }

  /**
   * ProductBatch findMany
   */
  export type ProductBatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
    /**
     * Filter, which ProductBatches to fetch.
     */
    where?: ProductBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductBatches to fetch.
     */
    orderBy?: ProductBatchOrderByWithRelationInput | ProductBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductBatches.
     */
    cursor?: ProductBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductBatches.
     */
    skip?: number
    distinct?: ProductBatchScalarFieldEnum | ProductBatchScalarFieldEnum[]
  }

  /**
   * ProductBatch create
   */
  export type ProductBatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductBatch.
     */
    data: XOR<ProductBatchCreateInput, ProductBatchUncheckedCreateInput>
  }

  /**
   * ProductBatch createMany
   */
  export type ProductBatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductBatches.
     */
    data: ProductBatchCreateManyInput | ProductBatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductBatch createManyAndReturn
   */
  export type ProductBatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * The data used to create many ProductBatches.
     */
    data: ProductBatchCreateManyInput | ProductBatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductBatch update
   */
  export type ProductBatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductBatch.
     */
    data: XOR<ProductBatchUpdateInput, ProductBatchUncheckedUpdateInput>
    /**
     * Choose, which ProductBatch to update.
     */
    where: ProductBatchWhereUniqueInput
  }

  /**
   * ProductBatch updateMany
   */
  export type ProductBatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductBatches.
     */
    data: XOR<ProductBatchUpdateManyMutationInput, ProductBatchUncheckedUpdateManyInput>
    /**
     * Filter which ProductBatches to update
     */
    where?: ProductBatchWhereInput
    /**
     * Limit how many ProductBatches to update.
     */
    limit?: number
  }

  /**
   * ProductBatch updateManyAndReturn
   */
  export type ProductBatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * The data used to update ProductBatches.
     */
    data: XOR<ProductBatchUpdateManyMutationInput, ProductBatchUncheckedUpdateManyInput>
    /**
     * Filter which ProductBatches to update
     */
    where?: ProductBatchWhereInput
    /**
     * Limit how many ProductBatches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductBatch upsert
   */
  export type ProductBatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductBatch to update in case it exists.
     */
    where: ProductBatchWhereUniqueInput
    /**
     * In case the ProductBatch found by the `where` argument doesn't exist, create a new ProductBatch with this data.
     */
    create: XOR<ProductBatchCreateInput, ProductBatchUncheckedCreateInput>
    /**
     * In case the ProductBatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductBatchUpdateInput, ProductBatchUncheckedUpdateInput>
  }

  /**
   * ProductBatch delete
   */
  export type ProductBatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
    /**
     * Filter which ProductBatch to delete.
     */
    where: ProductBatchWhereUniqueInput
  }

  /**
   * ProductBatch deleteMany
   */
  export type ProductBatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductBatches to delete
     */
    where?: ProductBatchWhereInput
    /**
     * Limit how many ProductBatches to delete.
     */
    limit?: number
  }

  /**
   * ProductBatch without action
   */
  export type ProductBatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductBatch
     */
    select?: ProductBatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductBatch
     */
    omit?: ProductBatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductBatchInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseEntry
   */

  export type AggregatePurchaseEntry = {
    _count: PurchaseEntryCountAggregateOutputType | null
    _avg: PurchaseEntryAvgAggregateOutputType | null
    _sum: PurchaseEntrySumAggregateOutputType | null
    _min: PurchaseEntryMinAggregateOutputType | null
    _max: PurchaseEntryMaxAggregateOutputType | null
  }

  export type PurchaseEntryAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    purchaseRate: Decimal | null
  }

  export type PurchaseEntrySumAggregateOutputType = {
    id: number | null
    quantity: number | null
    purchaseRate: Decimal | null
  }

  export type PurchaseEntryMinAggregateOutputType = {
    id: number | null
    date: Date | null
    partyName: string | null
    purchaseNumber: string | null
    itemName: string | null
    quantity: number | null
    purchaseRate: Decimal | null
    purchaseReferenceNumber: string | null
  }

  export type PurchaseEntryMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    partyName: string | null
    purchaseNumber: string | null
    itemName: string | null
    quantity: number | null
    purchaseRate: Decimal | null
    purchaseReferenceNumber: string | null
  }

  export type PurchaseEntryCountAggregateOutputType = {
    id: number
    date: number
    partyName: number
    purchaseNumber: number
    itemName: number
    quantity: number
    purchaseRate: number
    purchaseReferenceNumber: number
    _all: number
  }


  export type PurchaseEntryAvgAggregateInputType = {
    id?: true
    quantity?: true
    purchaseRate?: true
  }

  export type PurchaseEntrySumAggregateInputType = {
    id?: true
    quantity?: true
    purchaseRate?: true
  }

  export type PurchaseEntryMinAggregateInputType = {
    id?: true
    date?: true
    partyName?: true
    purchaseNumber?: true
    itemName?: true
    quantity?: true
    purchaseRate?: true
    purchaseReferenceNumber?: true
  }

  export type PurchaseEntryMaxAggregateInputType = {
    id?: true
    date?: true
    partyName?: true
    purchaseNumber?: true
    itemName?: true
    quantity?: true
    purchaseRate?: true
    purchaseReferenceNumber?: true
  }

  export type PurchaseEntryCountAggregateInputType = {
    id?: true
    date?: true
    partyName?: true
    purchaseNumber?: true
    itemName?: true
    quantity?: true
    purchaseRate?: true
    purchaseReferenceNumber?: true
    _all?: true
  }

  export type PurchaseEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseEntry to aggregate.
     */
    where?: PurchaseEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseEntries to fetch.
     */
    orderBy?: PurchaseEntryOrderByWithRelationInput | PurchaseEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseEntries
    **/
    _count?: true | PurchaseEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseEntryMaxAggregateInputType
  }

  export type GetPurchaseEntryAggregateType<T extends PurchaseEntryAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseEntry[P]>
      : GetScalarType<T[P], AggregatePurchaseEntry[P]>
  }




  export type PurchaseEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseEntryWhereInput
    orderBy?: PurchaseEntryOrderByWithAggregationInput | PurchaseEntryOrderByWithAggregationInput[]
    by: PurchaseEntryScalarFieldEnum[] | PurchaseEntryScalarFieldEnum
    having?: PurchaseEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseEntryCountAggregateInputType | true
    _avg?: PurchaseEntryAvgAggregateInputType
    _sum?: PurchaseEntrySumAggregateInputType
    _min?: PurchaseEntryMinAggregateInputType
    _max?: PurchaseEntryMaxAggregateInputType
  }

  export type PurchaseEntryGroupByOutputType = {
    id: number
    date: Date
    partyName: string
    purchaseNumber: string
    itemName: string
    quantity: number
    purchaseRate: Decimal
    purchaseReferenceNumber: string | null
    _count: PurchaseEntryCountAggregateOutputType | null
    _avg: PurchaseEntryAvgAggregateOutputType | null
    _sum: PurchaseEntrySumAggregateOutputType | null
    _min: PurchaseEntryMinAggregateOutputType | null
    _max: PurchaseEntryMaxAggregateOutputType | null
  }

  type GetPurchaseEntryGroupByPayload<T extends PurchaseEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseEntryGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseEntryGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    partyName?: boolean
    purchaseNumber?: boolean
    itemName?: boolean
    quantity?: boolean
    purchaseRate?: boolean
    purchaseReferenceNumber?: boolean
  }, ExtArgs["result"]["purchaseEntry"]>

  export type PurchaseEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    partyName?: boolean
    purchaseNumber?: boolean
    itemName?: boolean
    quantity?: boolean
    purchaseRate?: boolean
    purchaseReferenceNumber?: boolean
  }, ExtArgs["result"]["purchaseEntry"]>

  export type PurchaseEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    partyName?: boolean
    purchaseNumber?: boolean
    itemName?: boolean
    quantity?: boolean
    purchaseRate?: boolean
    purchaseReferenceNumber?: boolean
  }, ExtArgs["result"]["purchaseEntry"]>

  export type PurchaseEntrySelectScalar = {
    id?: boolean
    date?: boolean
    partyName?: boolean
    purchaseNumber?: boolean
    itemName?: boolean
    quantity?: boolean
    purchaseRate?: boolean
    purchaseReferenceNumber?: boolean
  }

  export type PurchaseEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "partyName" | "purchaseNumber" | "itemName" | "quantity" | "purchaseRate" | "purchaseReferenceNumber", ExtArgs["result"]["purchaseEntry"]>

  export type $PurchaseEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseEntry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      partyName: string
      purchaseNumber: string
      itemName: string
      quantity: number
      purchaseRate: Prisma.Decimal
      /**
       * *
       *    * optional for batch cross‑checks
       */
      purchaseReferenceNumber: string | null
    }, ExtArgs["result"]["purchaseEntry"]>
    composites: {}
  }

  type PurchaseEntryGetPayload<S extends boolean | null | undefined | PurchaseEntryDefaultArgs> = $Result.GetResult<Prisma.$PurchaseEntryPayload, S>

  type PurchaseEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseEntryCountAggregateInputType | true
    }

  export interface PurchaseEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseEntry'], meta: { name: 'PurchaseEntry' } }
    /**
     * Find zero or one PurchaseEntry that matches the filter.
     * @param {PurchaseEntryFindUniqueArgs} args - Arguments to find a PurchaseEntry
     * @example
     * // Get one PurchaseEntry
     * const purchaseEntry = await prisma.purchaseEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseEntryFindUniqueArgs>(args: SelectSubset<T, PurchaseEntryFindUniqueArgs<ExtArgs>>): Prisma__PurchaseEntryClient<$Result.GetResult<Prisma.$PurchaseEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseEntryFindUniqueOrThrowArgs} args - Arguments to find a PurchaseEntry
     * @example
     * // Get one PurchaseEntry
     * const purchaseEntry = await prisma.purchaseEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseEntryClient<$Result.GetResult<Prisma.$PurchaseEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseEntryFindFirstArgs} args - Arguments to find a PurchaseEntry
     * @example
     * // Get one PurchaseEntry
     * const purchaseEntry = await prisma.purchaseEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseEntryFindFirstArgs>(args?: SelectSubset<T, PurchaseEntryFindFirstArgs<ExtArgs>>): Prisma__PurchaseEntryClient<$Result.GetResult<Prisma.$PurchaseEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseEntryFindFirstOrThrowArgs} args - Arguments to find a PurchaseEntry
     * @example
     * // Get one PurchaseEntry
     * const purchaseEntry = await prisma.purchaseEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseEntryClient<$Result.GetResult<Prisma.$PurchaseEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseEntries
     * const purchaseEntries = await prisma.purchaseEntry.findMany()
     * 
     * // Get first 10 PurchaseEntries
     * const purchaseEntries = await prisma.purchaseEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseEntryWithIdOnly = await prisma.purchaseEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseEntryFindManyArgs>(args?: SelectSubset<T, PurchaseEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseEntry.
     * @param {PurchaseEntryCreateArgs} args - Arguments to create a PurchaseEntry.
     * @example
     * // Create one PurchaseEntry
     * const PurchaseEntry = await prisma.purchaseEntry.create({
     *   data: {
     *     // ... data to create a PurchaseEntry
     *   }
     * })
     * 
     */
    create<T extends PurchaseEntryCreateArgs>(args: SelectSubset<T, PurchaseEntryCreateArgs<ExtArgs>>): Prisma__PurchaseEntryClient<$Result.GetResult<Prisma.$PurchaseEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseEntries.
     * @param {PurchaseEntryCreateManyArgs} args - Arguments to create many PurchaseEntries.
     * @example
     * // Create many PurchaseEntries
     * const purchaseEntry = await prisma.purchaseEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseEntryCreateManyArgs>(args?: SelectSubset<T, PurchaseEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseEntries and returns the data saved in the database.
     * @param {PurchaseEntryCreateManyAndReturnArgs} args - Arguments to create many PurchaseEntries.
     * @example
     * // Create many PurchaseEntries
     * const purchaseEntry = await prisma.purchaseEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseEntries and only return the `id`
     * const purchaseEntryWithIdOnly = await prisma.purchaseEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseEntry.
     * @param {PurchaseEntryDeleteArgs} args - Arguments to delete one PurchaseEntry.
     * @example
     * // Delete one PurchaseEntry
     * const PurchaseEntry = await prisma.purchaseEntry.delete({
     *   where: {
     *     // ... filter to delete one PurchaseEntry
     *   }
     * })
     * 
     */
    delete<T extends PurchaseEntryDeleteArgs>(args: SelectSubset<T, PurchaseEntryDeleteArgs<ExtArgs>>): Prisma__PurchaseEntryClient<$Result.GetResult<Prisma.$PurchaseEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseEntry.
     * @param {PurchaseEntryUpdateArgs} args - Arguments to update one PurchaseEntry.
     * @example
     * // Update one PurchaseEntry
     * const purchaseEntry = await prisma.purchaseEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseEntryUpdateArgs>(args: SelectSubset<T, PurchaseEntryUpdateArgs<ExtArgs>>): Prisma__PurchaseEntryClient<$Result.GetResult<Prisma.$PurchaseEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseEntries.
     * @param {PurchaseEntryDeleteManyArgs} args - Arguments to filter PurchaseEntries to delete.
     * @example
     * // Delete a few PurchaseEntries
     * const { count } = await prisma.purchaseEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseEntryDeleteManyArgs>(args?: SelectSubset<T, PurchaseEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseEntries
     * const purchaseEntry = await prisma.purchaseEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseEntryUpdateManyArgs>(args: SelectSubset<T, PurchaseEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseEntries and returns the data updated in the database.
     * @param {PurchaseEntryUpdateManyAndReturnArgs} args - Arguments to update many PurchaseEntries.
     * @example
     * // Update many PurchaseEntries
     * const purchaseEntry = await prisma.purchaseEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseEntries and only return the `id`
     * const purchaseEntryWithIdOnly = await prisma.purchaseEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseEntry.
     * @param {PurchaseEntryUpsertArgs} args - Arguments to update or create a PurchaseEntry.
     * @example
     * // Update or create a PurchaseEntry
     * const purchaseEntry = await prisma.purchaseEntry.upsert({
     *   create: {
     *     // ... data to create a PurchaseEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseEntry we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseEntryUpsertArgs>(args: SelectSubset<T, PurchaseEntryUpsertArgs<ExtArgs>>): Prisma__PurchaseEntryClient<$Result.GetResult<Prisma.$PurchaseEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseEntryCountArgs} args - Arguments to filter PurchaseEntries to count.
     * @example
     * // Count the number of PurchaseEntries
     * const count = await prisma.purchaseEntry.count({
     *   where: {
     *     // ... the filter for the PurchaseEntries we want to count
     *   }
     * })
    **/
    count<T extends PurchaseEntryCountArgs>(
      args?: Subset<T, PurchaseEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseEntryAggregateArgs>(args: Subset<T, PurchaseEntryAggregateArgs>): Prisma.PrismaPromise<GetPurchaseEntryAggregateType<T>>

    /**
     * Group by PurchaseEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseEntryGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseEntry model
   */
  readonly fields: PurchaseEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseEntry model
   */
  interface PurchaseEntryFieldRefs {
    readonly id: FieldRef<"PurchaseEntry", 'Int'>
    readonly date: FieldRef<"PurchaseEntry", 'DateTime'>
    readonly partyName: FieldRef<"PurchaseEntry", 'String'>
    readonly purchaseNumber: FieldRef<"PurchaseEntry", 'String'>
    readonly itemName: FieldRef<"PurchaseEntry", 'String'>
    readonly quantity: FieldRef<"PurchaseEntry", 'Int'>
    readonly purchaseRate: FieldRef<"PurchaseEntry", 'Decimal'>
    readonly purchaseReferenceNumber: FieldRef<"PurchaseEntry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseEntry findUnique
   */
  export type PurchaseEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseEntry
     */
    select?: PurchaseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseEntry
     */
    omit?: PurchaseEntryOmit<ExtArgs> | null
    /**
     * Filter, which PurchaseEntry to fetch.
     */
    where: PurchaseEntryWhereUniqueInput
  }

  /**
   * PurchaseEntry findUniqueOrThrow
   */
  export type PurchaseEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseEntry
     */
    select?: PurchaseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseEntry
     */
    omit?: PurchaseEntryOmit<ExtArgs> | null
    /**
     * Filter, which PurchaseEntry to fetch.
     */
    where: PurchaseEntryWhereUniqueInput
  }

  /**
   * PurchaseEntry findFirst
   */
  export type PurchaseEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseEntry
     */
    select?: PurchaseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseEntry
     */
    omit?: PurchaseEntryOmit<ExtArgs> | null
    /**
     * Filter, which PurchaseEntry to fetch.
     */
    where?: PurchaseEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseEntries to fetch.
     */
    orderBy?: PurchaseEntryOrderByWithRelationInput | PurchaseEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseEntries.
     */
    cursor?: PurchaseEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseEntries.
     */
    distinct?: PurchaseEntryScalarFieldEnum | PurchaseEntryScalarFieldEnum[]
  }

  /**
   * PurchaseEntry findFirstOrThrow
   */
  export type PurchaseEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseEntry
     */
    select?: PurchaseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseEntry
     */
    omit?: PurchaseEntryOmit<ExtArgs> | null
    /**
     * Filter, which PurchaseEntry to fetch.
     */
    where?: PurchaseEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseEntries to fetch.
     */
    orderBy?: PurchaseEntryOrderByWithRelationInput | PurchaseEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseEntries.
     */
    cursor?: PurchaseEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseEntries.
     */
    distinct?: PurchaseEntryScalarFieldEnum | PurchaseEntryScalarFieldEnum[]
  }

  /**
   * PurchaseEntry findMany
   */
  export type PurchaseEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseEntry
     */
    select?: PurchaseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseEntry
     */
    omit?: PurchaseEntryOmit<ExtArgs> | null
    /**
     * Filter, which PurchaseEntries to fetch.
     */
    where?: PurchaseEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseEntries to fetch.
     */
    orderBy?: PurchaseEntryOrderByWithRelationInput | PurchaseEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseEntries.
     */
    cursor?: PurchaseEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseEntries.
     */
    skip?: number
    distinct?: PurchaseEntryScalarFieldEnum | PurchaseEntryScalarFieldEnum[]
  }

  /**
   * PurchaseEntry create
   */
  export type PurchaseEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseEntry
     */
    select?: PurchaseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseEntry
     */
    omit?: PurchaseEntryOmit<ExtArgs> | null
    /**
     * The data needed to create a PurchaseEntry.
     */
    data: XOR<PurchaseEntryCreateInput, PurchaseEntryUncheckedCreateInput>
  }

  /**
   * PurchaseEntry createMany
   */
  export type PurchaseEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseEntries.
     */
    data: PurchaseEntryCreateManyInput | PurchaseEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseEntry createManyAndReturn
   */
  export type PurchaseEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseEntry
     */
    select?: PurchaseEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseEntry
     */
    omit?: PurchaseEntryOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseEntries.
     */
    data: PurchaseEntryCreateManyInput | PurchaseEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseEntry update
   */
  export type PurchaseEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseEntry
     */
    select?: PurchaseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseEntry
     */
    omit?: PurchaseEntryOmit<ExtArgs> | null
    /**
     * The data needed to update a PurchaseEntry.
     */
    data: XOR<PurchaseEntryUpdateInput, PurchaseEntryUncheckedUpdateInput>
    /**
     * Choose, which PurchaseEntry to update.
     */
    where: PurchaseEntryWhereUniqueInput
  }

  /**
   * PurchaseEntry updateMany
   */
  export type PurchaseEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseEntries.
     */
    data: XOR<PurchaseEntryUpdateManyMutationInput, PurchaseEntryUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseEntries to update
     */
    where?: PurchaseEntryWhereInput
    /**
     * Limit how many PurchaseEntries to update.
     */
    limit?: number
  }

  /**
   * PurchaseEntry updateManyAndReturn
   */
  export type PurchaseEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseEntry
     */
    select?: PurchaseEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseEntry
     */
    omit?: PurchaseEntryOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseEntries.
     */
    data: XOR<PurchaseEntryUpdateManyMutationInput, PurchaseEntryUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseEntries to update
     */
    where?: PurchaseEntryWhereInput
    /**
     * Limit how many PurchaseEntries to update.
     */
    limit?: number
  }

  /**
   * PurchaseEntry upsert
   */
  export type PurchaseEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseEntry
     */
    select?: PurchaseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseEntry
     */
    omit?: PurchaseEntryOmit<ExtArgs> | null
    /**
     * The filter to search for the PurchaseEntry to update in case it exists.
     */
    where: PurchaseEntryWhereUniqueInput
    /**
     * In case the PurchaseEntry found by the `where` argument doesn't exist, create a new PurchaseEntry with this data.
     */
    create: XOR<PurchaseEntryCreateInput, PurchaseEntryUncheckedCreateInput>
    /**
     * In case the PurchaseEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseEntryUpdateInput, PurchaseEntryUncheckedUpdateInput>
  }

  /**
   * PurchaseEntry delete
   */
  export type PurchaseEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseEntry
     */
    select?: PurchaseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseEntry
     */
    omit?: PurchaseEntryOmit<ExtArgs> | null
    /**
     * Filter which PurchaseEntry to delete.
     */
    where: PurchaseEntryWhereUniqueInput
  }

  /**
   * PurchaseEntry deleteMany
   */
  export type PurchaseEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseEntries to delete
     */
    where?: PurchaseEntryWhereInput
    /**
     * Limit how many PurchaseEntries to delete.
     */
    limit?: number
  }

  /**
   * PurchaseEntry without action
   */
  export type PurchaseEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseEntry
     */
    select?: PurchaseEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseEntry
     */
    omit?: PurchaseEntryOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PartyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    code: 'code',
    contact: 'contact',
    credit: 'credit',
    dlno: 'dlno',
    gst: 'gst',
    state: 'state',
    type: 'type',
    shipping_address: 'shipping_address',
    credit_period: 'credit_period'
  };

  export type PartyScalarFieldEnum = (typeof PartyScalarFieldEnum)[keyof typeof PartyScalarFieldEnum]


  export const CourierScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CourierScalarFieldEnum = (typeof CourierScalarFieldEnum)[keyof typeof CourierScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    hsn: 'hsn',
    min: 'min',
    rate: 'rate',
    tax: 'tax',
    vendor: 'vendor',
    mrp: 'mrp',
    stockIn: 'stockIn',
    stockHold: 'stockHold',
    stockOut: 'stockOut',
    effectiveStock: 'effectiveStock',
    productType: 'productType'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const InRegisterScalarFieldEnum: {
    id: 'id',
    regNo: 'regNo',
    party: 'party',
    item: 'item',
    qty: 'qty',
    department: 'department',
    deptRef: 'deptRef',
    remark: 'remark',
    others: 'others',
    courier: 'courier',
    complete: 'complete',
    date: 'date'
  };

  export type InRegisterScalarFieldEnum = (typeof InRegisterScalarFieldEnum)[keyof typeof InRegisterScalarFieldEnum]


  export const SaleEntryScalarFieldEnum: {
    id: 'id',
    date: 'date',
    party_name: 'party_name',
    invoice_number: 'invoice_number',
    item_name: 'item_name',
    quantity: 'quantity',
    sell_rate: 'sell_rate',
    profit: 'profit'
  };

  export type SaleEntryScalarFieldEnum = (typeof SaleEntryScalarFieldEnum)[keyof typeof SaleEntryScalarFieldEnum]


  export const SalesByItemScalarFieldEnum: {
    id: 'id',
    date: 'date',
    itemname: 'itemname',
    qty: 'qty'
  };

  export type SalesByItemScalarFieldEnum = (typeof SalesByItemScalarFieldEnum)[keyof typeof SalesByItemScalarFieldEnum]


  export const SaleData2425ScalarFieldEnum: {
    party_name: 'party_name',
    invoice_date: 'invoice_date',
    invoice_no: 'invoice_no',
    item_name: 'item_name',
    quantity: 'quantity',
    rate: 'rate',
    uid: 'uid',
    id: 'id'
  };

  export type SaleData2425ScalarFieldEnum = (typeof SaleData2425ScalarFieldEnum)[keyof typeof SaleData2425ScalarFieldEnum]


  export const StockItemScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    name: 'name',
    hsncode: 'hsncode',
    buyingprice: 'buyingprice',
    supplier: 'supplier',
    tax: 'tax',
    stock: 'stock'
  };

  export type StockItemScalarFieldEnum = (typeof StockItemScalarFieldEnum)[keyof typeof StockItemScalarFieldEnum]


  export const PermanentItemScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    name: 'name',
    reorder_level: 'reorder_level',
    product_note: 'product_note',
    supplier: 'supplier',
    udrl: 'udrl'
  };

  export type PermanentItemScalarFieldEnum = (typeof PermanentItemScalarFieldEnum)[keyof typeof PermanentItemScalarFieldEnum]


  export const SaleTempEntryScalarFieldEnum: {
    id: 'id',
    partyname: 'partyname',
    invcdt: 'invcdt',
    itemName: 'itemName',
    disc: 'disc',
    qty: 'qty',
    rate: 'rate',
    shpAdd: 'shpAdd'
  };

  export type SaleTempEntryScalarFieldEnum = (typeof SaleTempEntryScalarFieldEnum)[keyof typeof SaleTempEntryScalarFieldEnum]


  export const CustomerPricingRuleScalarFieldEnum: {
    id: 'id',
    party_id: 'party_id',
    item_id: 'item_id',
    min_qty: 'min_qty',
    fixed_price: 'fixed_price',
    effective_from: 'effective_from',
    effective_to: 'effective_to'
  };

  export type CustomerPricingRuleScalarFieldEnum = (typeof CustomerPricingRuleScalarFieldEnum)[keyof typeof CustomerPricingRuleScalarFieldEnum]


  export const ProductBatchScalarFieldEnum: {
    id: 'id',
    stockitemId: 'stockitemId',
    batchNo: 'batchNo',
    serialNo: 'serialNo',
    expiryDate: 'expiryDate',
    mfgDate: 'mfgDate',
    quantity: 'quantity',
    createdAt: 'createdAt'
  };

  export type ProductBatchScalarFieldEnum = (typeof ProductBatchScalarFieldEnum)[keyof typeof ProductBatchScalarFieldEnum]


  export const PurchaseEntryScalarFieldEnum: {
    id: 'id',
    date: 'date',
    partyName: 'partyName',
    purchaseNumber: 'purchaseNumber',
    itemName: 'itemName',
    quantity: 'quantity',
    purchaseRate: 'purchaseRate',
    purchaseReferenceNumber: 'purchaseReferenceNumber'
  };

  export type PurchaseEntryScalarFieldEnum = (typeof PurchaseEntryScalarFieldEnum)[keyof typeof PurchaseEntryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    
  /**
   * Deep Input Types
   */


  export type PartyWhereInput = {
    AND?: PartyWhereInput | PartyWhereInput[]
    OR?: PartyWhereInput[]
    NOT?: PartyWhereInput | PartyWhereInput[]
    id?: IntFilter<"Party"> | number
    name?: StringFilter<"Party"> | string
    address?: StringNullableFilter<"Party"> | string | null
    code?: IntNullableFilter<"Party"> | number | null
    contact?: StringNullableFilter<"Party"> | string | null
    credit?: FloatNullableFilter<"Party"> | number | null
    dlno?: StringNullableFilter<"Party"> | string | null
    gst?: StringNullableFilter<"Party"> | string | null
    state?: StringNullableFilter<"Party"> | string | null
    type?: StringNullableFilter<"Party"> | string | null
    shipping_address?: StringNullableFilter<"Party"> | string | null
    credit_period?: StringNullableFilter<"Party"> | string | null
    pricingRules?: CustomerPricingRuleListRelationFilter
  }

  export type PartyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    credit?: SortOrderInput | SortOrder
    dlno?: SortOrderInput | SortOrder
    gst?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    shipping_address?: SortOrderInput | SortOrder
    credit_period?: SortOrderInput | SortOrder
    pricingRules?: CustomerPricingRuleOrderByRelationAggregateInput
  }

  export type PartyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PartyWhereInput | PartyWhereInput[]
    OR?: PartyWhereInput[]
    NOT?: PartyWhereInput | PartyWhereInput[]
    name?: StringFilter<"Party"> | string
    address?: StringNullableFilter<"Party"> | string | null
    code?: IntNullableFilter<"Party"> | number | null
    contact?: StringNullableFilter<"Party"> | string | null
    credit?: FloatNullableFilter<"Party"> | number | null
    dlno?: StringNullableFilter<"Party"> | string | null
    gst?: StringNullableFilter<"Party"> | string | null
    state?: StringNullableFilter<"Party"> | string | null
    type?: StringNullableFilter<"Party"> | string | null
    shipping_address?: StringNullableFilter<"Party"> | string | null
    credit_period?: StringNullableFilter<"Party"> | string | null
    pricingRules?: CustomerPricingRuleListRelationFilter
  }, "id">

  export type PartyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    credit?: SortOrderInput | SortOrder
    dlno?: SortOrderInput | SortOrder
    gst?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    shipping_address?: SortOrderInput | SortOrder
    credit_period?: SortOrderInput | SortOrder
    _count?: PartyCountOrderByAggregateInput
    _avg?: PartyAvgOrderByAggregateInput
    _max?: PartyMaxOrderByAggregateInput
    _min?: PartyMinOrderByAggregateInput
    _sum?: PartySumOrderByAggregateInput
  }

  export type PartyScalarWhereWithAggregatesInput = {
    AND?: PartyScalarWhereWithAggregatesInput | PartyScalarWhereWithAggregatesInput[]
    OR?: PartyScalarWhereWithAggregatesInput[]
    NOT?: PartyScalarWhereWithAggregatesInput | PartyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Party"> | number
    name?: StringWithAggregatesFilter<"Party"> | string
    address?: StringNullableWithAggregatesFilter<"Party"> | string | null
    code?: IntNullableWithAggregatesFilter<"Party"> | number | null
    contact?: StringNullableWithAggregatesFilter<"Party"> | string | null
    credit?: FloatNullableWithAggregatesFilter<"Party"> | number | null
    dlno?: StringNullableWithAggregatesFilter<"Party"> | string | null
    gst?: StringNullableWithAggregatesFilter<"Party"> | string | null
    state?: StringNullableWithAggregatesFilter<"Party"> | string | null
    type?: StringNullableWithAggregatesFilter<"Party"> | string | null
    shipping_address?: StringNullableWithAggregatesFilter<"Party"> | string | null
    credit_period?: StringNullableWithAggregatesFilter<"Party"> | string | null
  }

  export type CourierWhereInput = {
    AND?: CourierWhereInput | CourierWhereInput[]
    OR?: CourierWhereInput[]
    NOT?: CourierWhereInput | CourierWhereInput[]
    id?: IntFilter<"Courier"> | number
    name?: StringFilter<"Courier"> | string
  }

  export type CourierOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CourierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: CourierWhereInput | CourierWhereInput[]
    OR?: CourierWhereInput[]
    NOT?: CourierWhereInput | CourierWhereInput[]
  }, "id" | "name">

  export type CourierOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: CourierCountOrderByAggregateInput
    _avg?: CourierAvgOrderByAggregateInput
    _max?: CourierMaxOrderByAggregateInput
    _min?: CourierMinOrderByAggregateInput
    _sum?: CourierSumOrderByAggregateInput
  }

  export type CourierScalarWhereWithAggregatesInput = {
    AND?: CourierScalarWhereWithAggregatesInput | CourierScalarWhereWithAggregatesInput[]
    OR?: CourierScalarWhereWithAggregatesInput[]
    NOT?: CourierScalarWhereWithAggregatesInput | CourierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Courier"> | number
    name?: StringWithAggregatesFilter<"Courier"> | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: IntFilter<"Department"> | number
    name?: StringFilter<"Department"> | string
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
  }, "id" | "name">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _avg?: DepartmentAvgOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
    _sum?: DepartmentSumOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Department"> | number
    name?: StringWithAggregatesFilter<"Department"> | string
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: IntFilter<"Item"> | number
    name?: StringFilter<"Item"> | string
    hsn?: IntNullableFilter<"Item"> | number | null
    min?: IntNullableFilter<"Item"> | number | null
    rate?: FloatNullableFilter<"Item"> | number | null
    tax?: FloatNullableFilter<"Item"> | number | null
    vendor?: StringNullableFilter<"Item"> | string | null
    mrp?: DecimalNullableFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    stockIn?: IntNullableFilter<"Item"> | number | null
    stockHold?: IntNullableFilter<"Item"> | number | null
    stockOut?: IntNullableFilter<"Item"> | number | null
    productType?: StringNullableFilter<"Item"> | string | null
    pricingRules?: CustomerPricingRuleListRelationFilter
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    hsn?: SortOrderInput | SortOrder
    min?: SortOrderInput | SortOrder
    rate?: SortOrderInput | SortOrder
    tax?: SortOrderInput | SortOrder
    vendor?: SortOrderInput | SortOrder
    mrp?: SortOrderInput | SortOrder
    stockIn?: SortOrderInput | SortOrder
    stockHold?: SortOrderInput | SortOrder
    stockOut?: SortOrderInput | SortOrder
    productType?: SortOrderInput | SortOrder
    pricingRules?: CustomerPricingRuleOrderByRelationAggregateInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    hsn?: IntNullableFilter<"Item"> | number | null
    min?: IntNullableFilter<"Item"> | number | null
    rate?: FloatNullableFilter<"Item"> | number | null
    tax?: FloatNullableFilter<"Item"> | number | null
    vendor?: StringNullableFilter<"Item"> | string | null
    mrp?: DecimalNullableFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    stockIn?: IntNullableFilter<"Item"> | number | null
    stockHold?: IntNullableFilter<"Item"> | number | null
    stockOut?: IntNullableFilter<"Item"> | number | null
    productType?: StringNullableFilter<"Item"> | string | null
    pricingRules?: CustomerPricingRuleListRelationFilter
  }, "id" | "name">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    hsn?: SortOrderInput | SortOrder
    min?: SortOrderInput | SortOrder
    rate?: SortOrderInput | SortOrder
    tax?: SortOrderInput | SortOrder
    vendor?: SortOrderInput | SortOrder
    mrp?: SortOrderInput | SortOrder
    stockIn?: SortOrderInput | SortOrder
    stockHold?: SortOrderInput | SortOrder
    stockOut?: SortOrderInput | SortOrder
    productType?: SortOrderInput | SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Item"> | number
    name?: StringWithAggregatesFilter<"Item"> | string
    hsn?: IntNullableWithAggregatesFilter<"Item"> | number | null
    min?: IntNullableWithAggregatesFilter<"Item"> | number | null
    rate?: FloatNullableWithAggregatesFilter<"Item"> | number | null
    tax?: FloatNullableWithAggregatesFilter<"Item"> | number | null
    vendor?: StringNullableWithAggregatesFilter<"Item"> | string | null
    mrp?: DecimalNullableWithAggregatesFilter<"Item"> | Decimal | DecimalJsLike | number | string | null
    stockIn?: IntNullableWithAggregatesFilter<"Item"> | number | null
    stockHold?: IntNullableWithAggregatesFilter<"Item"> | number | null
    stockOut?: IntNullableWithAggregatesFilter<"Item"> | number | null
    productType?: StringNullableWithAggregatesFilter<"Item"> | string | null
  }

  export type inRegisterWhereInput = {
    AND?: inRegisterWhereInput | inRegisterWhereInput[]
    OR?: inRegisterWhereInput[]
    NOT?: inRegisterWhereInput | inRegisterWhereInput[]
    id?: IntFilter<"inRegister"> | number
    regNo?: IntFilter<"inRegister"> | number
    party?: StringNullableFilter<"inRegister"> | string | null
    item?: StringNullableFilter<"inRegister"> | string | null
    qty?: IntFilter<"inRegister"> | number
    department?: StringNullableFilter<"inRegister"> | string | null
    deptRef?: StringNullableFilter<"inRegister"> | string | null
    remark?: StringNullableFilter<"inRegister"> | string | null
    others?: StringNullableFilter<"inRegister"> | string | null
    courier?: StringNullableFilter<"inRegister"> | string | null
    complete?: StringNullableFilter<"inRegister"> | string | null
    date?: DateTimeFilter<"inRegister"> | Date | string
  }

  export type inRegisterOrderByWithRelationInput = {
    id?: SortOrder
    regNo?: SortOrder
    party?: SortOrderInput | SortOrder
    item?: SortOrderInput | SortOrder
    qty?: SortOrder
    department?: SortOrderInput | SortOrder
    deptRef?: SortOrderInput | SortOrder
    remark?: SortOrderInput | SortOrder
    others?: SortOrderInput | SortOrder
    courier?: SortOrderInput | SortOrder
    complete?: SortOrderInput | SortOrder
    date?: SortOrder
  }

  export type inRegisterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    regNo?: number
    AND?: inRegisterWhereInput | inRegisterWhereInput[]
    OR?: inRegisterWhereInput[]
    NOT?: inRegisterWhereInput | inRegisterWhereInput[]
    party?: StringNullableFilter<"inRegister"> | string | null
    item?: StringNullableFilter<"inRegister"> | string | null
    qty?: IntFilter<"inRegister"> | number
    department?: StringNullableFilter<"inRegister"> | string | null
    deptRef?: StringNullableFilter<"inRegister"> | string | null
    remark?: StringNullableFilter<"inRegister"> | string | null
    others?: StringNullableFilter<"inRegister"> | string | null
    courier?: StringNullableFilter<"inRegister"> | string | null
    complete?: StringNullableFilter<"inRegister"> | string | null
    date?: DateTimeFilter<"inRegister"> | Date | string
  }, "id" | "regNo">

  export type inRegisterOrderByWithAggregationInput = {
    id?: SortOrder
    regNo?: SortOrder
    party?: SortOrderInput | SortOrder
    item?: SortOrderInput | SortOrder
    qty?: SortOrder
    department?: SortOrderInput | SortOrder
    deptRef?: SortOrderInput | SortOrder
    remark?: SortOrderInput | SortOrder
    others?: SortOrderInput | SortOrder
    courier?: SortOrderInput | SortOrder
    complete?: SortOrderInput | SortOrder
    date?: SortOrder
    _count?: inRegisterCountOrderByAggregateInput
    _avg?: inRegisterAvgOrderByAggregateInput
    _max?: inRegisterMaxOrderByAggregateInput
    _min?: inRegisterMinOrderByAggregateInput
    _sum?: inRegisterSumOrderByAggregateInput
  }

  export type inRegisterScalarWhereWithAggregatesInput = {
    AND?: inRegisterScalarWhereWithAggregatesInput | inRegisterScalarWhereWithAggregatesInput[]
    OR?: inRegisterScalarWhereWithAggregatesInput[]
    NOT?: inRegisterScalarWhereWithAggregatesInput | inRegisterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"inRegister"> | number
    regNo?: IntWithAggregatesFilter<"inRegister"> | number
    party?: StringNullableWithAggregatesFilter<"inRegister"> | string | null
    item?: StringNullableWithAggregatesFilter<"inRegister"> | string | null
    qty?: IntWithAggregatesFilter<"inRegister"> | number
    department?: StringNullableWithAggregatesFilter<"inRegister"> | string | null
    deptRef?: StringNullableWithAggregatesFilter<"inRegister"> | string | null
    remark?: StringNullableWithAggregatesFilter<"inRegister"> | string | null
    others?: StringNullableWithAggregatesFilter<"inRegister"> | string | null
    courier?: StringNullableWithAggregatesFilter<"inRegister"> | string | null
    complete?: StringNullableWithAggregatesFilter<"inRegister"> | string | null
    date?: DateTimeWithAggregatesFilter<"inRegister"> | Date | string
  }

  export type saleEntryWhereInput = {
    AND?: saleEntryWhereInput | saleEntryWhereInput[]
    OR?: saleEntryWhereInput[]
    NOT?: saleEntryWhereInput | saleEntryWhereInput[]
    id?: IntFilter<"saleEntry"> | number
    date?: DateTimeFilter<"saleEntry"> | Date | string
    party_name?: StringFilter<"saleEntry"> | string
    invoice_number?: StringFilter<"saleEntry"> | string
    item_name?: StringFilter<"saleEntry"> | string
    quantity?: IntFilter<"saleEntry"> | number
    sell_rate?: DecimalFilter<"saleEntry"> | Decimal | DecimalJsLike | number | string
    profit?: DecimalNullableFilter<"saleEntry"> | Decimal | DecimalJsLike | number | string | null
  }

  export type saleEntryOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    party_name?: SortOrder
    invoice_number?: SortOrder
    item_name?: SortOrder
    quantity?: SortOrder
    sell_rate?: SortOrder
    profit?: SortOrderInput | SortOrder
  }

  export type saleEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: saleEntryWhereInput | saleEntryWhereInput[]
    OR?: saleEntryWhereInput[]
    NOT?: saleEntryWhereInput | saleEntryWhereInput[]
    date?: DateTimeFilter<"saleEntry"> | Date | string
    party_name?: StringFilter<"saleEntry"> | string
    invoice_number?: StringFilter<"saleEntry"> | string
    item_name?: StringFilter<"saleEntry"> | string
    quantity?: IntFilter<"saleEntry"> | number
    sell_rate?: DecimalFilter<"saleEntry"> | Decimal | DecimalJsLike | number | string
    profit?: DecimalNullableFilter<"saleEntry"> | Decimal | DecimalJsLike | number | string | null
  }, "id">

  export type saleEntryOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    party_name?: SortOrder
    invoice_number?: SortOrder
    item_name?: SortOrder
    quantity?: SortOrder
    sell_rate?: SortOrder
    profit?: SortOrderInput | SortOrder
    _count?: saleEntryCountOrderByAggregateInput
    _avg?: saleEntryAvgOrderByAggregateInput
    _max?: saleEntryMaxOrderByAggregateInput
    _min?: saleEntryMinOrderByAggregateInput
    _sum?: saleEntrySumOrderByAggregateInput
  }

  export type saleEntryScalarWhereWithAggregatesInput = {
    AND?: saleEntryScalarWhereWithAggregatesInput | saleEntryScalarWhereWithAggregatesInput[]
    OR?: saleEntryScalarWhereWithAggregatesInput[]
    NOT?: saleEntryScalarWhereWithAggregatesInput | saleEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"saleEntry"> | number
    date?: DateTimeWithAggregatesFilter<"saleEntry"> | Date | string
    party_name?: StringWithAggregatesFilter<"saleEntry"> | string
    invoice_number?: StringWithAggregatesFilter<"saleEntry"> | string
    item_name?: StringWithAggregatesFilter<"saleEntry"> | string
    quantity?: IntWithAggregatesFilter<"saleEntry"> | number
    sell_rate?: DecimalWithAggregatesFilter<"saleEntry"> | Decimal | DecimalJsLike | number | string
    profit?: DecimalNullableWithAggregatesFilter<"saleEntry"> | Decimal | DecimalJsLike | number | string | null
  }

  export type SalesByItemWhereInput = {
    AND?: SalesByItemWhereInput | SalesByItemWhereInput[]
    OR?: SalesByItemWhereInput[]
    NOT?: SalesByItemWhereInput | SalesByItemWhereInput[]
    id?: IntFilter<"SalesByItem"> | number
    date?: DateTimeFilter<"SalesByItem"> | Date | string
    itemname?: StringFilter<"SalesByItem"> | string
    qty?: IntFilter<"SalesByItem"> | number
  }

  export type SalesByItemOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    itemname?: SortOrder
    qty?: SortOrder
  }

  export type SalesByItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SalesByItemWhereInput | SalesByItemWhereInput[]
    OR?: SalesByItemWhereInput[]
    NOT?: SalesByItemWhereInput | SalesByItemWhereInput[]
    date?: DateTimeFilter<"SalesByItem"> | Date | string
    itemname?: StringFilter<"SalesByItem"> | string
    qty?: IntFilter<"SalesByItem"> | number
  }, "id">

  export type SalesByItemOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    itemname?: SortOrder
    qty?: SortOrder
    _count?: SalesByItemCountOrderByAggregateInput
    _avg?: SalesByItemAvgOrderByAggregateInput
    _max?: SalesByItemMaxOrderByAggregateInput
    _min?: SalesByItemMinOrderByAggregateInput
    _sum?: SalesByItemSumOrderByAggregateInput
  }

  export type SalesByItemScalarWhereWithAggregatesInput = {
    AND?: SalesByItemScalarWhereWithAggregatesInput | SalesByItemScalarWhereWithAggregatesInput[]
    OR?: SalesByItemScalarWhereWithAggregatesInput[]
    NOT?: SalesByItemScalarWhereWithAggregatesInput | SalesByItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalesByItem"> | number
    date?: DateTimeWithAggregatesFilter<"SalesByItem"> | Date | string
    itemname?: StringWithAggregatesFilter<"SalesByItem"> | string
    qty?: IntWithAggregatesFilter<"SalesByItem"> | number
  }

  export type SaleData2425WhereInput = {
    AND?: SaleData2425WhereInput | SaleData2425WhereInput[]
    OR?: SaleData2425WhereInput[]
    NOT?: SaleData2425WhereInput | SaleData2425WhereInput[]
    party_name?: StringNullableFilter<"SaleData2425"> | string | null
    invoice_date?: DateTimeNullableFilter<"SaleData2425"> | Date | string | null
    invoice_no?: StringNullableFilter<"SaleData2425"> | string | null
    item_name?: StringNullableFilter<"SaleData2425"> | string | null
    quantity?: IntNullableFilter<"SaleData2425"> | number | null
    rate?: DecimalNullableFilter<"SaleData2425"> | Decimal | DecimalJsLike | number | string | null
    uid?: StringNullableFilter<"SaleData2425"> | string | null
    id?: UuidFilter<"SaleData2425"> | string
  }

  export type SaleData2425OrderByWithRelationInput = {
    party_name?: SortOrderInput | SortOrder
    invoice_date?: SortOrderInput | SortOrder
    invoice_no?: SortOrderInput | SortOrder
    item_name?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    rate?: SortOrderInput | SortOrder
    uid?: SortOrderInput | SortOrder
    id?: SortOrder
  }

  export type SaleData2425WhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleData2425WhereInput | SaleData2425WhereInput[]
    OR?: SaleData2425WhereInput[]
    NOT?: SaleData2425WhereInput | SaleData2425WhereInput[]
    party_name?: StringNullableFilter<"SaleData2425"> | string | null
    invoice_date?: DateTimeNullableFilter<"SaleData2425"> | Date | string | null
    invoice_no?: StringNullableFilter<"SaleData2425"> | string | null
    item_name?: StringNullableFilter<"SaleData2425"> | string | null
    quantity?: IntNullableFilter<"SaleData2425"> | number | null
    rate?: DecimalNullableFilter<"SaleData2425"> | Decimal | DecimalJsLike | number | string | null
    uid?: StringNullableFilter<"SaleData2425"> | string | null
  }, "id">

  export type SaleData2425OrderByWithAggregationInput = {
    party_name?: SortOrderInput | SortOrder
    invoice_date?: SortOrderInput | SortOrder
    invoice_no?: SortOrderInput | SortOrder
    item_name?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    rate?: SortOrderInput | SortOrder
    uid?: SortOrderInput | SortOrder
    id?: SortOrder
    _count?: SaleData2425CountOrderByAggregateInput
    _avg?: SaleData2425AvgOrderByAggregateInput
    _max?: SaleData2425MaxOrderByAggregateInput
    _min?: SaleData2425MinOrderByAggregateInput
    _sum?: SaleData2425SumOrderByAggregateInput
  }

  export type SaleData2425ScalarWhereWithAggregatesInput = {
    AND?: SaleData2425ScalarWhereWithAggregatesInput | SaleData2425ScalarWhereWithAggregatesInput[]
    OR?: SaleData2425ScalarWhereWithAggregatesInput[]
    NOT?: SaleData2425ScalarWhereWithAggregatesInput | SaleData2425ScalarWhereWithAggregatesInput[]
    party_name?: StringNullableWithAggregatesFilter<"SaleData2425"> | string | null
    invoice_date?: DateTimeNullableWithAggregatesFilter<"SaleData2425"> | Date | string | null
    invoice_no?: StringNullableWithAggregatesFilter<"SaleData2425"> | string | null
    item_name?: StringNullableWithAggregatesFilter<"SaleData2425"> | string | null
    quantity?: IntNullableWithAggregatesFilter<"SaleData2425"> | number | null
    rate?: DecimalNullableWithAggregatesFilter<"SaleData2425"> | Decimal | DecimalJsLike | number | string | null
    uid?: StringNullableWithAggregatesFilter<"SaleData2425"> | string | null
    id?: UuidWithAggregatesFilter<"SaleData2425"> | string
  }

  export type StockItemWhereInput = {
    AND?: StockItemWhereInput | StockItemWhereInput[]
    OR?: StockItemWhereInput[]
    NOT?: StockItemWhereInput | StockItemWhereInput[]
    id?: IntFilter<"StockItem"> | number
    uid?: StringFilter<"StockItem"> | string
    name?: StringFilter<"StockItem"> | string
    hsncode?: StringNullableFilter<"StockItem"> | string | null
    buyingprice?: FloatFilter<"StockItem"> | number
    supplier?: StringNullableFilter<"StockItem"> | string | null
    tax?: FloatNullableFilter<"StockItem"> | number | null
    stock?: IntFilter<"StockItem"> | number
    productBatches?: ProductBatchListRelationFilter
    permanentItem?: XOR<PermanentItemNullableScalarRelationFilter, PermanentItemWhereInput> | null
  }

  export type StockItemOrderByWithRelationInput = {
    id?: SortOrder
    uid?: SortOrder
    name?: SortOrder
    hsncode?: SortOrderInput | SortOrder
    buyingprice?: SortOrder
    supplier?: SortOrderInput | SortOrder
    tax?: SortOrderInput | SortOrder
    stock?: SortOrder
    productBatches?: ProductBatchOrderByRelationAggregateInput
    permanentItem?: PermanentItemOrderByWithRelationInput
  }

  export type StockItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uid?: string
    AND?: StockItemWhereInput | StockItemWhereInput[]
    OR?: StockItemWhereInput[]
    NOT?: StockItemWhereInput | StockItemWhereInput[]
    name?: StringFilter<"StockItem"> | string
    hsncode?: StringNullableFilter<"StockItem"> | string | null
    buyingprice?: FloatFilter<"StockItem"> | number
    supplier?: StringNullableFilter<"StockItem"> | string | null
    tax?: FloatNullableFilter<"StockItem"> | number | null
    stock?: IntFilter<"StockItem"> | number
    productBatches?: ProductBatchListRelationFilter
    permanentItem?: XOR<PermanentItemNullableScalarRelationFilter, PermanentItemWhereInput> | null
  }, "id" | "uid">

  export type StockItemOrderByWithAggregationInput = {
    id?: SortOrder
    uid?: SortOrder
    name?: SortOrder
    hsncode?: SortOrderInput | SortOrder
    buyingprice?: SortOrder
    supplier?: SortOrderInput | SortOrder
    tax?: SortOrderInput | SortOrder
    stock?: SortOrder
    _count?: StockItemCountOrderByAggregateInput
    _avg?: StockItemAvgOrderByAggregateInput
    _max?: StockItemMaxOrderByAggregateInput
    _min?: StockItemMinOrderByAggregateInput
    _sum?: StockItemSumOrderByAggregateInput
  }

  export type StockItemScalarWhereWithAggregatesInput = {
    AND?: StockItemScalarWhereWithAggregatesInput | StockItemScalarWhereWithAggregatesInput[]
    OR?: StockItemScalarWhereWithAggregatesInput[]
    NOT?: StockItemScalarWhereWithAggregatesInput | StockItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StockItem"> | number
    uid?: StringWithAggregatesFilter<"StockItem"> | string
    name?: StringWithAggregatesFilter<"StockItem"> | string
    hsncode?: StringNullableWithAggregatesFilter<"StockItem"> | string | null
    buyingprice?: FloatWithAggregatesFilter<"StockItem"> | number
    supplier?: StringNullableWithAggregatesFilter<"StockItem"> | string | null
    tax?: FloatNullableWithAggregatesFilter<"StockItem"> | number | null
    stock?: IntWithAggregatesFilter<"StockItem"> | number
  }

  export type PermanentItemWhereInput = {
    AND?: PermanentItemWhereInput | PermanentItemWhereInput[]
    OR?: PermanentItemWhereInput[]
    NOT?: PermanentItemWhereInput | PermanentItemWhereInput[]
    id?: IntFilter<"PermanentItem"> | number
    uid?: StringFilter<"PermanentItem"> | string
    name?: StringNullableFilter<"PermanentItem"> | string | null
    reorder_level?: IntNullableFilter<"PermanentItem"> | number | null
    product_note?: StringNullableFilter<"PermanentItem"> | string | null
    supplier?: StringNullableFilter<"PermanentItem"> | string | null
    udrl?: StringNullableFilter<"PermanentItem"> | string | null
    stockItem?: XOR<StockItemScalarRelationFilter, StockItemWhereInput>
  }

  export type PermanentItemOrderByWithRelationInput = {
    id?: SortOrder
    uid?: SortOrder
    name?: SortOrderInput | SortOrder
    reorder_level?: SortOrderInput | SortOrder
    product_note?: SortOrderInput | SortOrder
    supplier?: SortOrderInput | SortOrder
    udrl?: SortOrderInput | SortOrder
    stockItem?: StockItemOrderByWithRelationInput
  }

  export type PermanentItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uid?: string
    AND?: PermanentItemWhereInput | PermanentItemWhereInput[]
    OR?: PermanentItemWhereInput[]
    NOT?: PermanentItemWhereInput | PermanentItemWhereInput[]
    name?: StringNullableFilter<"PermanentItem"> | string | null
    reorder_level?: IntNullableFilter<"PermanentItem"> | number | null
    product_note?: StringNullableFilter<"PermanentItem"> | string | null
    supplier?: StringNullableFilter<"PermanentItem"> | string | null
    udrl?: StringNullableFilter<"PermanentItem"> | string | null
    stockItem?: XOR<StockItemScalarRelationFilter, StockItemWhereInput>
  }, "id" | "uid">

  export type PermanentItemOrderByWithAggregationInput = {
    id?: SortOrder
    uid?: SortOrder
    name?: SortOrderInput | SortOrder
    reorder_level?: SortOrderInput | SortOrder
    product_note?: SortOrderInput | SortOrder
    supplier?: SortOrderInput | SortOrder
    udrl?: SortOrderInput | SortOrder
    _count?: PermanentItemCountOrderByAggregateInput
    _avg?: PermanentItemAvgOrderByAggregateInput
    _max?: PermanentItemMaxOrderByAggregateInput
    _min?: PermanentItemMinOrderByAggregateInput
    _sum?: PermanentItemSumOrderByAggregateInput
  }

  export type PermanentItemScalarWhereWithAggregatesInput = {
    AND?: PermanentItemScalarWhereWithAggregatesInput | PermanentItemScalarWhereWithAggregatesInput[]
    OR?: PermanentItemScalarWhereWithAggregatesInput[]
    NOT?: PermanentItemScalarWhereWithAggregatesInput | PermanentItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PermanentItem"> | number
    uid?: StringWithAggregatesFilter<"PermanentItem"> | string
    name?: StringNullableWithAggregatesFilter<"PermanentItem"> | string | null
    reorder_level?: IntNullableWithAggregatesFilter<"PermanentItem"> | number | null
    product_note?: StringNullableWithAggregatesFilter<"PermanentItem"> | string | null
    supplier?: StringNullableWithAggregatesFilter<"PermanentItem"> | string | null
    udrl?: StringNullableWithAggregatesFilter<"PermanentItem"> | string | null
  }

  export type saleTempEntryWhereInput = {
    AND?: saleTempEntryWhereInput | saleTempEntryWhereInput[]
    OR?: saleTempEntryWhereInput[]
    NOT?: saleTempEntryWhereInput | saleTempEntryWhereInput[]
    id?: IntFilter<"saleTempEntry"> | number
    partyname?: StringNullableFilter<"saleTempEntry"> | string | null
    invcdt?: DateTimeNullableFilter<"saleTempEntry"> | Date | string | null
    itemName?: StringNullableFilter<"saleTempEntry"> | string | null
    disc?: StringNullableFilter<"saleTempEntry"> | string | null
    qty?: FloatNullableFilter<"saleTempEntry"> | number | null
    rate?: FloatNullableFilter<"saleTempEntry"> | number | null
    shpAdd?: StringNullableFilter<"saleTempEntry"> | string | null
  }

  export type saleTempEntryOrderByWithRelationInput = {
    id?: SortOrder
    partyname?: SortOrderInput | SortOrder
    invcdt?: SortOrderInput | SortOrder
    itemName?: SortOrderInput | SortOrder
    disc?: SortOrderInput | SortOrder
    qty?: SortOrderInput | SortOrder
    rate?: SortOrderInput | SortOrder
    shpAdd?: SortOrderInput | SortOrder
  }

  export type saleTempEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: saleTempEntryWhereInput | saleTempEntryWhereInput[]
    OR?: saleTempEntryWhereInput[]
    NOT?: saleTempEntryWhereInput | saleTempEntryWhereInput[]
    partyname?: StringNullableFilter<"saleTempEntry"> | string | null
    invcdt?: DateTimeNullableFilter<"saleTempEntry"> | Date | string | null
    itemName?: StringNullableFilter<"saleTempEntry"> | string | null
    disc?: StringNullableFilter<"saleTempEntry"> | string | null
    qty?: FloatNullableFilter<"saleTempEntry"> | number | null
    rate?: FloatNullableFilter<"saleTempEntry"> | number | null
    shpAdd?: StringNullableFilter<"saleTempEntry"> | string | null
  }, "id">

  export type saleTempEntryOrderByWithAggregationInput = {
    id?: SortOrder
    partyname?: SortOrderInput | SortOrder
    invcdt?: SortOrderInput | SortOrder
    itemName?: SortOrderInput | SortOrder
    disc?: SortOrderInput | SortOrder
    qty?: SortOrderInput | SortOrder
    rate?: SortOrderInput | SortOrder
    shpAdd?: SortOrderInput | SortOrder
    _count?: saleTempEntryCountOrderByAggregateInput
    _avg?: saleTempEntryAvgOrderByAggregateInput
    _max?: saleTempEntryMaxOrderByAggregateInput
    _min?: saleTempEntryMinOrderByAggregateInput
    _sum?: saleTempEntrySumOrderByAggregateInput
  }

  export type saleTempEntryScalarWhereWithAggregatesInput = {
    AND?: saleTempEntryScalarWhereWithAggregatesInput | saleTempEntryScalarWhereWithAggregatesInput[]
    OR?: saleTempEntryScalarWhereWithAggregatesInput[]
    NOT?: saleTempEntryScalarWhereWithAggregatesInput | saleTempEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"saleTempEntry"> | number
    partyname?: StringNullableWithAggregatesFilter<"saleTempEntry"> | string | null
    invcdt?: DateTimeNullableWithAggregatesFilter<"saleTempEntry"> | Date | string | null
    itemName?: StringNullableWithAggregatesFilter<"saleTempEntry"> | string | null
    disc?: StringNullableWithAggregatesFilter<"saleTempEntry"> | string | null
    qty?: FloatNullableWithAggregatesFilter<"saleTempEntry"> | number | null
    rate?: FloatNullableWithAggregatesFilter<"saleTempEntry"> | number | null
    shpAdd?: StringNullableWithAggregatesFilter<"saleTempEntry"> | string | null
  }

  export type CustomerPricingRuleWhereInput = {
    AND?: CustomerPricingRuleWhereInput | CustomerPricingRuleWhereInput[]
    OR?: CustomerPricingRuleWhereInput[]
    NOT?: CustomerPricingRuleWhereInput | CustomerPricingRuleWhereInput[]
    id?: IntFilter<"CustomerPricingRule"> | number
    party_id?: IntFilter<"CustomerPricingRule"> | number
    item_id?: IntFilter<"CustomerPricingRule"> | number
    min_qty?: IntNullableFilter<"CustomerPricingRule"> | number | null
    fixed_price?: DecimalFilter<"CustomerPricingRule"> | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFilter<"CustomerPricingRule"> | Date | string
    effective_to?: DateTimeNullableFilter<"CustomerPricingRule"> | Date | string | null
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    party?: XOR<PartyScalarRelationFilter, PartyWhereInput>
  }

  export type CustomerPricingRuleOrderByWithRelationInput = {
    id?: SortOrder
    party_id?: SortOrder
    item_id?: SortOrder
    min_qty?: SortOrderInput | SortOrder
    fixed_price?: SortOrder
    effective_from?: SortOrder
    effective_to?: SortOrderInput | SortOrder
    item?: ItemOrderByWithRelationInput
    party?: PartyOrderByWithRelationInput
  }

  export type CustomerPricingRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    party_id_item_id_min_qty?: CustomerPricingRuleParty_idItem_idMin_qtyCompoundUniqueInput
    AND?: CustomerPricingRuleWhereInput | CustomerPricingRuleWhereInput[]
    OR?: CustomerPricingRuleWhereInput[]
    NOT?: CustomerPricingRuleWhereInput | CustomerPricingRuleWhereInput[]
    party_id?: IntFilter<"CustomerPricingRule"> | number
    item_id?: IntFilter<"CustomerPricingRule"> | number
    min_qty?: IntNullableFilter<"CustomerPricingRule"> | number | null
    fixed_price?: DecimalFilter<"CustomerPricingRule"> | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFilter<"CustomerPricingRule"> | Date | string
    effective_to?: DateTimeNullableFilter<"CustomerPricingRule"> | Date | string | null
    item?: XOR<ItemScalarRelationFilter, ItemWhereInput>
    party?: XOR<PartyScalarRelationFilter, PartyWhereInput>
  }, "id" | "party_id_item_id_min_qty">

  export type CustomerPricingRuleOrderByWithAggregationInput = {
    id?: SortOrder
    party_id?: SortOrder
    item_id?: SortOrder
    min_qty?: SortOrderInput | SortOrder
    fixed_price?: SortOrder
    effective_from?: SortOrder
    effective_to?: SortOrderInput | SortOrder
    _count?: CustomerPricingRuleCountOrderByAggregateInput
    _avg?: CustomerPricingRuleAvgOrderByAggregateInput
    _max?: CustomerPricingRuleMaxOrderByAggregateInput
    _min?: CustomerPricingRuleMinOrderByAggregateInput
    _sum?: CustomerPricingRuleSumOrderByAggregateInput
  }

  export type CustomerPricingRuleScalarWhereWithAggregatesInput = {
    AND?: CustomerPricingRuleScalarWhereWithAggregatesInput | CustomerPricingRuleScalarWhereWithAggregatesInput[]
    OR?: CustomerPricingRuleScalarWhereWithAggregatesInput[]
    NOT?: CustomerPricingRuleScalarWhereWithAggregatesInput | CustomerPricingRuleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CustomerPricingRule"> | number
    party_id?: IntWithAggregatesFilter<"CustomerPricingRule"> | number
    item_id?: IntWithAggregatesFilter<"CustomerPricingRule"> | number
    min_qty?: IntNullableWithAggregatesFilter<"CustomerPricingRule"> | number | null
    fixed_price?: DecimalWithAggregatesFilter<"CustomerPricingRule"> | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeWithAggregatesFilter<"CustomerPricingRule"> | Date | string
    effective_to?: DateTimeNullableWithAggregatesFilter<"CustomerPricingRule"> | Date | string | null
  }

  export type ProductBatchWhereInput = {
    AND?: ProductBatchWhereInput | ProductBatchWhereInput[]
    OR?: ProductBatchWhereInput[]
    NOT?: ProductBatchWhereInput | ProductBatchWhereInput[]
    id?: IntFilter<"ProductBatch"> | number
    stockitemId?: IntFilter<"ProductBatch"> | number
    batchNo?: StringFilter<"ProductBatch"> | string
    serialNo?: StringNullableFilter<"ProductBatch"> | string | null
    expiryDate?: DateTimeNullableFilter<"ProductBatch"> | Date | string | null
    mfgDate?: DateTimeNullableFilter<"ProductBatch"> | Date | string | null
    quantity?: IntFilter<"ProductBatch"> | number
    createdAt?: DateTimeFilter<"ProductBatch"> | Date | string
    stockItem?: XOR<StockItemScalarRelationFilter, StockItemWhereInput>
  }

  export type ProductBatchOrderByWithRelationInput = {
    id?: SortOrder
    stockitemId?: SortOrder
    batchNo?: SortOrder
    serialNo?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    mfgDate?: SortOrderInput | SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    stockItem?: StockItemOrderByWithRelationInput
  }

  export type ProductBatchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    stockitemId_serialNo?: ProductBatchStockitemIdSerialNoCompoundUniqueInput
    stockitemId_batchNo?: ProductBatchStockitemIdBatchNoCompoundUniqueInput
    AND?: ProductBatchWhereInput | ProductBatchWhereInput[]
    OR?: ProductBatchWhereInput[]
    NOT?: ProductBatchWhereInput | ProductBatchWhereInput[]
    stockitemId?: IntFilter<"ProductBatch"> | number
    batchNo?: StringFilter<"ProductBatch"> | string
    serialNo?: StringNullableFilter<"ProductBatch"> | string | null
    expiryDate?: DateTimeNullableFilter<"ProductBatch"> | Date | string | null
    mfgDate?: DateTimeNullableFilter<"ProductBatch"> | Date | string | null
    quantity?: IntFilter<"ProductBatch"> | number
    createdAt?: DateTimeFilter<"ProductBatch"> | Date | string
    stockItem?: XOR<StockItemScalarRelationFilter, StockItemWhereInput>
  }, "id" | "stockitemId_serialNo" | "stockitemId_batchNo">

  export type ProductBatchOrderByWithAggregationInput = {
    id?: SortOrder
    stockitemId?: SortOrder
    batchNo?: SortOrder
    serialNo?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    mfgDate?: SortOrderInput | SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    _count?: ProductBatchCountOrderByAggregateInput
    _avg?: ProductBatchAvgOrderByAggregateInput
    _max?: ProductBatchMaxOrderByAggregateInput
    _min?: ProductBatchMinOrderByAggregateInput
    _sum?: ProductBatchSumOrderByAggregateInput
  }

  export type ProductBatchScalarWhereWithAggregatesInput = {
    AND?: ProductBatchScalarWhereWithAggregatesInput | ProductBatchScalarWhereWithAggregatesInput[]
    OR?: ProductBatchScalarWhereWithAggregatesInput[]
    NOT?: ProductBatchScalarWhereWithAggregatesInput | ProductBatchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProductBatch"> | number
    stockitemId?: IntWithAggregatesFilter<"ProductBatch"> | number
    batchNo?: StringWithAggregatesFilter<"ProductBatch"> | string
    serialNo?: StringNullableWithAggregatesFilter<"ProductBatch"> | string | null
    expiryDate?: DateTimeNullableWithAggregatesFilter<"ProductBatch"> | Date | string | null
    mfgDate?: DateTimeNullableWithAggregatesFilter<"ProductBatch"> | Date | string | null
    quantity?: IntWithAggregatesFilter<"ProductBatch"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProductBatch"> | Date | string
  }

  export type PurchaseEntryWhereInput = {
    AND?: PurchaseEntryWhereInput | PurchaseEntryWhereInput[]
    OR?: PurchaseEntryWhereInput[]
    NOT?: PurchaseEntryWhereInput | PurchaseEntryWhereInput[]
    id?: IntFilter<"PurchaseEntry"> | number
    date?: DateTimeFilter<"PurchaseEntry"> | Date | string
    partyName?: StringFilter<"PurchaseEntry"> | string
    purchaseNumber?: StringFilter<"PurchaseEntry"> | string
    itemName?: StringFilter<"PurchaseEntry"> | string
    quantity?: IntFilter<"PurchaseEntry"> | number
    purchaseRate?: DecimalFilter<"PurchaseEntry"> | Decimal | DecimalJsLike | number | string
    purchaseReferenceNumber?: StringNullableFilter<"PurchaseEntry"> | string | null
  }

  export type PurchaseEntryOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    partyName?: SortOrder
    purchaseNumber?: SortOrder
    itemName?: SortOrder
    quantity?: SortOrder
    purchaseRate?: SortOrder
    purchaseReferenceNumber?: SortOrderInput | SortOrder
  }

  export type PurchaseEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PurchaseEntryWhereInput | PurchaseEntryWhereInput[]
    OR?: PurchaseEntryWhereInput[]
    NOT?: PurchaseEntryWhereInput | PurchaseEntryWhereInput[]
    date?: DateTimeFilter<"PurchaseEntry"> | Date | string
    partyName?: StringFilter<"PurchaseEntry"> | string
    purchaseNumber?: StringFilter<"PurchaseEntry"> | string
    itemName?: StringFilter<"PurchaseEntry"> | string
    quantity?: IntFilter<"PurchaseEntry"> | number
    purchaseRate?: DecimalFilter<"PurchaseEntry"> | Decimal | DecimalJsLike | number | string
    purchaseReferenceNumber?: StringNullableFilter<"PurchaseEntry"> | string | null
  }, "id">

  export type PurchaseEntryOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    partyName?: SortOrder
    purchaseNumber?: SortOrder
    itemName?: SortOrder
    quantity?: SortOrder
    purchaseRate?: SortOrder
    purchaseReferenceNumber?: SortOrderInput | SortOrder
    _count?: PurchaseEntryCountOrderByAggregateInput
    _avg?: PurchaseEntryAvgOrderByAggregateInput
    _max?: PurchaseEntryMaxOrderByAggregateInput
    _min?: PurchaseEntryMinOrderByAggregateInput
    _sum?: PurchaseEntrySumOrderByAggregateInput
  }

  export type PurchaseEntryScalarWhereWithAggregatesInput = {
    AND?: PurchaseEntryScalarWhereWithAggregatesInput | PurchaseEntryScalarWhereWithAggregatesInput[]
    OR?: PurchaseEntryScalarWhereWithAggregatesInput[]
    NOT?: PurchaseEntryScalarWhereWithAggregatesInput | PurchaseEntryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchaseEntry"> | number
    date?: DateTimeWithAggregatesFilter<"PurchaseEntry"> | Date | string
    partyName?: StringWithAggregatesFilter<"PurchaseEntry"> | string
    purchaseNumber?: StringWithAggregatesFilter<"PurchaseEntry"> | string
    itemName?: StringWithAggregatesFilter<"PurchaseEntry"> | string
    quantity?: IntWithAggregatesFilter<"PurchaseEntry"> | number
    purchaseRate?: DecimalWithAggregatesFilter<"PurchaseEntry"> | Decimal | DecimalJsLike | number | string
    purchaseReferenceNumber?: StringNullableWithAggregatesFilter<"PurchaseEntry"> | string | null
  }

  export type PartyCreateInput = {
    name: string
    address?: string | null
    code?: number | null
    contact?: string | null
    credit?: number | null
    dlno?: string | null
    gst?: string | null
    state?: string | null
    type?: string | null
    shipping_address?: string | null
    credit_period?: string | null
    pricingRules?: CustomerPricingRuleCreateNestedManyWithoutPartyInput
  }

  export type PartyUncheckedCreateInput = {
    id?: number
    name: string
    address?: string | null
    code?: number | null
    contact?: string | null
    credit?: number | null
    dlno?: string | null
    gst?: string | null
    state?: string | null
    type?: string | null
    shipping_address?: string | null
    credit_period?: string | null
    pricingRules?: CustomerPricingRuleUncheckedCreateNestedManyWithoutPartyInput
  }

  export type PartyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableIntFieldUpdateOperationsInput | number | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: NullableFloatFieldUpdateOperationsInput | number | null
    dlno?: NullableStringFieldUpdateOperationsInput | string | null
    gst?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address?: NullableStringFieldUpdateOperationsInput | string | null
    credit_period?: NullableStringFieldUpdateOperationsInput | string | null
    pricingRules?: CustomerPricingRuleUpdateManyWithoutPartyNestedInput
  }

  export type PartyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableIntFieldUpdateOperationsInput | number | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: NullableFloatFieldUpdateOperationsInput | number | null
    dlno?: NullableStringFieldUpdateOperationsInput | string | null
    gst?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address?: NullableStringFieldUpdateOperationsInput | string | null
    credit_period?: NullableStringFieldUpdateOperationsInput | string | null
    pricingRules?: CustomerPricingRuleUncheckedUpdateManyWithoutPartyNestedInput
  }

  export type PartyCreateManyInput = {
    id?: number
    name: string
    address?: string | null
    code?: number | null
    contact?: string | null
    credit?: number | null
    dlno?: string | null
    gst?: string | null
    state?: string | null
    type?: string | null
    shipping_address?: string | null
    credit_period?: string | null
  }

  export type PartyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableIntFieldUpdateOperationsInput | number | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: NullableFloatFieldUpdateOperationsInput | number | null
    dlno?: NullableStringFieldUpdateOperationsInput | string | null
    gst?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address?: NullableStringFieldUpdateOperationsInput | string | null
    credit_period?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PartyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableIntFieldUpdateOperationsInput | number | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: NullableFloatFieldUpdateOperationsInput | number | null
    dlno?: NullableStringFieldUpdateOperationsInput | string | null
    gst?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address?: NullableStringFieldUpdateOperationsInput | string | null
    credit_period?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourierCreateInput = {
    name: string
  }

  export type CourierUncheckedCreateInput = {
    id?: number
    name: string
  }

  export type CourierUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CourierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CourierCreateManyInput = {
    id?: number
    name: string
  }

  export type CourierUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CourierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DepartmentCreateInput = {
    name: string
  }

  export type DepartmentUncheckedCreateInput = {
    id?: number
    name: string
  }

  export type DepartmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DepartmentCreateManyInput = {
    id?: number
    name: string
  }

  export type DepartmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCreateInput = {
    name: string
    hsn?: number | null
    min?: number | null
    rate?: number | null
    tax?: number | null
    vendor?: string | null
    mrp?: Decimal | DecimalJsLike | number | string | null
    stockIn?: number | null
    stockHold?: number | null
    stockOut?: number | null
    productType?: string | null
    pricingRules?: CustomerPricingRuleCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateInput = {
    id?: number
    name: string
    hsn?: number | null
    min?: number | null
    rate?: number | null
    tax?: number | null
    vendor?: string | null
    mrp?: Decimal | DecimalJsLike | number | string | null
    stockIn?: number | null
    stockHold?: number | null
    stockOut?: number | null
    productType?: string | null
    pricingRules?: CustomerPricingRuleUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    hsn?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    mrp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stockIn?: NullableIntFieldUpdateOperationsInput | number | null
    stockHold?: NullableIntFieldUpdateOperationsInput | number | null
    stockOut?: NullableIntFieldUpdateOperationsInput | number | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    pricingRules?: CustomerPricingRuleUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    hsn?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    mrp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stockIn?: NullableIntFieldUpdateOperationsInput | number | null
    stockHold?: NullableIntFieldUpdateOperationsInput | number | null
    stockOut?: NullableIntFieldUpdateOperationsInput | number | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
    pricingRules?: CustomerPricingRuleUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyInput = {
    id?: number
    name: string
    hsn?: number | null
    min?: number | null
    rate?: number | null
    tax?: number | null
    vendor?: string | null
    mrp?: Decimal | DecimalJsLike | number | string | null
    stockIn?: number | null
    stockHold?: number | null
    stockOut?: number | null
    productType?: string | null
  }

  export type ItemUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    hsn?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    mrp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stockIn?: NullableIntFieldUpdateOperationsInput | number | null
    stockHold?: NullableIntFieldUpdateOperationsInput | number | null
    stockOut?: NullableIntFieldUpdateOperationsInput | number | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    hsn?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    mrp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stockIn?: NullableIntFieldUpdateOperationsInput | number | null
    stockHold?: NullableIntFieldUpdateOperationsInput | number | null
    stockOut?: NullableIntFieldUpdateOperationsInput | number | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inRegisterCreateInput = {
    regNo: number
    party?: string | null
    item?: string | null
    qty: number
    department?: string | null
    deptRef?: string | null
    remark?: string | null
    others?: string | null
    courier?: string | null
    complete?: string | null
    date: Date | string
  }

  export type inRegisterUncheckedCreateInput = {
    id?: number
    regNo: number
    party?: string | null
    item?: string | null
    qty: number
    department?: string | null
    deptRef?: string | null
    remark?: string | null
    others?: string | null
    courier?: string | null
    complete?: string | null
    date: Date | string
  }

  export type inRegisterUpdateInput = {
    regNo?: IntFieldUpdateOperationsInput | number
    party?: NullableStringFieldUpdateOperationsInput | string | null
    item?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    deptRef?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    others?: NullableStringFieldUpdateOperationsInput | string | null
    courier?: NullableStringFieldUpdateOperationsInput | string | null
    complete?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inRegisterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    regNo?: IntFieldUpdateOperationsInput | number
    party?: NullableStringFieldUpdateOperationsInput | string | null
    item?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    deptRef?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    others?: NullableStringFieldUpdateOperationsInput | string | null
    courier?: NullableStringFieldUpdateOperationsInput | string | null
    complete?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inRegisterCreateManyInput = {
    id?: number
    regNo: number
    party?: string | null
    item?: string | null
    qty: number
    department?: string | null
    deptRef?: string | null
    remark?: string | null
    others?: string | null
    courier?: string | null
    complete?: string | null
    date: Date | string
  }

  export type inRegisterUpdateManyMutationInput = {
    regNo?: IntFieldUpdateOperationsInput | number
    party?: NullableStringFieldUpdateOperationsInput | string | null
    item?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    deptRef?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    others?: NullableStringFieldUpdateOperationsInput | string | null
    courier?: NullableStringFieldUpdateOperationsInput | string | null
    complete?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inRegisterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    regNo?: IntFieldUpdateOperationsInput | number
    party?: NullableStringFieldUpdateOperationsInput | string | null
    item?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    deptRef?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    others?: NullableStringFieldUpdateOperationsInput | string | null
    courier?: NullableStringFieldUpdateOperationsInput | string | null
    complete?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type saleEntryCreateInput = {
    date: Date | string
    party_name: string
    invoice_number: string
    item_name: string
    quantity: number
    sell_rate: Decimal | DecimalJsLike | number | string
    profit?: Decimal | DecimalJsLike | number | string | null
  }

  export type saleEntryUncheckedCreateInput = {
    id?: number
    date: Date | string
    party_name: string
    invoice_number: string
    item_name: string
    quantity: number
    sell_rate: Decimal | DecimalJsLike | number | string
    profit?: Decimal | DecimalJsLike | number | string | null
  }

  export type saleEntryUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    party_name?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sell_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type saleEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    party_name?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sell_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type saleEntryCreateManyInput = {
    id?: number
    date: Date | string
    party_name: string
    invoice_number: string
    item_name: string
    quantity: number
    sell_rate: Decimal | DecimalJsLike | number | string
    profit?: Decimal | DecimalJsLike | number | string | null
  }

  export type saleEntryUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    party_name?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sell_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type saleEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    party_name?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    sell_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    profit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type SalesByItemCreateInput = {
    date: Date | string
    itemname: string
    qty: number
  }

  export type SalesByItemUncheckedCreateInput = {
    id?: number
    date: Date | string
    itemname: string
    qty: number
  }

  export type SalesByItemUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    itemname?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
  }

  export type SalesByItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    itemname?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
  }

  export type SalesByItemCreateManyInput = {
    id?: number
    date: Date | string
    itemname: string
    qty: number
  }

  export type SalesByItemUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    itemname?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
  }

  export type SalesByItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    itemname?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
  }

  export type SaleData2425CreateInput = {
    party_name?: string | null
    invoice_date?: Date | string | null
    invoice_no?: string | null
    item_name?: string | null
    quantity?: number | null
    rate?: Decimal | DecimalJsLike | number | string | null
    uid?: string | null
    id?: string
  }

  export type SaleData2425UncheckedCreateInput = {
    party_name?: string | null
    invoice_date?: Date | string | null
    invoice_no?: string | null
    item_name?: string | null
    quantity?: number | null
    rate?: Decimal | DecimalJsLike | number | string | null
    uid?: string | null
    id?: string
  }

  export type SaleData2425UpdateInput = {
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    uid?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
  }

  export type SaleData2425UncheckedUpdateInput = {
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    uid?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
  }

  export type SaleData2425CreateManyInput = {
    party_name?: string | null
    invoice_date?: Date | string | null
    invoice_no?: string | null
    item_name?: string | null
    quantity?: number | null
    rate?: Decimal | DecimalJsLike | number | string | null
    uid?: string | null
    id?: string
  }

  export type SaleData2425UpdateManyMutationInput = {
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    uid?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
  }

  export type SaleData2425UncheckedUpdateManyInput = {
    party_name?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoice_no?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    uid?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
  }

  export type StockItemCreateInput = {
    uid: string
    name: string
    hsncode?: string | null
    buyingprice: number
    supplier?: string | null
    tax?: number | null
    stock: number
    productBatches?: ProductBatchCreateNestedManyWithoutStockItemInput
    permanentItem?: PermanentItemCreateNestedOneWithoutStockItemInput
  }

  export type StockItemUncheckedCreateInput = {
    id?: number
    uid: string
    name: string
    hsncode?: string | null
    buyingprice: number
    supplier?: string | null
    tax?: number | null
    stock: number
    productBatches?: ProductBatchUncheckedCreateNestedManyWithoutStockItemInput
    permanentItem?: PermanentItemUncheckedCreateNestedOneWithoutStockItemInput
  }

  export type StockItemUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hsncode?: NullableStringFieldUpdateOperationsInput | string | null
    buyingprice?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    productBatches?: ProductBatchUpdateManyWithoutStockItemNestedInput
    permanentItem?: PermanentItemUpdateOneWithoutStockItemNestedInput
  }

  export type StockItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hsncode?: NullableStringFieldUpdateOperationsInput | string | null
    buyingprice?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    productBatches?: ProductBatchUncheckedUpdateManyWithoutStockItemNestedInput
    permanentItem?: PermanentItemUncheckedUpdateOneWithoutStockItemNestedInput
  }

  export type StockItemCreateManyInput = {
    id?: number
    uid: string
    name: string
    hsncode?: string | null
    buyingprice: number
    supplier?: string | null
    tax?: number | null
    stock: number
  }

  export type StockItemUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hsncode?: NullableStringFieldUpdateOperationsInput | string | null
    buyingprice?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
  }

  export type StockItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hsncode?: NullableStringFieldUpdateOperationsInput | string | null
    buyingprice?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
  }

  export type PermanentItemCreateInput = {
    name?: string | null
    reorder_level?: number | null
    product_note?: string | null
    supplier?: string | null
    udrl?: string | null
    stockItem: StockItemCreateNestedOneWithoutPermanentItemInput
  }

  export type PermanentItemUncheckedCreateInput = {
    id?: number
    uid: string
    name?: string | null
    reorder_level?: number | null
    product_note?: string | null
    supplier?: string | null
    udrl?: string | null
  }

  export type PermanentItemUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    reorder_level?: NullableIntFieldUpdateOperationsInput | number | null
    product_note?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    udrl?: NullableStringFieldUpdateOperationsInput | string | null
    stockItem?: StockItemUpdateOneRequiredWithoutPermanentItemNestedInput
  }

  export type PermanentItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    reorder_level?: NullableIntFieldUpdateOperationsInput | number | null
    product_note?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    udrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermanentItemCreateManyInput = {
    id?: number
    uid: string
    name?: string | null
    reorder_level?: number | null
    product_note?: string | null
    supplier?: string | null
    udrl?: string | null
  }

  export type PermanentItemUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    reorder_level?: NullableIntFieldUpdateOperationsInput | number | null
    product_note?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    udrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermanentItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    reorder_level?: NullableIntFieldUpdateOperationsInput | number | null
    product_note?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    udrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type saleTempEntryCreateInput = {
    partyname?: string | null
    invcdt?: Date | string | null
    itemName?: string | null
    disc?: string | null
    qty?: number | null
    rate?: number | null
    shpAdd?: string | null
  }

  export type saleTempEntryUncheckedCreateInput = {
    id?: number
    partyname?: string | null
    invcdt?: Date | string | null
    itemName?: string | null
    disc?: string | null
    qty?: number | null
    rate?: number | null
    shpAdd?: string | null
  }

  export type saleTempEntryUpdateInput = {
    partyname?: NullableStringFieldUpdateOperationsInput | string | null
    invcdt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    disc?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    shpAdd?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type saleTempEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    partyname?: NullableStringFieldUpdateOperationsInput | string | null
    invcdt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    disc?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    shpAdd?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type saleTempEntryCreateManyInput = {
    id?: number
    partyname?: string | null
    invcdt?: Date | string | null
    itemName?: string | null
    disc?: string | null
    qty?: number | null
    rate?: number | null
    shpAdd?: string | null
  }

  export type saleTempEntryUpdateManyMutationInput = {
    partyname?: NullableStringFieldUpdateOperationsInput | string | null
    invcdt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    disc?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    shpAdd?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type saleTempEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    partyname?: NullableStringFieldUpdateOperationsInput | string | null
    invcdt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    itemName?: NullableStringFieldUpdateOperationsInput | string | null
    disc?: NullableStringFieldUpdateOperationsInput | string | null
    qty?: NullableFloatFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    shpAdd?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerPricingRuleCreateInput = {
    min_qty?: number | null
    fixed_price: Decimal | DecimalJsLike | number | string
    effective_from?: Date | string
    effective_to?: Date | string | null
    item: ItemCreateNestedOneWithoutPricingRulesInput
    party: PartyCreateNestedOneWithoutPricingRulesInput
  }

  export type CustomerPricingRuleUncheckedCreateInput = {
    id?: number
    party_id: number
    item_id: number
    min_qty?: number | null
    fixed_price: Decimal | DecimalJsLike | number | string
    effective_from?: Date | string
    effective_to?: Date | string | null
  }

  export type CustomerPricingRuleUpdateInput = {
    min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFieldUpdateOperationsInput | Date | string
    effective_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item?: ItemUpdateOneRequiredWithoutPricingRulesNestedInput
    party?: PartyUpdateOneRequiredWithoutPricingRulesNestedInput
  }

  export type CustomerPricingRuleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    party_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFieldUpdateOperationsInput | Date | string
    effective_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerPricingRuleCreateManyInput = {
    id?: number
    party_id: number
    item_id: number
    min_qty?: number | null
    fixed_price: Decimal | DecimalJsLike | number | string
    effective_from?: Date | string
    effective_to?: Date | string | null
  }

  export type CustomerPricingRuleUpdateManyMutationInput = {
    min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFieldUpdateOperationsInput | Date | string
    effective_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerPricingRuleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    party_id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFieldUpdateOperationsInput | Date | string
    effective_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductBatchCreateInput = {
    batchNo: string
    serialNo?: string | null
    expiryDate?: Date | string | null
    mfgDate?: Date | string | null
    quantity: number
    createdAt?: Date | string
    stockItem: StockItemCreateNestedOneWithoutProductBatchesInput
  }

  export type ProductBatchUncheckedCreateInput = {
    id?: number
    stockitemId: number
    batchNo: string
    serialNo?: string | null
    expiryDate?: Date | string | null
    mfgDate?: Date | string | null
    quantity: number
    createdAt?: Date | string
  }

  export type ProductBatchUpdateInput = {
    batchNo?: StringFieldUpdateOperationsInput | string
    serialNo?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfgDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stockItem?: StockItemUpdateOneRequiredWithoutProductBatchesNestedInput
  }

  export type ProductBatchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    stockitemId?: IntFieldUpdateOperationsInput | number
    batchNo?: StringFieldUpdateOperationsInput | string
    serialNo?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfgDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductBatchCreateManyInput = {
    id?: number
    stockitemId: number
    batchNo: string
    serialNo?: string | null
    expiryDate?: Date | string | null
    mfgDate?: Date | string | null
    quantity: number
    createdAt?: Date | string
  }

  export type ProductBatchUpdateManyMutationInput = {
    batchNo?: StringFieldUpdateOperationsInput | string
    serialNo?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfgDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductBatchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    stockitemId?: IntFieldUpdateOperationsInput | number
    batchNo?: StringFieldUpdateOperationsInput | string
    serialNo?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfgDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseEntryCreateInput = {
    date: Date | string
    partyName: string
    purchaseNumber: string
    itemName: string
    quantity: number
    purchaseRate: Decimal | DecimalJsLike | number | string
    purchaseReferenceNumber?: string | null
  }

  export type PurchaseEntryUncheckedCreateInput = {
    id?: number
    date: Date | string
    partyName: string
    purchaseNumber: string
    itemName: string
    quantity: number
    purchaseRate: Decimal | DecimalJsLike | number | string
    purchaseReferenceNumber?: string | null
  }

  export type PurchaseEntryUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    partyName?: StringFieldUpdateOperationsInput | string
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    purchaseRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseReferenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseEntryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    partyName?: StringFieldUpdateOperationsInput | string
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    purchaseRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseReferenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseEntryCreateManyInput = {
    id?: number
    date: Date | string
    partyName: string
    purchaseNumber: string
    itemName: string
    quantity: number
    purchaseRate: Decimal | DecimalJsLike | number | string
    purchaseReferenceNumber?: string | null
  }

  export type PurchaseEntryUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    partyName?: StringFieldUpdateOperationsInput | string
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    purchaseRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseReferenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PurchaseEntryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    partyName?: StringFieldUpdateOperationsInput | string
    purchaseNumber?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    purchaseRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    purchaseReferenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CustomerPricingRuleListRelationFilter = {
    every?: CustomerPricingRuleWhereInput
    some?: CustomerPricingRuleWhereInput
    none?: CustomerPricingRuleWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CustomerPricingRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    code?: SortOrder
    contact?: SortOrder
    credit?: SortOrder
    dlno?: SortOrder
    gst?: SortOrder
    state?: SortOrder
    type?: SortOrder
    shipping_address?: SortOrder
    credit_period?: SortOrder
  }

  export type PartyAvgOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    credit?: SortOrder
  }

  export type PartyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    code?: SortOrder
    contact?: SortOrder
    credit?: SortOrder
    dlno?: SortOrder
    gst?: SortOrder
    state?: SortOrder
    type?: SortOrder
    shipping_address?: SortOrder
    credit_period?: SortOrder
  }

  export type PartyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    code?: SortOrder
    contact?: SortOrder
    credit?: SortOrder
    dlno?: SortOrder
    gst?: SortOrder
    state?: SortOrder
    type?: SortOrder
    shipping_address?: SortOrder
    credit_period?: SortOrder
  }

  export type PartySumOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    credit?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type CourierCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CourierAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CourierMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CourierMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CourierSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DepartmentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DepartmentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    hsn?: SortOrder
    min?: SortOrder
    rate?: SortOrder
    tax?: SortOrder
    vendor?: SortOrder
    mrp?: SortOrder
    stockIn?: SortOrder
    stockHold?: SortOrder
    stockOut?: SortOrder
    productType?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    id?: SortOrder
    hsn?: SortOrder
    min?: SortOrder
    rate?: SortOrder
    tax?: SortOrder
    mrp?: SortOrder
    stockIn?: SortOrder
    stockHold?: SortOrder
    stockOut?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    hsn?: SortOrder
    min?: SortOrder
    rate?: SortOrder
    tax?: SortOrder
    vendor?: SortOrder
    mrp?: SortOrder
    stockIn?: SortOrder
    stockHold?: SortOrder
    stockOut?: SortOrder
    productType?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    hsn?: SortOrder
    min?: SortOrder
    rate?: SortOrder
    tax?: SortOrder
    vendor?: SortOrder
    mrp?: SortOrder
    stockIn?: SortOrder
    stockHold?: SortOrder
    stockOut?: SortOrder
    productType?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    id?: SortOrder
    hsn?: SortOrder
    min?: SortOrder
    rate?: SortOrder
    tax?: SortOrder
    mrp?: SortOrder
    stockIn?: SortOrder
    stockHold?: SortOrder
    stockOut?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type inRegisterCountOrderByAggregateInput = {
    id?: SortOrder
    regNo?: SortOrder
    party?: SortOrder
    item?: SortOrder
    qty?: SortOrder
    department?: SortOrder
    deptRef?: SortOrder
    remark?: SortOrder
    others?: SortOrder
    courier?: SortOrder
    complete?: SortOrder
    date?: SortOrder
  }

  export type inRegisterAvgOrderByAggregateInput = {
    id?: SortOrder
    regNo?: SortOrder
    qty?: SortOrder
  }

  export type inRegisterMaxOrderByAggregateInput = {
    id?: SortOrder
    regNo?: SortOrder
    party?: SortOrder
    item?: SortOrder
    qty?: SortOrder
    department?: SortOrder
    deptRef?: SortOrder
    remark?: SortOrder
    others?: SortOrder
    courier?: SortOrder
    complete?: SortOrder
    date?: SortOrder
  }

  export type inRegisterMinOrderByAggregateInput = {
    id?: SortOrder
    regNo?: SortOrder
    party?: SortOrder
    item?: SortOrder
    qty?: SortOrder
    department?: SortOrder
    deptRef?: SortOrder
    remark?: SortOrder
    others?: SortOrder
    courier?: SortOrder
    complete?: SortOrder
    date?: SortOrder
  }

  export type inRegisterSumOrderByAggregateInput = {
    id?: SortOrder
    regNo?: SortOrder
    qty?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type saleEntryCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    party_name?: SortOrder
    invoice_number?: SortOrder
    item_name?: SortOrder
    quantity?: SortOrder
    sell_rate?: SortOrder
    profit?: SortOrder
  }

  export type saleEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    sell_rate?: SortOrder
    profit?: SortOrder
  }

  export type saleEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    party_name?: SortOrder
    invoice_number?: SortOrder
    item_name?: SortOrder
    quantity?: SortOrder
    sell_rate?: SortOrder
    profit?: SortOrder
  }

  export type saleEntryMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    party_name?: SortOrder
    invoice_number?: SortOrder
    item_name?: SortOrder
    quantity?: SortOrder
    sell_rate?: SortOrder
    profit?: SortOrder
  }

  export type saleEntrySumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    sell_rate?: SortOrder
    profit?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type SalesByItemCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    itemname?: SortOrder
    qty?: SortOrder
  }

  export type SalesByItemAvgOrderByAggregateInput = {
    id?: SortOrder
    qty?: SortOrder
  }

  export type SalesByItemMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    itemname?: SortOrder
    qty?: SortOrder
  }

  export type SalesByItemMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    itemname?: SortOrder
    qty?: SortOrder
  }

  export type SalesByItemSumOrderByAggregateInput = {
    id?: SortOrder
    qty?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type SaleData2425CountOrderByAggregateInput = {
    party_name?: SortOrder
    invoice_date?: SortOrder
    invoice_no?: SortOrder
    item_name?: SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    uid?: SortOrder
    id?: SortOrder
  }

  export type SaleData2425AvgOrderByAggregateInput = {
    quantity?: SortOrder
    rate?: SortOrder
  }

  export type SaleData2425MaxOrderByAggregateInput = {
    party_name?: SortOrder
    invoice_date?: SortOrder
    invoice_no?: SortOrder
    item_name?: SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    uid?: SortOrder
    id?: SortOrder
  }

  export type SaleData2425MinOrderByAggregateInput = {
    party_name?: SortOrder
    invoice_date?: SortOrder
    invoice_no?: SortOrder
    item_name?: SortOrder
    quantity?: SortOrder
    rate?: SortOrder
    uid?: SortOrder
    id?: SortOrder
  }

  export type SaleData2425SumOrderByAggregateInput = {
    quantity?: SortOrder
    rate?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ProductBatchListRelationFilter = {
    every?: ProductBatchWhereInput
    some?: ProductBatchWhereInput
    none?: ProductBatchWhereInput
  }

  export type PermanentItemNullableScalarRelationFilter = {
    is?: PermanentItemWhereInput | null
    isNot?: PermanentItemWhereInput | null
  }

  export type ProductBatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockItemCountOrderByAggregateInput = {
    id?: SortOrder
    uid?: SortOrder
    name?: SortOrder
    hsncode?: SortOrder
    buyingprice?: SortOrder
    supplier?: SortOrder
    tax?: SortOrder
    stock?: SortOrder
  }

  export type StockItemAvgOrderByAggregateInput = {
    id?: SortOrder
    buyingprice?: SortOrder
    tax?: SortOrder
    stock?: SortOrder
  }

  export type StockItemMaxOrderByAggregateInput = {
    id?: SortOrder
    uid?: SortOrder
    name?: SortOrder
    hsncode?: SortOrder
    buyingprice?: SortOrder
    supplier?: SortOrder
    tax?: SortOrder
    stock?: SortOrder
  }

  export type StockItemMinOrderByAggregateInput = {
    id?: SortOrder
    uid?: SortOrder
    name?: SortOrder
    hsncode?: SortOrder
    buyingprice?: SortOrder
    supplier?: SortOrder
    tax?: SortOrder
    stock?: SortOrder
  }

  export type StockItemSumOrderByAggregateInput = {
    id?: SortOrder
    buyingprice?: SortOrder
    tax?: SortOrder
    stock?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type StockItemScalarRelationFilter = {
    is?: StockItemWhereInput
    isNot?: StockItemWhereInput
  }

  export type PermanentItemCountOrderByAggregateInput = {
    id?: SortOrder
    uid?: SortOrder
    name?: SortOrder
    reorder_level?: SortOrder
    product_note?: SortOrder
    supplier?: SortOrder
    udrl?: SortOrder
  }

  export type PermanentItemAvgOrderByAggregateInput = {
    id?: SortOrder
    reorder_level?: SortOrder
  }

  export type PermanentItemMaxOrderByAggregateInput = {
    id?: SortOrder
    uid?: SortOrder
    name?: SortOrder
    reorder_level?: SortOrder
    product_note?: SortOrder
    supplier?: SortOrder
    udrl?: SortOrder
  }

  export type PermanentItemMinOrderByAggregateInput = {
    id?: SortOrder
    uid?: SortOrder
    name?: SortOrder
    reorder_level?: SortOrder
    product_note?: SortOrder
    supplier?: SortOrder
    udrl?: SortOrder
  }

  export type PermanentItemSumOrderByAggregateInput = {
    id?: SortOrder
    reorder_level?: SortOrder
  }

  export type saleTempEntryCountOrderByAggregateInput = {
    id?: SortOrder
    partyname?: SortOrder
    invcdt?: SortOrder
    itemName?: SortOrder
    disc?: SortOrder
    qty?: SortOrder
    rate?: SortOrder
    shpAdd?: SortOrder
  }

  export type saleTempEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    qty?: SortOrder
    rate?: SortOrder
  }

  export type saleTempEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    partyname?: SortOrder
    invcdt?: SortOrder
    itemName?: SortOrder
    disc?: SortOrder
    qty?: SortOrder
    rate?: SortOrder
    shpAdd?: SortOrder
  }

  export type saleTempEntryMinOrderByAggregateInput = {
    id?: SortOrder
    partyname?: SortOrder
    invcdt?: SortOrder
    itemName?: SortOrder
    disc?: SortOrder
    qty?: SortOrder
    rate?: SortOrder
    shpAdd?: SortOrder
  }

  export type saleTempEntrySumOrderByAggregateInput = {
    id?: SortOrder
    qty?: SortOrder
    rate?: SortOrder
  }

  export type ItemScalarRelationFilter = {
    is?: ItemWhereInput
    isNot?: ItemWhereInput
  }

  export type PartyScalarRelationFilter = {
    is?: PartyWhereInput
    isNot?: PartyWhereInput
  }

  export type CustomerPricingRuleParty_idItem_idMin_qtyCompoundUniqueInput = {
    party_id: number
    item_id: number
    min_qty: number
  }

  export type CustomerPricingRuleCountOrderByAggregateInput = {
    id?: SortOrder
    party_id?: SortOrder
    item_id?: SortOrder
    min_qty?: SortOrder
    fixed_price?: SortOrder
    effective_from?: SortOrder
    effective_to?: SortOrder
  }

  export type CustomerPricingRuleAvgOrderByAggregateInput = {
    id?: SortOrder
    party_id?: SortOrder
    item_id?: SortOrder
    min_qty?: SortOrder
    fixed_price?: SortOrder
  }

  export type CustomerPricingRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    party_id?: SortOrder
    item_id?: SortOrder
    min_qty?: SortOrder
    fixed_price?: SortOrder
    effective_from?: SortOrder
    effective_to?: SortOrder
  }

  export type CustomerPricingRuleMinOrderByAggregateInput = {
    id?: SortOrder
    party_id?: SortOrder
    item_id?: SortOrder
    min_qty?: SortOrder
    fixed_price?: SortOrder
    effective_from?: SortOrder
    effective_to?: SortOrder
  }

  export type CustomerPricingRuleSumOrderByAggregateInput = {
    id?: SortOrder
    party_id?: SortOrder
    item_id?: SortOrder
    min_qty?: SortOrder
    fixed_price?: SortOrder
  }

  export type ProductBatchStockitemIdSerialNoCompoundUniqueInput = {
    stockitemId: number
    serialNo: string
  }

  export type ProductBatchStockitemIdBatchNoCompoundUniqueInput = {
    stockitemId: number
    batchNo: string
  }

  export type ProductBatchCountOrderByAggregateInput = {
    id?: SortOrder
    stockitemId?: SortOrder
    batchNo?: SortOrder
    serialNo?: SortOrder
    expiryDate?: SortOrder
    mfgDate?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductBatchAvgOrderByAggregateInput = {
    id?: SortOrder
    stockitemId?: SortOrder
    quantity?: SortOrder
  }

  export type ProductBatchMaxOrderByAggregateInput = {
    id?: SortOrder
    stockitemId?: SortOrder
    batchNo?: SortOrder
    serialNo?: SortOrder
    expiryDate?: SortOrder
    mfgDate?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductBatchMinOrderByAggregateInput = {
    id?: SortOrder
    stockitemId?: SortOrder
    batchNo?: SortOrder
    serialNo?: SortOrder
    expiryDate?: SortOrder
    mfgDate?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductBatchSumOrderByAggregateInput = {
    id?: SortOrder
    stockitemId?: SortOrder
    quantity?: SortOrder
  }

  export type PurchaseEntryCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    partyName?: SortOrder
    purchaseNumber?: SortOrder
    itemName?: SortOrder
    quantity?: SortOrder
    purchaseRate?: SortOrder
    purchaseReferenceNumber?: SortOrder
  }

  export type PurchaseEntryAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    purchaseRate?: SortOrder
  }

  export type PurchaseEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    partyName?: SortOrder
    purchaseNumber?: SortOrder
    itemName?: SortOrder
    quantity?: SortOrder
    purchaseRate?: SortOrder
    purchaseReferenceNumber?: SortOrder
  }

  export type PurchaseEntryMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    partyName?: SortOrder
    purchaseNumber?: SortOrder
    itemName?: SortOrder
    quantity?: SortOrder
    purchaseRate?: SortOrder
    purchaseReferenceNumber?: SortOrder
  }

  export type PurchaseEntrySumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    purchaseRate?: SortOrder
  }

  export type CustomerPricingRuleCreateNestedManyWithoutPartyInput = {
    create?: XOR<CustomerPricingRuleCreateWithoutPartyInput, CustomerPricingRuleUncheckedCreateWithoutPartyInput> | CustomerPricingRuleCreateWithoutPartyInput[] | CustomerPricingRuleUncheckedCreateWithoutPartyInput[]
    connectOrCreate?: CustomerPricingRuleCreateOrConnectWithoutPartyInput | CustomerPricingRuleCreateOrConnectWithoutPartyInput[]
    createMany?: CustomerPricingRuleCreateManyPartyInputEnvelope
    connect?: CustomerPricingRuleWhereUniqueInput | CustomerPricingRuleWhereUniqueInput[]
  }

  export type CustomerPricingRuleUncheckedCreateNestedManyWithoutPartyInput = {
    create?: XOR<CustomerPricingRuleCreateWithoutPartyInput, CustomerPricingRuleUncheckedCreateWithoutPartyInput> | CustomerPricingRuleCreateWithoutPartyInput[] | CustomerPricingRuleUncheckedCreateWithoutPartyInput[]
    connectOrCreate?: CustomerPricingRuleCreateOrConnectWithoutPartyInput | CustomerPricingRuleCreateOrConnectWithoutPartyInput[]
    createMany?: CustomerPricingRuleCreateManyPartyInputEnvelope
    connect?: CustomerPricingRuleWhereUniqueInput | CustomerPricingRuleWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerPricingRuleUpdateManyWithoutPartyNestedInput = {
    create?: XOR<CustomerPricingRuleCreateWithoutPartyInput, CustomerPricingRuleUncheckedCreateWithoutPartyInput> | CustomerPricingRuleCreateWithoutPartyInput[] | CustomerPricingRuleUncheckedCreateWithoutPartyInput[]
    connectOrCreate?: CustomerPricingRuleCreateOrConnectWithoutPartyInput | CustomerPricingRuleCreateOrConnectWithoutPartyInput[]
    upsert?: CustomerPricingRuleUpsertWithWhereUniqueWithoutPartyInput | CustomerPricingRuleUpsertWithWhereUniqueWithoutPartyInput[]
    createMany?: CustomerPricingRuleCreateManyPartyInputEnvelope
    set?: CustomerPricingRuleWhereUniqueInput | CustomerPricingRuleWhereUniqueInput[]
    disconnect?: CustomerPricingRuleWhereUniqueInput | CustomerPricingRuleWhereUniqueInput[]
    delete?: CustomerPricingRuleWhereUniqueInput | CustomerPricingRuleWhereUniqueInput[]
    connect?: CustomerPricingRuleWhereUniqueInput | CustomerPricingRuleWhereUniqueInput[]
    update?: CustomerPricingRuleUpdateWithWhereUniqueWithoutPartyInput | CustomerPricingRuleUpdateWithWhereUniqueWithoutPartyInput[]
    updateMany?: CustomerPricingRuleUpdateManyWithWhereWithoutPartyInput | CustomerPricingRuleUpdateManyWithWhereWithoutPartyInput[]
    deleteMany?: CustomerPricingRuleScalarWhereInput | CustomerPricingRuleScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomerPricingRuleUncheckedUpdateManyWithoutPartyNestedInput = {
    create?: XOR<CustomerPricingRuleCreateWithoutPartyInput, CustomerPricingRuleUncheckedCreateWithoutPartyInput> | CustomerPricingRuleCreateWithoutPartyInput[] | CustomerPricingRuleUncheckedCreateWithoutPartyInput[]
    connectOrCreate?: CustomerPricingRuleCreateOrConnectWithoutPartyInput | CustomerPricingRuleCreateOrConnectWithoutPartyInput[]
    upsert?: CustomerPricingRuleUpsertWithWhereUniqueWithoutPartyInput | CustomerPricingRuleUpsertWithWhereUniqueWithoutPartyInput[]
    createMany?: CustomerPricingRuleCreateManyPartyInputEnvelope
    set?: CustomerPricingRuleWhereUniqueInput | CustomerPricingRuleWhereUniqueInput[]
    disconnect?: CustomerPricingRuleWhereUniqueInput | CustomerPricingRuleWhereUniqueInput[]
    delete?: CustomerPricingRuleWhereUniqueInput | CustomerPricingRuleWhereUniqueInput[]
    connect?: CustomerPricingRuleWhereUniqueInput | CustomerPricingRuleWhereUniqueInput[]
    update?: CustomerPricingRuleUpdateWithWhereUniqueWithoutPartyInput | CustomerPricingRuleUpdateWithWhereUniqueWithoutPartyInput[]
    updateMany?: CustomerPricingRuleUpdateManyWithWhereWithoutPartyInput | CustomerPricingRuleUpdateManyWithWhereWithoutPartyInput[]
    deleteMany?: CustomerPricingRuleScalarWhereInput | CustomerPricingRuleScalarWhereInput[]
  }

  export type CustomerPricingRuleCreateNestedManyWithoutItemInput = {
    create?: XOR<CustomerPricingRuleCreateWithoutItemInput, CustomerPricingRuleUncheckedCreateWithoutItemInput> | CustomerPricingRuleCreateWithoutItemInput[] | CustomerPricingRuleUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CustomerPricingRuleCreateOrConnectWithoutItemInput | CustomerPricingRuleCreateOrConnectWithoutItemInput[]
    createMany?: CustomerPricingRuleCreateManyItemInputEnvelope
    connect?: CustomerPricingRuleWhereUniqueInput | CustomerPricingRuleWhereUniqueInput[]
  }

  export type CustomerPricingRuleUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<CustomerPricingRuleCreateWithoutItemInput, CustomerPricingRuleUncheckedCreateWithoutItemInput> | CustomerPricingRuleCreateWithoutItemInput[] | CustomerPricingRuleUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CustomerPricingRuleCreateOrConnectWithoutItemInput | CustomerPricingRuleCreateOrConnectWithoutItemInput[]
    createMany?: CustomerPricingRuleCreateManyItemInputEnvelope
    connect?: CustomerPricingRuleWhereUniqueInput | CustomerPricingRuleWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CustomerPricingRuleUpdateManyWithoutItemNestedInput = {
    create?: XOR<CustomerPricingRuleCreateWithoutItemInput, CustomerPricingRuleUncheckedCreateWithoutItemInput> | CustomerPricingRuleCreateWithoutItemInput[] | CustomerPricingRuleUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CustomerPricingRuleCreateOrConnectWithoutItemInput | CustomerPricingRuleCreateOrConnectWithoutItemInput[]
    upsert?: CustomerPricingRuleUpsertWithWhereUniqueWithoutItemInput | CustomerPricingRuleUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: CustomerPricingRuleCreateManyItemInputEnvelope
    set?: CustomerPricingRuleWhereUniqueInput | CustomerPricingRuleWhereUniqueInput[]
    disconnect?: CustomerPricingRuleWhereUniqueInput | CustomerPricingRuleWhereUniqueInput[]
    delete?: CustomerPricingRuleWhereUniqueInput | CustomerPricingRuleWhereUniqueInput[]
    connect?: CustomerPricingRuleWhereUniqueInput | CustomerPricingRuleWhereUniqueInput[]
    update?: CustomerPricingRuleUpdateWithWhereUniqueWithoutItemInput | CustomerPricingRuleUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: CustomerPricingRuleUpdateManyWithWhereWithoutItemInput | CustomerPricingRuleUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: CustomerPricingRuleScalarWhereInput | CustomerPricingRuleScalarWhereInput[]
  }

  export type CustomerPricingRuleUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<CustomerPricingRuleCreateWithoutItemInput, CustomerPricingRuleUncheckedCreateWithoutItemInput> | CustomerPricingRuleCreateWithoutItemInput[] | CustomerPricingRuleUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CustomerPricingRuleCreateOrConnectWithoutItemInput | CustomerPricingRuleCreateOrConnectWithoutItemInput[]
    upsert?: CustomerPricingRuleUpsertWithWhereUniqueWithoutItemInput | CustomerPricingRuleUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: CustomerPricingRuleCreateManyItemInputEnvelope
    set?: CustomerPricingRuleWhereUniqueInput | CustomerPricingRuleWhereUniqueInput[]
    disconnect?: CustomerPricingRuleWhereUniqueInput | CustomerPricingRuleWhereUniqueInput[]
    delete?: CustomerPricingRuleWhereUniqueInput | CustomerPricingRuleWhereUniqueInput[]
    connect?: CustomerPricingRuleWhereUniqueInput | CustomerPricingRuleWhereUniqueInput[]
    update?: CustomerPricingRuleUpdateWithWhereUniqueWithoutItemInput | CustomerPricingRuleUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: CustomerPricingRuleUpdateManyWithWhereWithoutItemInput | CustomerPricingRuleUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: CustomerPricingRuleScalarWhereInput | CustomerPricingRuleScalarWhereInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ProductBatchCreateNestedManyWithoutStockItemInput = {
    create?: XOR<ProductBatchCreateWithoutStockItemInput, ProductBatchUncheckedCreateWithoutStockItemInput> | ProductBatchCreateWithoutStockItemInput[] | ProductBatchUncheckedCreateWithoutStockItemInput[]
    connectOrCreate?: ProductBatchCreateOrConnectWithoutStockItemInput | ProductBatchCreateOrConnectWithoutStockItemInput[]
    createMany?: ProductBatchCreateManyStockItemInputEnvelope
    connect?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
  }

  export type PermanentItemCreateNestedOneWithoutStockItemInput = {
    create?: XOR<PermanentItemCreateWithoutStockItemInput, PermanentItemUncheckedCreateWithoutStockItemInput>
    connectOrCreate?: PermanentItemCreateOrConnectWithoutStockItemInput
    connect?: PermanentItemWhereUniqueInput
  }

  export type ProductBatchUncheckedCreateNestedManyWithoutStockItemInput = {
    create?: XOR<ProductBatchCreateWithoutStockItemInput, ProductBatchUncheckedCreateWithoutStockItemInput> | ProductBatchCreateWithoutStockItemInput[] | ProductBatchUncheckedCreateWithoutStockItemInput[]
    connectOrCreate?: ProductBatchCreateOrConnectWithoutStockItemInput | ProductBatchCreateOrConnectWithoutStockItemInput[]
    createMany?: ProductBatchCreateManyStockItemInputEnvelope
    connect?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
  }

  export type PermanentItemUncheckedCreateNestedOneWithoutStockItemInput = {
    create?: XOR<PermanentItemCreateWithoutStockItemInput, PermanentItemUncheckedCreateWithoutStockItemInput>
    connectOrCreate?: PermanentItemCreateOrConnectWithoutStockItemInput
    connect?: PermanentItemWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductBatchUpdateManyWithoutStockItemNestedInput = {
    create?: XOR<ProductBatchCreateWithoutStockItemInput, ProductBatchUncheckedCreateWithoutStockItemInput> | ProductBatchCreateWithoutStockItemInput[] | ProductBatchUncheckedCreateWithoutStockItemInput[]
    connectOrCreate?: ProductBatchCreateOrConnectWithoutStockItemInput | ProductBatchCreateOrConnectWithoutStockItemInput[]
    upsert?: ProductBatchUpsertWithWhereUniqueWithoutStockItemInput | ProductBatchUpsertWithWhereUniqueWithoutStockItemInput[]
    createMany?: ProductBatchCreateManyStockItemInputEnvelope
    set?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    disconnect?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    delete?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    connect?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    update?: ProductBatchUpdateWithWhereUniqueWithoutStockItemInput | ProductBatchUpdateWithWhereUniqueWithoutStockItemInput[]
    updateMany?: ProductBatchUpdateManyWithWhereWithoutStockItemInput | ProductBatchUpdateManyWithWhereWithoutStockItemInput[]
    deleteMany?: ProductBatchScalarWhereInput | ProductBatchScalarWhereInput[]
  }

  export type PermanentItemUpdateOneWithoutStockItemNestedInput = {
    create?: XOR<PermanentItemCreateWithoutStockItemInput, PermanentItemUncheckedCreateWithoutStockItemInput>
    connectOrCreate?: PermanentItemCreateOrConnectWithoutStockItemInput
    upsert?: PermanentItemUpsertWithoutStockItemInput
    disconnect?: PermanentItemWhereInput | boolean
    delete?: PermanentItemWhereInput | boolean
    connect?: PermanentItemWhereUniqueInput
    update?: XOR<XOR<PermanentItemUpdateToOneWithWhereWithoutStockItemInput, PermanentItemUpdateWithoutStockItemInput>, PermanentItemUncheckedUpdateWithoutStockItemInput>
  }

  export type ProductBatchUncheckedUpdateManyWithoutStockItemNestedInput = {
    create?: XOR<ProductBatchCreateWithoutStockItemInput, ProductBatchUncheckedCreateWithoutStockItemInput> | ProductBatchCreateWithoutStockItemInput[] | ProductBatchUncheckedCreateWithoutStockItemInput[]
    connectOrCreate?: ProductBatchCreateOrConnectWithoutStockItemInput | ProductBatchCreateOrConnectWithoutStockItemInput[]
    upsert?: ProductBatchUpsertWithWhereUniqueWithoutStockItemInput | ProductBatchUpsertWithWhereUniqueWithoutStockItemInput[]
    createMany?: ProductBatchCreateManyStockItemInputEnvelope
    set?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    disconnect?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    delete?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    connect?: ProductBatchWhereUniqueInput | ProductBatchWhereUniqueInput[]
    update?: ProductBatchUpdateWithWhereUniqueWithoutStockItemInput | ProductBatchUpdateWithWhereUniqueWithoutStockItemInput[]
    updateMany?: ProductBatchUpdateManyWithWhereWithoutStockItemInput | ProductBatchUpdateManyWithWhereWithoutStockItemInput[]
    deleteMany?: ProductBatchScalarWhereInput | ProductBatchScalarWhereInput[]
  }

  export type PermanentItemUncheckedUpdateOneWithoutStockItemNestedInput = {
    create?: XOR<PermanentItemCreateWithoutStockItemInput, PermanentItemUncheckedCreateWithoutStockItemInput>
    connectOrCreate?: PermanentItemCreateOrConnectWithoutStockItemInput
    upsert?: PermanentItemUpsertWithoutStockItemInput
    disconnect?: PermanentItemWhereInput | boolean
    delete?: PermanentItemWhereInput | boolean
    connect?: PermanentItemWhereUniqueInput
    update?: XOR<XOR<PermanentItemUpdateToOneWithWhereWithoutStockItemInput, PermanentItemUpdateWithoutStockItemInput>, PermanentItemUncheckedUpdateWithoutStockItemInput>
  }

  export type StockItemCreateNestedOneWithoutPermanentItemInput = {
    create?: XOR<StockItemCreateWithoutPermanentItemInput, StockItemUncheckedCreateWithoutPermanentItemInput>
    connectOrCreate?: StockItemCreateOrConnectWithoutPermanentItemInput
    connect?: StockItemWhereUniqueInput
  }

  export type StockItemUpdateOneRequiredWithoutPermanentItemNestedInput = {
    create?: XOR<StockItemCreateWithoutPermanentItemInput, StockItemUncheckedCreateWithoutPermanentItemInput>
    connectOrCreate?: StockItemCreateOrConnectWithoutPermanentItemInput
    upsert?: StockItemUpsertWithoutPermanentItemInput
    connect?: StockItemWhereUniqueInput
    update?: XOR<XOR<StockItemUpdateToOneWithWhereWithoutPermanentItemInput, StockItemUpdateWithoutPermanentItemInput>, StockItemUncheckedUpdateWithoutPermanentItemInput>
  }

  export type ItemCreateNestedOneWithoutPricingRulesInput = {
    create?: XOR<ItemCreateWithoutPricingRulesInput, ItemUncheckedCreateWithoutPricingRulesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPricingRulesInput
    connect?: ItemWhereUniqueInput
  }

  export type PartyCreateNestedOneWithoutPricingRulesInput = {
    create?: XOR<PartyCreateWithoutPricingRulesInput, PartyUncheckedCreateWithoutPricingRulesInput>
    connectOrCreate?: PartyCreateOrConnectWithoutPricingRulesInput
    connect?: PartyWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutPricingRulesNestedInput = {
    create?: XOR<ItemCreateWithoutPricingRulesInput, ItemUncheckedCreateWithoutPricingRulesInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPricingRulesInput
    upsert?: ItemUpsertWithoutPricingRulesInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutPricingRulesInput, ItemUpdateWithoutPricingRulesInput>, ItemUncheckedUpdateWithoutPricingRulesInput>
  }

  export type PartyUpdateOneRequiredWithoutPricingRulesNestedInput = {
    create?: XOR<PartyCreateWithoutPricingRulesInput, PartyUncheckedCreateWithoutPricingRulesInput>
    connectOrCreate?: PartyCreateOrConnectWithoutPricingRulesInput
    upsert?: PartyUpsertWithoutPricingRulesInput
    connect?: PartyWhereUniqueInput
    update?: XOR<XOR<PartyUpdateToOneWithWhereWithoutPricingRulesInput, PartyUpdateWithoutPricingRulesInput>, PartyUncheckedUpdateWithoutPricingRulesInput>
  }

  export type StockItemCreateNestedOneWithoutProductBatchesInput = {
    create?: XOR<StockItemCreateWithoutProductBatchesInput, StockItemUncheckedCreateWithoutProductBatchesInput>
    connectOrCreate?: StockItemCreateOrConnectWithoutProductBatchesInput
    connect?: StockItemWhereUniqueInput
  }

  export type StockItemUpdateOneRequiredWithoutProductBatchesNestedInput = {
    create?: XOR<StockItemCreateWithoutProductBatchesInput, StockItemUncheckedCreateWithoutProductBatchesInput>
    connectOrCreate?: StockItemCreateOrConnectWithoutProductBatchesInput
    upsert?: StockItemUpsertWithoutProductBatchesInput
    connect?: StockItemWhereUniqueInput
    update?: XOR<XOR<StockItemUpdateToOneWithWhereWithoutProductBatchesInput, StockItemUpdateWithoutProductBatchesInput>, StockItemUncheckedUpdateWithoutProductBatchesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CustomerPricingRuleCreateWithoutPartyInput = {
    min_qty?: number | null
    fixed_price: Decimal | DecimalJsLike | number | string
    effective_from?: Date | string
    effective_to?: Date | string | null
    item: ItemCreateNestedOneWithoutPricingRulesInput
  }

  export type CustomerPricingRuleUncheckedCreateWithoutPartyInput = {
    id?: number
    item_id: number
    min_qty?: number | null
    fixed_price: Decimal | DecimalJsLike | number | string
    effective_from?: Date | string
    effective_to?: Date | string | null
  }

  export type CustomerPricingRuleCreateOrConnectWithoutPartyInput = {
    where: CustomerPricingRuleWhereUniqueInput
    create: XOR<CustomerPricingRuleCreateWithoutPartyInput, CustomerPricingRuleUncheckedCreateWithoutPartyInput>
  }

  export type CustomerPricingRuleCreateManyPartyInputEnvelope = {
    data: CustomerPricingRuleCreateManyPartyInput | CustomerPricingRuleCreateManyPartyInput[]
    skipDuplicates?: boolean
  }

  export type CustomerPricingRuleUpsertWithWhereUniqueWithoutPartyInput = {
    where: CustomerPricingRuleWhereUniqueInput
    update: XOR<CustomerPricingRuleUpdateWithoutPartyInput, CustomerPricingRuleUncheckedUpdateWithoutPartyInput>
    create: XOR<CustomerPricingRuleCreateWithoutPartyInput, CustomerPricingRuleUncheckedCreateWithoutPartyInput>
  }

  export type CustomerPricingRuleUpdateWithWhereUniqueWithoutPartyInput = {
    where: CustomerPricingRuleWhereUniqueInput
    data: XOR<CustomerPricingRuleUpdateWithoutPartyInput, CustomerPricingRuleUncheckedUpdateWithoutPartyInput>
  }

  export type CustomerPricingRuleUpdateManyWithWhereWithoutPartyInput = {
    where: CustomerPricingRuleScalarWhereInput
    data: XOR<CustomerPricingRuleUpdateManyMutationInput, CustomerPricingRuleUncheckedUpdateManyWithoutPartyInput>
  }

  export type CustomerPricingRuleScalarWhereInput = {
    AND?: CustomerPricingRuleScalarWhereInput | CustomerPricingRuleScalarWhereInput[]
    OR?: CustomerPricingRuleScalarWhereInput[]
    NOT?: CustomerPricingRuleScalarWhereInput | CustomerPricingRuleScalarWhereInput[]
    id?: IntFilter<"CustomerPricingRule"> | number
    party_id?: IntFilter<"CustomerPricingRule"> | number
    item_id?: IntFilter<"CustomerPricingRule"> | number
    min_qty?: IntNullableFilter<"CustomerPricingRule"> | number | null
    fixed_price?: DecimalFilter<"CustomerPricingRule"> | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFilter<"CustomerPricingRule"> | Date | string
    effective_to?: DateTimeNullableFilter<"CustomerPricingRule"> | Date | string | null
  }

  export type CustomerPricingRuleCreateWithoutItemInput = {
    min_qty?: number | null
    fixed_price: Decimal | DecimalJsLike | number | string
    effective_from?: Date | string
    effective_to?: Date | string | null
    party: PartyCreateNestedOneWithoutPricingRulesInput
  }

  export type CustomerPricingRuleUncheckedCreateWithoutItemInput = {
    id?: number
    party_id: number
    min_qty?: number | null
    fixed_price: Decimal | DecimalJsLike | number | string
    effective_from?: Date | string
    effective_to?: Date | string | null
  }

  export type CustomerPricingRuleCreateOrConnectWithoutItemInput = {
    where: CustomerPricingRuleWhereUniqueInput
    create: XOR<CustomerPricingRuleCreateWithoutItemInput, CustomerPricingRuleUncheckedCreateWithoutItemInput>
  }

  export type CustomerPricingRuleCreateManyItemInputEnvelope = {
    data: CustomerPricingRuleCreateManyItemInput | CustomerPricingRuleCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type CustomerPricingRuleUpsertWithWhereUniqueWithoutItemInput = {
    where: CustomerPricingRuleWhereUniqueInput
    update: XOR<CustomerPricingRuleUpdateWithoutItemInput, CustomerPricingRuleUncheckedUpdateWithoutItemInput>
    create: XOR<CustomerPricingRuleCreateWithoutItemInput, CustomerPricingRuleUncheckedCreateWithoutItemInput>
  }

  export type CustomerPricingRuleUpdateWithWhereUniqueWithoutItemInput = {
    where: CustomerPricingRuleWhereUniqueInput
    data: XOR<CustomerPricingRuleUpdateWithoutItemInput, CustomerPricingRuleUncheckedUpdateWithoutItemInput>
  }

  export type CustomerPricingRuleUpdateManyWithWhereWithoutItemInput = {
    where: CustomerPricingRuleScalarWhereInput
    data: XOR<CustomerPricingRuleUpdateManyMutationInput, CustomerPricingRuleUncheckedUpdateManyWithoutItemInput>
  }

  export type ProductBatchCreateWithoutStockItemInput = {
    batchNo: string
    serialNo?: string | null
    expiryDate?: Date | string | null
    mfgDate?: Date | string | null
    quantity: number
    createdAt?: Date | string
  }

  export type ProductBatchUncheckedCreateWithoutStockItemInput = {
    id?: number
    batchNo: string
    serialNo?: string | null
    expiryDate?: Date | string | null
    mfgDate?: Date | string | null
    quantity: number
    createdAt?: Date | string
  }

  export type ProductBatchCreateOrConnectWithoutStockItemInput = {
    where: ProductBatchWhereUniqueInput
    create: XOR<ProductBatchCreateWithoutStockItemInput, ProductBatchUncheckedCreateWithoutStockItemInput>
  }

  export type ProductBatchCreateManyStockItemInputEnvelope = {
    data: ProductBatchCreateManyStockItemInput | ProductBatchCreateManyStockItemInput[]
    skipDuplicates?: boolean
  }

  export type PermanentItemCreateWithoutStockItemInput = {
    name?: string | null
    reorder_level?: number | null
    product_note?: string | null
    supplier?: string | null
    udrl?: string | null
  }

  export type PermanentItemUncheckedCreateWithoutStockItemInput = {
    id?: number
    name?: string | null
    reorder_level?: number | null
    product_note?: string | null
    supplier?: string | null
    udrl?: string | null
  }

  export type PermanentItemCreateOrConnectWithoutStockItemInput = {
    where: PermanentItemWhereUniqueInput
    create: XOR<PermanentItemCreateWithoutStockItemInput, PermanentItemUncheckedCreateWithoutStockItemInput>
  }

  export type ProductBatchUpsertWithWhereUniqueWithoutStockItemInput = {
    where: ProductBatchWhereUniqueInput
    update: XOR<ProductBatchUpdateWithoutStockItemInput, ProductBatchUncheckedUpdateWithoutStockItemInput>
    create: XOR<ProductBatchCreateWithoutStockItemInput, ProductBatchUncheckedCreateWithoutStockItemInput>
  }

  export type ProductBatchUpdateWithWhereUniqueWithoutStockItemInput = {
    where: ProductBatchWhereUniqueInput
    data: XOR<ProductBatchUpdateWithoutStockItemInput, ProductBatchUncheckedUpdateWithoutStockItemInput>
  }

  export type ProductBatchUpdateManyWithWhereWithoutStockItemInput = {
    where: ProductBatchScalarWhereInput
    data: XOR<ProductBatchUpdateManyMutationInput, ProductBatchUncheckedUpdateManyWithoutStockItemInput>
  }

  export type ProductBatchScalarWhereInput = {
    AND?: ProductBatchScalarWhereInput | ProductBatchScalarWhereInput[]
    OR?: ProductBatchScalarWhereInput[]
    NOT?: ProductBatchScalarWhereInput | ProductBatchScalarWhereInput[]
    id?: IntFilter<"ProductBatch"> | number
    stockitemId?: IntFilter<"ProductBatch"> | number
    batchNo?: StringFilter<"ProductBatch"> | string
    serialNo?: StringNullableFilter<"ProductBatch"> | string | null
    expiryDate?: DateTimeNullableFilter<"ProductBatch"> | Date | string | null
    mfgDate?: DateTimeNullableFilter<"ProductBatch"> | Date | string | null
    quantity?: IntFilter<"ProductBatch"> | number
    createdAt?: DateTimeFilter<"ProductBatch"> | Date | string
  }

  export type PermanentItemUpsertWithoutStockItemInput = {
    update: XOR<PermanentItemUpdateWithoutStockItemInput, PermanentItemUncheckedUpdateWithoutStockItemInput>
    create: XOR<PermanentItemCreateWithoutStockItemInput, PermanentItemUncheckedCreateWithoutStockItemInput>
    where?: PermanentItemWhereInput
  }

  export type PermanentItemUpdateToOneWithWhereWithoutStockItemInput = {
    where?: PermanentItemWhereInput
    data: XOR<PermanentItemUpdateWithoutStockItemInput, PermanentItemUncheckedUpdateWithoutStockItemInput>
  }

  export type PermanentItemUpdateWithoutStockItemInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    reorder_level?: NullableIntFieldUpdateOperationsInput | number | null
    product_note?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    udrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermanentItemUncheckedUpdateWithoutStockItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    reorder_level?: NullableIntFieldUpdateOperationsInput | number | null
    product_note?: NullableStringFieldUpdateOperationsInput | string | null
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    udrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockItemCreateWithoutPermanentItemInput = {
    uid: string
    name: string
    hsncode?: string | null
    buyingprice: number
    supplier?: string | null
    tax?: number | null
    stock: number
    productBatches?: ProductBatchCreateNestedManyWithoutStockItemInput
  }

  export type StockItemUncheckedCreateWithoutPermanentItemInput = {
    id?: number
    uid: string
    name: string
    hsncode?: string | null
    buyingprice: number
    supplier?: string | null
    tax?: number | null
    stock: number
    productBatches?: ProductBatchUncheckedCreateNestedManyWithoutStockItemInput
  }

  export type StockItemCreateOrConnectWithoutPermanentItemInput = {
    where: StockItemWhereUniqueInput
    create: XOR<StockItemCreateWithoutPermanentItemInput, StockItemUncheckedCreateWithoutPermanentItemInput>
  }

  export type StockItemUpsertWithoutPermanentItemInput = {
    update: XOR<StockItemUpdateWithoutPermanentItemInput, StockItemUncheckedUpdateWithoutPermanentItemInput>
    create: XOR<StockItemCreateWithoutPermanentItemInput, StockItemUncheckedCreateWithoutPermanentItemInput>
    where?: StockItemWhereInput
  }

  export type StockItemUpdateToOneWithWhereWithoutPermanentItemInput = {
    where?: StockItemWhereInput
    data: XOR<StockItemUpdateWithoutPermanentItemInput, StockItemUncheckedUpdateWithoutPermanentItemInput>
  }

  export type StockItemUpdateWithoutPermanentItemInput = {
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hsncode?: NullableStringFieldUpdateOperationsInput | string | null
    buyingprice?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    productBatches?: ProductBatchUpdateManyWithoutStockItemNestedInput
  }

  export type StockItemUncheckedUpdateWithoutPermanentItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hsncode?: NullableStringFieldUpdateOperationsInput | string | null
    buyingprice?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    productBatches?: ProductBatchUncheckedUpdateManyWithoutStockItemNestedInput
  }

  export type ItemCreateWithoutPricingRulesInput = {
    name: string
    hsn?: number | null
    min?: number | null
    rate?: number | null
    tax?: number | null
    vendor?: string | null
    mrp?: Decimal | DecimalJsLike | number | string | null
    stockIn?: number | null
    stockHold?: number | null
    stockOut?: number | null
    productType?: string | null
  }

  export type ItemUncheckedCreateWithoutPricingRulesInput = {
    id?: number
    name: string
    hsn?: number | null
    min?: number | null
    rate?: number | null
    tax?: number | null
    vendor?: string | null
    mrp?: Decimal | DecimalJsLike | number | string | null
    stockIn?: number | null
    stockHold?: number | null
    stockOut?: number | null
    productType?: string | null
  }

  export type ItemCreateOrConnectWithoutPricingRulesInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutPricingRulesInput, ItemUncheckedCreateWithoutPricingRulesInput>
  }

  export type PartyCreateWithoutPricingRulesInput = {
    name: string
    address?: string | null
    code?: number | null
    contact?: string | null
    credit?: number | null
    dlno?: string | null
    gst?: string | null
    state?: string | null
    type?: string | null
    shipping_address?: string | null
    credit_period?: string | null
  }

  export type PartyUncheckedCreateWithoutPricingRulesInput = {
    id?: number
    name: string
    address?: string | null
    code?: number | null
    contact?: string | null
    credit?: number | null
    dlno?: string | null
    gst?: string | null
    state?: string | null
    type?: string | null
    shipping_address?: string | null
    credit_period?: string | null
  }

  export type PartyCreateOrConnectWithoutPricingRulesInput = {
    where: PartyWhereUniqueInput
    create: XOR<PartyCreateWithoutPricingRulesInput, PartyUncheckedCreateWithoutPricingRulesInput>
  }

  export type ItemUpsertWithoutPricingRulesInput = {
    update: XOR<ItemUpdateWithoutPricingRulesInput, ItemUncheckedUpdateWithoutPricingRulesInput>
    create: XOR<ItemCreateWithoutPricingRulesInput, ItemUncheckedCreateWithoutPricingRulesInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutPricingRulesInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutPricingRulesInput, ItemUncheckedUpdateWithoutPricingRulesInput>
  }

  export type ItemUpdateWithoutPricingRulesInput = {
    name?: StringFieldUpdateOperationsInput | string
    hsn?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    mrp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stockIn?: NullableIntFieldUpdateOperationsInput | number | null
    stockHold?: NullableIntFieldUpdateOperationsInput | number | null
    stockOut?: NullableIntFieldUpdateOperationsInput | number | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemUncheckedUpdateWithoutPricingRulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    hsn?: NullableIntFieldUpdateOperationsInput | number | null
    min?: NullableIntFieldUpdateOperationsInput | number | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    mrp?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    stockIn?: NullableIntFieldUpdateOperationsInput | number | null
    stockHold?: NullableIntFieldUpdateOperationsInput | number | null
    stockOut?: NullableIntFieldUpdateOperationsInput | number | null
    productType?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PartyUpsertWithoutPricingRulesInput = {
    update: XOR<PartyUpdateWithoutPricingRulesInput, PartyUncheckedUpdateWithoutPricingRulesInput>
    create: XOR<PartyCreateWithoutPricingRulesInput, PartyUncheckedCreateWithoutPricingRulesInput>
    where?: PartyWhereInput
  }

  export type PartyUpdateToOneWithWhereWithoutPricingRulesInput = {
    where?: PartyWhereInput
    data: XOR<PartyUpdateWithoutPricingRulesInput, PartyUncheckedUpdateWithoutPricingRulesInput>
  }

  export type PartyUpdateWithoutPricingRulesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableIntFieldUpdateOperationsInput | number | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: NullableFloatFieldUpdateOperationsInput | number | null
    dlno?: NullableStringFieldUpdateOperationsInput | string | null
    gst?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address?: NullableStringFieldUpdateOperationsInput | string | null
    credit_period?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PartyUncheckedUpdateWithoutPricingRulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableIntFieldUpdateOperationsInput | number | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    credit?: NullableFloatFieldUpdateOperationsInput | number | null
    dlno?: NullableStringFieldUpdateOperationsInput | string | null
    gst?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    shipping_address?: NullableStringFieldUpdateOperationsInput | string | null
    credit_period?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockItemCreateWithoutProductBatchesInput = {
    uid: string
    name: string
    hsncode?: string | null
    buyingprice: number
    supplier?: string | null
    tax?: number | null
    stock: number
    permanentItem?: PermanentItemCreateNestedOneWithoutStockItemInput
  }

  export type StockItemUncheckedCreateWithoutProductBatchesInput = {
    id?: number
    uid: string
    name: string
    hsncode?: string | null
    buyingprice: number
    supplier?: string | null
    tax?: number | null
    stock: number
    permanentItem?: PermanentItemUncheckedCreateNestedOneWithoutStockItemInput
  }

  export type StockItemCreateOrConnectWithoutProductBatchesInput = {
    where: StockItemWhereUniqueInput
    create: XOR<StockItemCreateWithoutProductBatchesInput, StockItemUncheckedCreateWithoutProductBatchesInput>
  }

  export type StockItemUpsertWithoutProductBatchesInput = {
    update: XOR<StockItemUpdateWithoutProductBatchesInput, StockItemUncheckedUpdateWithoutProductBatchesInput>
    create: XOR<StockItemCreateWithoutProductBatchesInput, StockItemUncheckedCreateWithoutProductBatchesInput>
    where?: StockItemWhereInput
  }

  export type StockItemUpdateToOneWithWhereWithoutProductBatchesInput = {
    where?: StockItemWhereInput
    data: XOR<StockItemUpdateWithoutProductBatchesInput, StockItemUncheckedUpdateWithoutProductBatchesInput>
  }

  export type StockItemUpdateWithoutProductBatchesInput = {
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hsncode?: NullableStringFieldUpdateOperationsInput | string | null
    buyingprice?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    permanentItem?: PermanentItemUpdateOneWithoutStockItemNestedInput
  }

  export type StockItemUncheckedUpdateWithoutProductBatchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hsncode?: NullableStringFieldUpdateOperationsInput | string | null
    buyingprice?: FloatFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    tax?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    permanentItem?: PermanentItemUncheckedUpdateOneWithoutStockItemNestedInput
  }

  export type CustomerPricingRuleCreateManyPartyInput = {
    id?: number
    item_id: number
    min_qty?: number | null
    fixed_price: Decimal | DecimalJsLike | number | string
    effective_from?: Date | string
    effective_to?: Date | string | null
  }

  export type CustomerPricingRuleUpdateWithoutPartyInput = {
    min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFieldUpdateOperationsInput | Date | string
    effective_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    item?: ItemUpdateOneRequiredWithoutPricingRulesNestedInput
  }

  export type CustomerPricingRuleUncheckedUpdateWithoutPartyInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFieldUpdateOperationsInput | Date | string
    effective_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerPricingRuleUncheckedUpdateManyWithoutPartyInput = {
    id?: IntFieldUpdateOperationsInput | number
    item_id?: IntFieldUpdateOperationsInput | number
    min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFieldUpdateOperationsInput | Date | string
    effective_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerPricingRuleCreateManyItemInput = {
    id?: number
    party_id: number
    min_qty?: number | null
    fixed_price: Decimal | DecimalJsLike | number | string
    effective_from?: Date | string
    effective_to?: Date | string | null
  }

  export type CustomerPricingRuleUpdateWithoutItemInput = {
    min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFieldUpdateOperationsInput | Date | string
    effective_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    party?: PartyUpdateOneRequiredWithoutPricingRulesNestedInput
  }

  export type CustomerPricingRuleUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    party_id?: IntFieldUpdateOperationsInput | number
    min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFieldUpdateOperationsInput | Date | string
    effective_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerPricingRuleUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    party_id?: IntFieldUpdateOperationsInput | number
    min_qty?: NullableIntFieldUpdateOperationsInput | number | null
    fixed_price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effective_from?: DateTimeFieldUpdateOperationsInput | Date | string
    effective_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductBatchCreateManyStockItemInput = {
    id?: number
    batchNo: string
    serialNo?: string | null
    expiryDate?: Date | string | null
    mfgDate?: Date | string | null
    quantity: number
    createdAt?: Date | string
  }

  export type ProductBatchUpdateWithoutStockItemInput = {
    batchNo?: StringFieldUpdateOperationsInput | string
    serialNo?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfgDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductBatchUncheckedUpdateWithoutStockItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchNo?: StringFieldUpdateOperationsInput | string
    serialNo?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfgDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductBatchUncheckedUpdateManyWithoutStockItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    batchNo?: StringFieldUpdateOperationsInput | string
    serialNo?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mfgDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}